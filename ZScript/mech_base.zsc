// Powerups and Cockpit Effects

class SuperCooled : Powerup
{

	Default
	{
		Powerup.Duration 2100; // lasts 1 minute;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		if (Owner == NULL)
		{
			return;
		}
		
		let mech = MechWarrior(Owner.player.mo);
		mech.supersink = true;
	}
	
	override void EndEffect()
	{
		super.EndEffect();

		if (Owner == NULL)
		{
			return;
		}
		
		let mech = MechWarrior(Owner.player.mo);
		mech.supersink = false;
	}
}

class InfraredAmp : PowerLightAmp 
{
	int fadeto;
	bool activate;
	
	Default
	{
		Powerup.Duration 0x7FFFFFFD; // lasts about 2 years;
	}
	
	override void PostBeginPlay()
	{
		fadeto = BlendColor.a;
		BlendColor.a = 0;
	}
	
	override void tick()
	{
		if(BlendColor.a < fadeto)
		{
			BlendColor.a += (fadeto) / (35 * 0.3); // .3 Second fade
			Colormap = ((BlendColor & 0xFFFF0000) == SPECIALCOLORMAP_MASK)? BlendColor & 0xffff : PlayerInfo.NOFIXEDCOLORMAP;
		}
		
		// Activate powerup halfway through fade.
		if(BlendColor.a > fadeto/2)	activate = true;
		
	}
	
	override void DoEffect()
	{
		if(activate) super.DoEffect();
	}
	
}


class SuperCoolant : PowerupGiver
{
	Default
	{
		+COUNTITEM
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.BIGPOWERUP
		Inventory.MaxAmount 0;
		Powerup.Type "SuperCooled";
		Powerup.Color "B0 DB E8", 0.154;
		Inventory.PickupMessage "Heatsink Overclock!";
	}
}

class InfraredGiver : PowerupGiver
{
	Default
	{
		+INVENTORY.AUTOACTIVATE
		Inventory.MaxAmount 0;
		Powerup.Type "InfraredAmp";
		Powerup.Color "DB 35 18", 0.437;
		Inventory.PickupMessage "Infrared Engaged";
	}
}

class SuperCoolant_Pickup : CustomInventory replaces Berserk
{
	Default
	{
		+COUNTITEM
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.ISHEALTH
		Inventory.PickupMessage "Heatsink Overclock!";
		Inventory.PickupSound "misc/p_pkup";
	}
	States
	{
	Spawn:
		TNT1 A 0;
		HSNK A -1;
		Stop;
	Pickup:
		TNT1 A 0 A_GiveInventory("SuperCoolant");
		HSNK A 0 HealThing(100, 0);
		Stop;
	}
}


struct WeaponGroups
{
	enum WeaponGroups 
	{
		ONE   = 1,
		TWO   = 2,
		THREE = 4,
		FOUR  = 8,
	};
}

struct HudAlert 
{	
	String text;
	int col;
}

class MechWarrior : DoomPlayer
{
	/* 
		Intrinsic <type> = These are types nessesary to define the mech.
		Volatile  <type> = These are sometimes derived values, do not define an individual mech.	
	*/

	// Volatile pointers
	Actor targetenemy;
	Actor prevlock;
	MechTargetReticle targetreticle;
	MechHardpoints hardpoints;
	HudAlert hAlert;
	SoundQueue mechsounds;
	
	// Intrinsic Arrays
	Array<String> weapon_items; // Stores all mech items before they go into the inventory.
	Array<String> mechstructs;  // These are equipped structs.
	Array<Int> mechstructs_x;   // Can't create struct dynarray. hardpoint x.
	Array<Int> mechstructs_y;   // Can't create sturct dynarray. hardpoint y


	// Volatile ints
	int selectedGroup;
	int selectedWeapon;
	int weapons;
	int ticks;
	int prevticks;
	int money_cbills; 			// (Special case, gets moved between mechs; Context dependant volatility)
	int shutdown_timer;
	int Mech_JetCount;
	int ams_timer;
	int maxgroup;
	int boblendir;
	
	
	// Intrinsic floats
	float baseHeatEfficiency;
	float LegSpeed;
	float MaxYaw;
	float MaxPitch;
	float LookSpeed;
	float MoveSpeedKPH;
	float pitchRange;
	float mech_tonnage;
	float enginesize;
	
	// Volatile floats
	float LegAng;
	float LookAngle;
	float lockpitch;
	float lockangle;
	float HeatLevel;
	float prevheat;
	float deltaHeat;
	float HeatEfficiency;
	float LookVel;
	float MoveSpeed;
	float MoveSpeed_Max;
	float LegVel;
	float throttle;
	float throttle_max;
	float mech_jetsfuel;
	float defaultfov;
	float boblength;
	float weapons_tonnage;
	float locktimer;
	float overfactor;
	float rolloffs;
	
	// Intrinsic bools
	bool defaultmovement;
	bool uncappedtorso;
	bool overtonnage;
	
	// Volatile bools
	bool buttonTick;
	bool weapon_groupfire;
	bool snd_reactor;
	bool snd_accelerate;
	bool Mech_HasJets;
	bool doShutdown;
	bool mech_shutdown;
	bool heatwarn;
	bool zoomed_in;
	bool supersink;
	bool canShutdown;
	bool btn_userfive;
	bool bInfrared;
	bool manualshutdown;
	bool targetlocked;
	bool weapons_fired;
	
	// Intrinsic Strings
	String hud_cockpit;
	String hud_mech;

	// Chassis properties
	Property heatEff  : baseHeatEfficiency;
	Property LegSpeed : LegSpeed;
	Property TwistRange : MaxYaw;
	Property MoveSpeed  : MoveSpeedKPH;
	Property PitchRange : pitchRange;
	Property Weight : mech_tonnage;
	Property HudMech : hud_mech;
	Property HudCockpit : hud_cockpit;
	Property EngineWeight : enginesize;
	Property DefaultMovement: defaultmovement;
	Property InfiniteTorsoTwist: uncappedtorso;
	Property OverTonnage: overtonnage;
	

	clearscope void sendHudAlert(String str, int c)
	{
		hAlert.text = str;
		hAlert.col = c;
	}
	
	clearscope int checkItemWorth(String item)
	{
		class<Mechbase_Utility> item_ut = item;
		class<Mechbase_Weapon> item_weap = item;
		if(item_ut)return GetDefaultByType(item_ut).worth;
		if(item_weap)return GetDefaultByType(item_weap).worth;
		
		return 0;
	}

	void giveWeaponAmmo(class<Ammo> type, int amt)
	{
		GiveInventory(type, amt);
	}
	bool checkVoodoo()
	{
		return (!player || !player.mo || player.mo != self);
	}
	
	void adjustMoney(int amt)
	{
		money_cbills += amt;
	}
	
	// Setup weapon location hardpoints and hardpoint slots.
	void setupHardpoints(Vector2 hd, Vector2 ct, Vector2 rt, Vector2 lt, Vector2 la, Vector2 ra, Vector2 ll, Vector2 rl)
	{
		hardpoints.hd.pos = hd;
		hardpoints.ct.pos = ct;
		hardpoints.lt.pos = lt;
		hardpoints.rt.pos = rt;
		hardpoints.la.pos = la;
		hardpoints.ra.pos = ra;
		hardpoints.ll.pos = ll;
		hardpoints.rl.pos = rl;
	}
	
	void setupHardpointVitals(int hda,int cta,int lta,int rta,int laa,int raa,int lla,int rla,int hdi,int cti,int lti,int rti,int lai,int rai,int lli,int rli)
	{
		// This looks really messy but idk what else i can do.
		hardpoints.hd.max_armor = hda;
		hardpoints.ct.max_armor = cta;
		hardpoints.lt.max_armor = lta;
		hardpoints.rt.max_armor = rta;
		hardpoints.la.max_armor = laa;
		hardpoints.ra.max_armor = raa;
		hardpoints.ll.max_armor = lla;
		hardpoints.rl.max_armor = rla;
		hardpoints.hd.armor = hda;
		hardpoints.ct.armor = cta;
		hardpoints.lt.armor = lta;
		hardpoints.rt.armor = rta;
		hardpoints.la.armor = laa;
		hardpoints.ra.armor = raa;
		hardpoints.ll.armor = lla;
		hardpoints.rl.armor = rla;
		hardpoints.hd.max_internal = hdi;
		hardpoints.ct.max_internal = cti;
		hardpoints.lt.max_internal = lti;
		hardpoints.rt.max_internal = rti;
		hardpoints.la.max_internal = lai;
		hardpoints.ra.max_internal = rai;
		hardpoints.ll.max_internal = lli;
		hardpoints.rl.max_internal = rli;
		hardpoints.hd.internalhp = hdi;
		hardpoints.ct.internalhp = cti;
		hardpoints.lt.internalhp = lti;
		hardpoints.rt.internalhp = rti;
		hardpoints.la.internalhp = lai;
		hardpoints.ra.internalhp = rai;
		hardpoints.ll.internalhp = lli;
		hardpoints.rl.internalhp = rli;
	}
	
	void setupHardpointSlots(int hds=10,int cts=12,int rts=12, int lts=12, int las=12,int ras=12, int lls=2,int rls=2)
	{
		hardpoints.hd.maxslots = hds;
		hardpoints.hd.slots = getWeaponSlotsUsed(hardpoints.hd.pos);
		hardpoints.ct.maxslots = cts;
		hardpoints.ct.slots = getWeaponSlotsUsed(hardpoints.ct.pos);
		hardpoints.rt.maxslots = rts;
		hardpoints.rt.slots = getWeaponSlotsUsed(hardpoints.rt.pos);
		hardpoints.lt.maxslots = lts;
		hardpoints.lt.slots = getWeaponSlotsUsed(hardpoints.lt.pos);
		hardpoints.la.maxslots= las;
		hardpoints.la.slots = getWeaponSlotsUsed(hardpoints.la.pos);
		hardpoints.ra.maxslots = ras;
		hardpoints.ra.slots = getWeaponSlotsUsed(hardpoints.ra.pos);
		hardpoints.ll.maxslots = lls;
		hardpoints.ll.slots = getWeaponSlotsUsed(hardpoints.ll.pos);
		hardpoints.rl.maxslots = rls;
		hardpoints.rl.slots = getWeaponSlotsUsed(hardpoints.rl.pos);
		// Setup criticals
		if(MoveSpeedKPH > 64)
		{
			equipStruct("StructEngine",hardpoints.lt.pos);
			equipStruct("StructEngine",hardpoints.rt.pos);	
		}
		if(MoveSpeedKPH > 81) equipStruct("StructEngine",hardpoints.ct.pos);	
		equipStruct("StructGyro",hardpoints.hd.pos);
		equipStruct("StructLifesupport",hardpoints.hd.pos);
		equipStruct("StructSensors",hardpoints.hd.pos);
		equipStruct("StructCockpit",hardpoints.hd.pos);
		equipStruct("StructHip",hardpoints.lt.pos);
		equipStruct("StructHip",hardpoints.rt.pos);
		equipStruct("StructActuator",hardpoints.la.pos);
		equipStruct("StructActuator",hardpoints.ra.pos);
		equipStruct("StructEngine",hardpoints.ct.pos);
		equipStruct("StructEngine",hardpoints.ct.pos);
		equipStruct("StructGyro",hardpoints.ct.pos);
		equipStruct("StructGyro",hardpoints.ct.pos);
	}
	
	void DestroyHardpointItems(MechHardpoint hp, bool recurse=true)
	{
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.mount == hp.pos) 
				{
					removeWeapon(ww);
					normalizeWeaponsID(1);
					mechsounds.pushSound("Mech/Betty/WeaponDestroyed");
					if(recurse) DestroyHardpointItems(hp,recurse);
				}
			}
		}
		DestroyHardpointStructs(hp,recurse);
	}
	
	void DestroyHardpointStructs(MechHardpoint hp, bool recurse=true)
	{
		for(int i = 0; i < mechstructs.Size(); i++)
		{
			Vector2 strucpos = (mechstructs_x[i], mechstructs_y[i]);
			let ut = GetDefaultByType(utilcast(mechstructs[i]));
			
			if(strucpos == hp.pos && ut.moveable)
			{
				class<Heatsink> hs = mechstructs[i];
				if(hs) 
				{
					mechsounds.pushSound("Mech/Betty/Heatsink");
					mechsounds.pushSound("Mech/Betty/Destroyed");
				}
				adjustHardslots(strucpos,-ut.hardslots);
				weapons_tonnage -= ut.weight;
				mechstructs.delete(i);
				mechstructs_x.delete(i);
				mechstructs_y.delete(i);
				if(recurse) DestroyHardpointStructs(hp,recurse);
			}
		}
	}
	
	int getWeaponSlotsUsed(Vector2 loc)
	{
		int slots = 0;
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.mount == loc) slots += ww.hardslots;
			}
		}
		return slots;
	}
	
	int getMaxWeaponGrouping()
	{
		int mxgrp = 1;
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.group > mxgrp)mxgrp = ww.group;
			}
		}
		return mxgrp;
	}
	
	void normalizeWeaponsID(int offs)
	{
		int weapsid = weapons-offs;
		weapons -= offs;
		for(let w = Inv; w; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				ww.WeaponID = weapsid;
				weapsid--;
			}
		}
	}
	
	clearscope String resolveWeaponName(Mechbase_Weapon ww)
	{	
		Array<String> weaponslot;
		weaponslot.Clear();
		String weapcheck = ww.getClassName();
		String weaptype = weapcheck;
		weapcheck.Split(weaponslot,"_");
		if(ww is weaponslot[0]) weaptype = weaponslot[0];
		//console.printf("Weapon is: %s",weaptype);
		return weaptype;
	}
	
	int checkHardslots(Vector2 pos)
	{
		int slots = 0;
		if(pos == hardpoints.hd.pos) slots = (hardpoints.hd.maxslots-hardpoints.hd.slots);
		if(pos == hardpoints.ct.pos) slots = (hardpoints.ct.maxslots-hardpoints.ct.slots);
		if(pos == hardpoints.lt.pos) slots = (hardpoints.lt.maxslots-hardpoints.lt.slots);
		if(pos == hardpoints.rt.pos) slots = (hardpoints.rt.maxslots-hardpoints.rt.slots);
		if(pos == hardpoints.la.pos) slots = (hardpoints.la.maxslots-hardpoints.la.slots);
		if(pos == hardpoints.ra.pos) slots = (hardpoints.ra.maxslots-hardpoints.ra.slots);
		if(pos == hardpoints.ll.pos) slots = (hardpoints.ll.maxslots-hardpoints.ll.slots);
		if(pos == hardpoints.rl.pos) slots = (hardpoints.rl.maxslots-hardpoints.rl.slots);
		return slots;
	}
	
	clearscope int getFreeSlots()
	{
		int slots = 0;
		slots += (hardpoints.hd.maxslots-hardpoints.hd.slots);
		slots += (hardpoints.ct.maxslots-hardpoints.ct.slots);
		slots += (hardpoints.lt.maxslots-hardpoints.lt.slots);
		slots += (hardpoints.rt.maxslots-hardpoints.rt.slots);
		slots += (hardpoints.la.maxslots-hardpoints.la.slots);
		slots += (hardpoints.ra.maxslots-hardpoints.ra.slots);
		slots += (hardpoints.ll.maxslots-hardpoints.ll.slots);
		slots += (hardpoints.rl.maxslots-hardpoints.rl.slots);
		
		return slots;
	}
	
	// I have to use internal structures here such as vector2 instead of my own struct
	// due to pointer issues.
	clearscope vector2 getHardpointSlots(int ind)
	{
		vector2 hslots = ( 0, 0 );
		if(ind == 0) hslots = (hardpoints.hd.maxslots, hardpoints.hd.slots);
		if(ind == 1) hslots = (hardpoints.ct.maxslots, hardpoints.ct.slots);
		if(ind == 2) hslots = (hardpoints.lt.maxslots, hardpoints.lt.slots);
		if(ind == 3) hslots = (hardpoints.rt.maxslots, hardpoints.rt.slots);
		if(ind == 4) hslots = (hardpoints.la.maxslots, hardpoints.la.slots);
		if(ind == 5) hslots = (hardpoints.ra.maxslots, hardpoints.ra.slots);
		if(ind == 6) hslots = (hardpoints.ll.maxslots, hardpoints.ll.slots);
		if(ind == 7) hslots = (hardpoints.rl.maxslots, hardpoints.rl.slots);
		return hslots;
	}
	
	clearscope vector2 getHardpointPos(int ind)
	{
		vector2 hpos = ( 0, 0 );
		if(ind == 0) hpos = hardpoints.hd.pos;
		if(ind == 1) hpos = hardpoints.ct.pos;
		if(ind == 2) hpos = hardpoints.lt.pos;
		if(ind == 3) hpos = hardpoints.rt.pos;
		if(ind == 4) hpos = hardpoints.la.pos;
		if(ind == 5) hpos = hardpoints.ra.pos;
		if(ind == 6) hpos = hardpoints.ll.pos;
		if(ind == 7) hpos = hardpoints.rl.pos;
		return hpos;
	}
	
	clearscope HardpointVitals getHardpointVitals(int ind)
	{
		HardpointVitals hvital = new("HardpointVitals");
		switch(ind)
		{
			case 0:
				hvital.armor = hardpoints.hd.armor;
				hvital.max_armor = hardpoints.hd.max_armor;
				hvital.internalhp = hardpoints.hd.internalhp;
				hvital.max_internal = hardpoints.hd.max_internal;
			break;
			case 1:
				hvital.armor = hardpoints.ct.armor;
				hvital.max_armor = hardpoints.ct.max_armor;
				hvital.internalhp = hardpoints.ct.internalhp;
				hvital.max_internal = hardpoints.ct.max_internal;
			break;
			case 2:
				hvital.armor = hardpoints.lt.armor;
				hvital.max_armor = hardpoints.lt.max_armor;
				hvital.internalhp = hardpoints.lt.internalhp;
				hvital.max_internal = hardpoints.lt.max_internal;
			break;
			case 3:
				hvital.armor = hardpoints.rt.armor;
				hvital.max_armor = hardpoints.rt.max_armor;
				hvital.internalhp = hardpoints.rt.internalhp;
				hvital.max_internal = hardpoints.rt.max_internal;
			break;
			case 4:
				hvital.armor = hardpoints.la.armor;
				hvital.max_armor = hardpoints.la.max_armor;
				hvital.internalhp = hardpoints.la.internalhp;
				hvital.max_internal = hardpoints.la.max_internal;
			break;
			case 5:
				hvital.armor = hardpoints.ra.armor;
				hvital.max_armor = hardpoints.ra.max_armor;
				hvital.internalhp = hardpoints.ra.internalhp;
				hvital.max_internal = hardpoints.ra.max_internal;
			break;
			case 6:
				hvital.armor = hardpoints.ll.armor;
				hvital.max_armor = hardpoints.ll.max_armor;
				hvital.internalhp = hardpoints.ll.internalhp;
				hvital.max_internal = hardpoints.ll.max_internal;
			break;
			case 7:
				hvital.armor = hardpoints.rl.armor;
				hvital.max_armor = hardpoints.rl.max_armor;
				hvital.internalhp = hardpoints.rl.internalhp;
				hvital.max_internal = hardpoints.rl.max_internal;
			break;
		}
		return hvital;
	}

	void ActivateArmorUtility(class<ArmoryUtility> type, int hindex)
	{	
		if(countinv(type) > 0)
		{
			let autil = ArmoryUtility(FindInventory(type));
			if(hindex == 0) autil.EquipUtil(self,hardpoints.hd);
			if(hindex == 1) autil.EquipUtil(self,hardpoints.ct);
			if(hindex == 2) autil.EquipUtil(self,hardpoints.lt);
			if(hindex == 3) autil.EquipUtil(self,hardpoints.rt);
			if(hindex == 4) autil.EquipUtil(self,hardpoints.la);
			if(hindex == 5) autil.EquipUtil(self,hardpoints.ra);
			if(hindex == 6) autil.EquipUtil(self,hardpoints.ll);
			if(hindex == 7) autil.EquipUtil(self,hardpoints.rl);
		}
	}

	clearscope int CalculateHardpointRepairCost(HardpointVitals hv, int stat)
	{
		int repair_cost = 0;
		float armor_ratio = 1.0 - (!hv.armor ? 1 : hv.armor)/hv.max_armor;
		float internalhp_ratio = 1.0 - (!hv.internalhp ? 1 : hv.internalhp)/hv.max_internal;
		if(stat == 0 && 	 armor_ratio > 0 ) repair_cost = (4750*armor_ratio)+(hv.max_armor*50);
		if(stat == 1 && internalhp_ratio > 0 ) repair_cost = (1250*internalhp_ratio)+(hv.max_internal*25);
		return repair_cost;
	}
	
	void RepairHardpointStat(int hindex, int stat)
	{
		let hv = getHardpointVitals(hindex);
		int cost = CalculateHardpointRepairCost(hv,stat);
		if(money_cbills < cost) 
		{
			sendHudAlert("Insufficient funds!",Font.CR_DARKRED);
		}
		else
		{
			money_cbills -= cost;
			if(hindex == 0) _DoHardpointRepair(hardpoints.hd, stat);
			if(hindex == 1) _DoHardpointRepair(hardpoints.ct, stat);
			if(hindex == 2) _DoHardpointRepair(hardpoints.lt, stat);
			if(hindex == 3) _DoHardpointRepair(hardpoints.rt, stat);
			if(hindex == 4) _DoHardpointRepair(hardpoints.la, stat);
			if(hindex == 5) _DoHardpointRepair(hardpoints.ra, stat);
			if(hindex == 6) _DoHardpointRepair(hardpoints.ll, stat);
			if(hindex == 7) _DoHardpointRepair(hardpoints.rl, stat);
		}
	}
	void _DoHardpointRepair(MechHardpoint hp, int stats)
	{
		if(stats == 0) hp.armor = hp.max_armor;
		if(stats == 1) hp.internalhp = hp.max_internal;	
		sendHudAlert("Hardpoint repaired!",Font.CR_GREEN);
	}

	clearscope vector2 FindHardpointVitals(vector2 pos)
	{
		vector2 ffs = ( 0, 0 );
		if(pos == hardpoints.hd.pos) ffs = (hardpoints.hd.armor, hardpoints.hd.internalhp);
		if(pos == hardpoints.ct.pos) ffs = (hardpoints.ct.armor, hardpoints.ct.internalhp);
		if(pos == hardpoints.lt.pos) ffs = (hardpoints.lt.armor, hardpoints.lt.internalhp);
		if(pos == hardpoints.rt.pos) ffs = (hardpoints.rt.armor, hardpoints.rt.internalhp);
		if(pos == hardpoints.la.pos) ffs = (hardpoints.la.armor, hardpoints.la.internalhp);
		if(pos == hardpoints.ra.pos) ffs = (hardpoints.ra.armor, hardpoints.ra.internalhp);
		if(pos == hardpoints.ll.pos) ffs = (hardpoints.ll.armor, hardpoints.ll.internalhp);
		if(pos == hardpoints.rl.pos) ffs = (hardpoints.rl.armor, hardpoints.rl.internalhp);
		return ffs;
	}
	
	void adjustHardslots(Vector2 pos, int amt)
	{
		if(pos == hardpoints.hd.pos) hardpoints.hd.slots += amt;
		if(pos == hardpoints.ct.pos) hardpoints.ct.slots += amt;
		if(pos == hardpoints.lt.pos) hardpoints.lt.slots += amt;
		if(pos == hardpoints.rt.pos) hardpoints.rt.slots += amt;
		if(pos == hardpoints.la.pos) hardpoints.la.slots += amt;
		if(pos == hardpoints.ra.pos) hardpoints.ra.slots += amt;
		if(pos == hardpoints.ll.pos) hardpoints.ll.slots += amt;
		if(pos == hardpoints.rl.pos) hardpoints.rl.slots += amt;
	}
	
	void removeWeapon(Mechbase_Weapon w)
	{
		// This is need because hardpoints and stuff.
		weapons_tonnage -= w.weight;
		// TakeInventory(resolveWeaponName(w),1);
		adjustHardslots(w.mount,-w.hardslots);
		RemoveInventory(w);
	}
	
	bool removeWeaponAt(int ind)
	{
		for(let w = Inv; w; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.WeaponID == ind)
				{
					removeWeapon(ww);
					normalizeWeaponsID(1);
					return true;
				}
			}
		}
		return false;
	}
	
	bool swapWeaponToInv(int weap_ind, int inv_ind)
	{
		String weaptype;
		inv_ind --;
		
		// Make sure our inventory type is a weapon!
		class<Mechbase_Weapon> invweap = weapon_items[inv_ind];
		if(!invweap) return false;
		
		for(let w = Inv; w; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(weap_ind == ww.WeaponID)
				{
					weaptype = resolveWeaponName(ww);
					int prevweaps = weapons;
					weapons = ww.WeaponID-1;
					equipWeapon(weapon_items[inv_ind],ww.mount,ww.group,false);
					weapons = prevweaps;
					removeWeapon(ww);
					weapon_items[inv_ind] = weaptype;
					return true;
				}
			}
		}
		return false;
	}
	
	bool moveWeaponToInv(int weap_ind)
	{
		for(let w = Inv; w; w = w.Inv)
		{
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.WeaponID == weap_ind)
				{
					addWeaponToInv(resolveWeaponName(ww),1,false);
					removeWeapon(ww);
					normalizeWeaponsID(1);
					return true;
				}
			}
		}
		return false;
	}
	
	clearscope class<Mechbase_Utility> utilcast(String type)
	{
		class<Mechbase_Utility> mechutil = type;
		return mechutil;
	}
	
	bool moveStructToInv(int struc_ind, bool move=true)
	{
		for(int i = 0; i < mechstructs.Size(); i++)
		{
			if(i == struc_ind)
			{
				let ut = GetDefaultByType(utilcast(mechstructs[i]));
				if(!ut.moveable) return false;
				Vector2 strucpos = (mechstructs_x[i], mechstructs_y[i]);
				adjustHardslots(strucpos,-ut.hardslots);
				weapons_tonnage -= ut.weight;
				addStructToInv(mechstructs[i]);
				if(move)mechstructs.delete(i);
				if(move)mechstructs_x.delete(i);
				if(move)mechstructs_y.delete(i);
				return true;
			}
		}
		return false;
	}
	
	void addWeaponToInv(String weapon,int amt=1,bool giveammo = true)
	{
		if(weapon_items.Size() == 0) weapon_items.Clear();
		class<Mechbase_Weapon> weap = weapon;
		class<Mechbase_Utility> util = weapon;
		if(weap)
		{
			let weapdef = GetDefaultByType(weap);
			if(weapdef.ammotype && giveammo) A_GiveInventory(weapdef.ammotype,weapdef.ammogive);
		}
		if(util)
		{
			let utildef = GetDefaultByType(util);
			if(utildef.ammotype && giveammo) A_GiveInventory(utildef.ammotype,utildef.ammogive);
		}
		
		for(int i = 0; i < amt; i++)weapon_items.push(weapon);
	}
	
	void addStructToInv(String mstruc)
	{
		class<Mechbase_Utility> util = mstruc;
		if(!util) return;
		weapon_items.push(mstruc);
	}
	
	// Equip weapon from items
	bool equipWeaponInv(int ind, Vector2 pos, int grp, bool move=true)
	{
		class<Mechbase_Weapon> weap = weapon_items[ind-1];
		if(!weap) return false;
		
		if( weapons_tonnage+GetDefaultByType(weap).weight > mech_tonnage && !overtonnage)
		{
			sendHudAlert("Cannot equip weapon, over tonnage!", Font.CR_DARKRED);
			return false;
		}
		if( checkHardslots(pos) < GetDefaultByType(weap).hardslots )
		{
			sendHudAlert("Cannot equip weapon, no freeslots!", Font.CR_DARKRED);
			return false;	
		}
		 
		 // Equip weapon in inventory, don't give ammo.
		if(!equipWeapon(weapon_items[ind-1],pos,grp,false)) return false;
		if(move)weapon_items.delete(ind-1);
		return true;
	}
	
	// Equip struct from items
	bool equipStructInv(int ind, Vector2 pos, bool move=true)
	{
		class<Mechbase_Utility> util = weapon_items[ind-1];
		if(!util) return false;
		
		if( weapons_tonnage+GetDefaultByType(util).weight > mech_tonnage && !overtonnage)
		{
			sendHudAlert("Cannot equip item, over tonnage!", Font.CR_DARKRED);
			return false;
		}
		if( checkHardslots(pos) < GetDefaultByType(util).hardslots )
		{
			sendHudAlert("Cannot equip item, no freeslots!", Font.CR_DARKRED);
			return false;	
		}
		 
		 // Equip without giving starting ammunition
		if(!equipStruct(weapon_items[ind-1],pos,1,false)) return false;
		if(move)weapon_items.delete(ind-1);
		return true;
	}
	
	
	Mechbase_Weapon getSelectedWeapon()
	{	
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.WeaponID == selectedWeapon) return ww;
			}
		}
		return null;
	}
	
	
	int getWeaponGroupAt(int ind)
	{
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.WeaponID == ind) return ww.group;
			}
		}
		return 1;
	}
	
	bool, int getNextWeaponIn(int ind, int grp)
	{
		int mxgrp = 0;
		bool found = false;
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.WeaponID > ind && ww.group == grp)
				{
					// /console.printf("Found: I: %d, G: %d",ww.WeaponID,ww.group);
					mxgrp = ww.WeaponID;
					found = true;
				}
			}
		}
		return found, mxgrp;
	}
	
	bool setWeaponGroupAt(int ind, int group)
	{
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.WeaponID == ind) 
				{
					ww.group = group;
					return true;
				}
			}
		}
		return false;
	}
	
	int getNearestWeaponAt(int group, bool markactive=false)
	{
		int prevind = weapons;
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if( (ww.WeaponID < prevind) && ww.group == group )
				{
					prevind = ww.WeaponID;
				}
			}
		}
		return prevind;
	}
	
	void clearWeapons()
	{
		ClearInventory();
		hardpoints.hd.slots = 0;
		hardpoints.ct.slots = 0;
		hardpoints.lt.slots = 0;
		hardpoints.rt.slots = 0;
		hardpoints.la.slots = 0;
		hardpoints.ra.slots = 0;
		hardpoints.ll.slots = 0;
		hardpoints.rl.slots = 0;
		weapons_tonnage = 0;
		GiveInventory("CrosshairHandler",1);
		weapons = 0;	
	}
	
	bool equipStruct(class<Mechbase_Utility> type, Vector2 pos, int amt = 1,bool giveammo=true)
	{
		if( (checkHardslots(pos)-(GetDefaultByType(type).hardslots*amt)) < 0)
		{
			if(!GetDefaultByType(type).moveable) console.printf("WARNING: Failed to equip critical item: %s",type.getClassName());
			return false;
		}
		//console.printf("Adding struct: %s", GetDefaultByType(type).displayName);
		let str_def = GetDefaultByType(type);
		if(str_def.ammogive > 0 && str_def.ammotype != "" && giveammo) 
		{
			A_GiveInventory(str_def.ammotype,str_def.ammogive);
		}
		for(int i = 0; i < amt; i++)
		{
			mechstructs.push(type.getClassName());
			mechstructs_x.push(pos.x);
			mechstructs_y.push(pos.y);
			weapons_tonnage += GetDefaultByType(type).weight;
			adjustHardslots(pos,GetDefaultByType(type).hardslots);
		}
		return true;
	}
	
	int countStruct(String type)
	{
		int count = 0;
		type.ToLower();
		if(!mechstructs.Size()) mechstructs.Clear();
		for(int i = 0; i < mechstructs.Size(); i++)
		{
			String cname = mechstructs[i];
			cname.ToLower();
			type.ToLower();
			if(cname == type) count++;
		}
		//console.printf("Count for %s: %d",type,count);
		return count;
	}
	
	bool equipWeapon(class<Mechbase_Weapon> type, Vector2 vpos, int group, bool giveammo = true)
	{
		if(checkVoodoo()) return false;
		GiveInventory(type,1);
		if(countinv(type) > 1)
		{
			int slotcheck = 1;
			Name ntype;
			// You can only have 12 of each weapon, max.
			for(int i = 1; i < 12; i++)
			{
				if(countinv( Name(type) .. "_" .. i )) continue;
				ntype = Name(type) .. "_" .. i;
				slotcheck = i;
			}
			if(!ntype)
			{
				sendHudAlert("Weapon Systems Error. Buffer overloaded!", Font.CR_DARKRED);
				//console.printf("No free slot found for: %s",(Name(type) .. ""));
				return false;
			}
			GiveInventory(ntype,1);
			//console.printf("Obtaining another %s; slot #%d",(Name(ntype) .. ""),slotcheck);
		}
		weapons++;
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{
				if(ww.WeaponID == 0)
				{
					//console.printf("Setting new ID: %d",weapons); 
					ww.WeaponID = weapons;
					ww.group = group;
					ww.mount = vpos;
					adjustHardslots(ww.mount,ww.hardslots);
					weapons_tonnage += ww.weight;
					if(ww.ammotype && giveammo)GiveInventory(ww.ammotype,ww.ammogive);
					//console.printf("Adding Weapon: %s at %d",ww.displayName,ww.WeaponID);
				}
			}
		}
		maxgroup = getMaxWeaponGrouping();
		return true;
	}
	
	void nextWeapon(bool gcycle=false)
	{
		//console.printf("[4] %d",getNearestWeaponAt(getWeaponGroupAt(selectedWeapon)));
		if(weapon_groupfire || gcycle)
		{
			bool valid;
			int ind;
			[valid, ind] = getNextWeaponIn(selectedWeapon, getWeaponGroupAt(selectedWeapon));
			if(!valid)
			{
				selectedWeapon = getNearestWeaponAt(getWeaponGroupAt(selectedWeapon));
			}
			else
			{
				selectedWeapon = ind;
			}
		}
		else
		{
			selectedWeapon++;
		}
	}
	
	void FireGroup(int group, bool alpha=false)
	{
		if(checkVoodoo()) return;
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{	
				if( (ww.group == group) || alpha) ww.MWFire();
			}
		}
	}
	
	void FireWeapons(bool groupfire=true)
	{
		if(checkVoodoo()) return;
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{	if(groupfire)
				{
					//int bit = 2 ** (ww.group-1);
					if(ww.group == getWeaponGroupAt(selectedWeapon))
					{
						if(!ww.MWFire() && buttonTick && !weapon_groupfire) A_PlaySound("Mech/WeaponBusy",3);
					}
				}
				else if(ww.WeaponID == selectedWeapon)
				{
					if(!ww.MWFire() && buttonTick && !weapon_groupfire && weapons_fired == 0) A_PlaySound("Mech/WeaponBusy",3);
				}
			}
		}
	}
	
	void process_antimissilesystem()
	{
		for(int i = 0; i < mechstructs.Size(); i++)
		{
			String cname = mechstructs[i];
			cname.ToLower();
			if(cname == "antimissilesystem")
			{
				trigger_ams( (mechstructs_x[i],mechstructs_y[i]) );
			}
		}
		if(ams_timer > 0) ams_timer--;
	}
	
	void trigger_ams(vector2 amshardpoint)
	{
		class<Mechbase_Utility> amsut = "AntiMissileSystem";
		class<AntiMissileSystem> amsdef = "AntiMissileSystem";
		let def_utams = GetDefaultByType(amsut);
		let def_ams = GetDefaultByType(amsdef);
		
		if(ams_timer <= 0)
		{	
		    // Check ammunition.
			if(def_utams.ammotype) 
			{
				if(countinv(def_utams.ammotype) < def_ams.ammouse) return;
			}
			// Check if a projectile is near us.
			ThinkerIterator ams_it = ThinkerIterator.Create("Actor");
			Actor obj;
			while(obj = Actor(ams_it.Next()))
			{
				if(obj is "AMS_Missile" || obj is "Mechbase_Actor") continue;
				if(obj)
				{	
					if( CheckSight(obj) && (obj.bMISSILE) && Distance3D(obj) < def_ams.activerange )
					{
						//console.printf("Firing AMS at: " .. obj.getTag());
						SoundEmitter.SE_Trigger("Missiles/AMS");
						amshardpoint.x += random(-5,5);
						amshardpoint.y += random(-5,5);
						float xo = (cos(AngleTo(obj)+amshardpoint.x))*25;
						float yo = (sin(AngleTo(obj)+amshardpoint.x))*25;
						Vector3 lpos = (pos.x+xo,pos.y+yo,pos.z+(viewheight*player.crouchFactor)+amshardpoint.y);		
						obj.bSHOOTABLE = true;
						let ams = AMS_Missile(Spawn(def_ams.amstype,lpos));
						if(ams)
						{
							// AMS Sound FX
							ams.tracer = obj;
							ams.master = self;
							ams_timer = def_ams.cooldown;
							ams.pitch = obj.pitch;
							ams.angle = ams.AngleTo(obj);
							// Will automatically set convengence factor in postplay.
							ams.vel = (
									cos(ams.AngleTo(obj))*cos(obj.pitch),
									sin(ams.AngleTo(obj))*cos(obj.pitch),
									-sin(obj.pitch)*5
									) * obj.speed;
							if(def_utams.ammotype) TakeInventory(def_utams.ammotype,def_ams.ammouse);
						}
					}
				}
			}
		}
	}
	
	Default
	{	
	
		Player.StartItem "CrosshairHandler";	
		Player.SoundClass "MechWarrior";
		MechWarrior.heatEff 0.05;
		Player.ViewBob 0;
		//Player.StartItem "Heatsink",5;
		MechWarrior.HudCockpit "CROW";
		MechWarrior.HudMech "";
		MechWarrior.LegSpeed 2;
		//MechWarrior.LegRange 360;
		Mechwarrior.MoveSpeed 4;
		//MechWarrior.TwistSpeed 1;
		MechWarrior.TwistRange 90;
		MechWarrior.PitchRange 30;
		Player.JumpZ 0;
	
	}

	void mech_movement()
	{
		if(!player) return;
		// Dead boi walkin
		if(health <= 0) return;
		// Leg Movement
		if(!defaultmovement)
		{
			if(player.cmd.yaw+player.cmd.pitch != 0 && (abs((angle-LegAng)) < MaxYaw || uncappedtorso) )
				{ A_PlaySound("Mech/TorsoTwist",4,0.3,1); } else { A_StopSound(4); }
				
			if(throttle == 0) snd_accelerate = true;
			if(GetPlayerInput(INPUT_BUTTONS) & BT_FORWARD)
			{
				throttle += 0.02;
				// If stop is pressed and we continue moving, we don't want the two "forces" to fight.
				TakeInventory("IBTN_STOP",1);
				if(snd_accelerate){A_PlaySound("Mech/AccelFromStop",1); snd_accelerate = false;}
			}
			else if(CVar.FindCVar("mwd_throttledecay").getInt() == 1 && throttle > 0.02)
			{
				throttle -= 0.02;
				if(!snd_accelerate){A_PlaySound("Mech/DeccelToStop",1); snd_accelerate = true;}
			}
			
			if(GetPlayerInput(INPUT_BUTTONS) & BT_BACK) 
			{
				throttle -= 0.02;
				TakeInventory("IBTN_STOP",1);
				if(!snd_accelerate){A_PlaySound("Mech/DeccelToStop",1); snd_accelerate = true;}
			}
			else if(CVar.FindCVar("mwd_throttledecay").getInt() == 1 && throttle < 0)
			{
				throttle += 0.02;
				if(snd_accelerate){A_PlaySound("Mech/AccelFromStop",1); snd_accelerate = false;}
			}
			
			throttle = clamp(throttle,-(throttle_max/2),throttle_max);
			
			if(throttle > 0.5 && !snd_reactor)
			{
				A_PlaySound("Mech/ReactorHum",5,1.0,1);
				snd_reactor = true;
			}
			else if(throttle < 0.5 && snd_reactor)
			{
				A_StopSound(5);
				snd_reactor = false;
			}
			
			if(GetPlayerInput(INPUT_BUTTONS) & BT_MOVERIGHT)
			{
				TakeInventory("IBTN_CENTER",1);
				LegVel = -LegSpeed;
				LookVel = -LegSpeed;
			}
			if(GetPlayerInput(INPUT_BUTTONS) & BT_MOVELEFT )
			{
				TakeInventory("IBTN_CENTER",1);
				LegVel = LegSpeed;
				LookVel = LegSpeed;
			}		
			if(!(GetPlayerInput(INPUT_BUTTONS) & BT_MOVERIGHT) && 
			   !(GetPlayerInput(INPUT_BUTTONS) & BT_MOVELEFT))
			  {
				 LookVel = 0;
				 LegVel = 0;
			  }
			   
			if(countinv("IBTN_STOP"))
			{
				if(abs(throttle) <= 0.1)TakeInventory("IBTN_STOP",1);
				if(throttle < 0)throttle += 0.02;
				if(throttle > 0)throttle -= 0.02;
				snd_accelerate = true;
				if(abs(throttle) <= 0.1)throttle = 0;
			}
			if(countinv("IBTN_CENTER") && !uncappedtorso)
			{
				int yaw = int(angle-LegAng);
				if(yaw > 0) LegVel =  2;
				if(yaw < 0) LegVel = -2;
				if(yaw == 0)TakeInventory("IBTN_CENTER",1);
			}
			if(countinv("IBTN_CENTERTORSO") && !uncappedtorso)
			{
				int yaw = int(angle-LegAng);
				if(yaw > 0)angle-=2;
				if(yaw < 0)angle+=2;
				if(pitch > 0)pitch-=2;
				if(pitch < 0)pitch+=2;
				if(yaw == 0)TakeInventory("IBTN_CENTERTORSO",1);
			}
			
			A_SetRoll( roll + 
				   (( (cos( (angle-LegAng)-90  ) * pitch) )
					- (cos(angle)*(sin( pitch )*10)))
			);
			// Move mech by a percentage of throttle.
			vel = (cos(LegAng)*(throttle*MoveSpeed),sin(LegAng)*(throttle*MoveSpeed),vel.z);
			LegAng += LegVel;
			angle += LookVel;
			//A_SetRoll( (cos(angle)*(sin( pitch )*30))-TiltOffset);
			Pitch = clamp(Pitch, -pitchRange, pitchRange);
			if(MaxYaw < 360 && !uncappedtorso)
			{
				if(angle - LegAng > MaxYaw)  angle = LegAng + MaxYaw;
				if(angle - LegAng < -MaxYaw) angle = LegAng - MaxYaw;
			}
		}
		
		
 		if( (GetPlayerInput(INPUT_BUTTONS) & BT_JUMP) && Mech_HasJets && mech_jetsfuel > 0)
		{
			class<JumpJet> jj = "JumpJet";
			float truetonnage = overtonnage ? weapons_tonnage : mech_tonnage;
			double tonmod = 100-( truetonnage-(5*Mech_JetCount) );
			double zthrust = ( Mech_JetCount * GetDefaultByType(jj).thrust_power ) * ( tonmod/100 ) + ((mech_jetsfuel/100)*2);
			vel.z = zthrust * defaultmovement ? 5 : 1;
			mech_jetsfuel -= 1;
			A_PlaySound("Mech/JetLoop",5,1,1);
		} 
		else if(!btn_userfive && mech_jetsfuel > 0)
		{
			A_StopSound(5);
		}
		
		if(btn_userfive && Mech_HasJets && mech_jetsfuel > 0)
		{
			class<JumpJet> jj = "JumpJet";
			double tonmod = 100-( mech_tonnage-(5*Mech_JetCount) );
			vel.z = ( Mech_JetCount * GetDefaultByType(jj).thrust_power ) * ( tonmod/100 ) + ((mech_jetsfuel/100)*2);
			mech_jetsfuel -= 1;
			A_PlaySound("Mech/JetLoop",5,1,1);
		} 
		else if ( !((GetPlayerInput(INPUT_BUTTONS) & BT_JUMP) && mech_jetsfuel > 0))
		{
			A_StopSound(5);
		}
		
		if( (GetPlayerInput(0) & BT_ZOOM) )
		{
			if(player.DesiredFOV > 30)
			{
				player.DesiredFOV -= 3;
				A_PlaySound("Mech/Zoom",7,1,1);
			}
			else
			{
				A_StopSound(7);
			}
		}
		else
		{
			if(player.DesiredFOV < defaultfov)
			{
				player.DesiredFOV += 3;
				A_PlaySound("Mech/Zoom",7,1,1);
			}
			else
			{
				A_StopSound(7);
			}
		}

		// Cool utilities for easier pilotability!
		if(countinv("IBTN_OVERRIDE"))
		{
			if(!doShutdown)
			{
				TakeInventory("IBTN_OVERRIDE",1);
			}
			else
			{
				A_Print("Shutdown overridden.");
				doShutdown = false;
				shutdown_timer = ticks;
				A_PlaySound("Mech/Override",1);
				mechsounds.pushSound("Mech/Betty/ShutdownOverride");
				TakeInventory("IBTN_OVERRIDE",1);
			}
		}
	
		if(countinv("IBTN_INFRARED"))
		{	
			if(bInfrared)
			{
				TakeInventory("InfraredAmp",1);
			}
			else
			{
				A_PlaySound("Mech/Infrared",CHAN_WEAPON);
				GiveInventory("InfraredGiver",1);
			}
			TakeInventory("IBTN_INFRARED",1);
			bInfrared = !bInfrared;
		}
	
		// Stompy boi
		if(vel.length() > 0.08)
		{
			boblength += (vel.length()/4) * boblendir;
		}
		if(abs(boblength) > 42)
		{
			boblendir *= -1;
		}
		//console.printf("Angle: %d", ceil(acos(cos(angle))));
		//console.printf("Speed: %dkph", MoveSpeedKPH*throttle);
		//console.printf("Throttle: %d%%", abs(throttle)*100);
		//if(weapon_groupfire)console.printf("Group: %d",selectedGroup);
		//if(!weapon_groupfire)console.printf("Weapon: %d",selectedWeapon);
		if(countStruct("JumpJet") > 0 && mech_jetsfuel < 100 && 
		 !(GetPlayerInput(INPUT_BUTTONS) & BT_JUMP) &&
		 !btn_userfive && player.OnGround) mech_jetsfuel += 0.5;
	}
	
	void powerup()
	{
		mech_shutdown = false;
		doShutdown = false;
	}
	
	void process_shutdown()
	{
		if(!defaultmovement)
		{	
			angle = lockangle;
			pitch = lockpitch;
		}
		if(!manualshutdown)
		{	
			if(throttle > 0)throttle -= 0.1;
			if(throttle < 0)throttle += 0.1;
			if( ((ticks - shutdown_timer) > 125) && HeatLevel <= 0 && doShutdown)
			{
				// If we are very efficiently cooled, powerup early
				prevticks = ticks;
				mechsounds.pushSound("Mech/Betty/SystemsCheck");
				A_PlaySound("Mech/Power",2);
				mechsounds.pushSound("Mech/StartupDone");
				doShutdown = false;
			}
			if(!doShutdown && (ticks-prevticks) > 250)powerup();
			if(HeatLevel > 0)HeatLevel -= HeatEfficiency*1.5;
		}
		else
		{
			if(countinv("IBTN_SHUTDOWN"))
			{
				mechsounds.pushSound("Mech/Betty/SystemsCheck");
				A_PlaySound("Mech/Power",2);
				mechsounds.pushSound("Mech/StartupDone");
				manualshutdown = false;
				TakeInventory("IBTN_SHUTDOWN",1);
				prevticks = ticks;
			}
		}
		ticks++;
	}
	
	
	void sortWeaponInv()
	{
		Array<string> newinv;
		Array<String> sortedtypes;
		sortedtypes.Clear();
		newinv.Clear();
		String type;
		sortedtypes.push("JumpJet");
		sortedtypes.push("AntiMissileSystem");
		sortedtypes.push("Heatsink");
		sortedtypes.push("DoubleHeatsink");
		sortedtypes.push("MediumLaser");
		sortedtypes.push("SmallLaser");
		sortedtypes.push("LargeLaser");
		sortedtypes.push("ERLargeLaser");
		sortedtypes.push("ERMediumLaser");
		sortedtypes.push("ERSmallLaser");
		sortedtypes.push("SmallPulseLaser");
		sortedtypes.push("MediumPulseLaser");
		sortedtypes.push("LargePulseLaser");
		sortedtypes.push("PPC");
		sortedtypes.push("ERPPC");
		sortedtypes.push("Flamer");
		sortedtypes.push("MachineGun");
		sortedtypes.push("Autocannon2");
		sortedtypes.push("Autocannon5");
		sortedtypes.push("Autocannon10");
		sortedtypes.push("Autocannon20");
		sortedtypes.push("UAutocannon2");
		sortedtypes.push("UAutocannon5");
		sortedtypes.push("UAutocannon10");
		sortedtypes.push("UAutocannon20");
		sortedtypes.push("GaussRifle");
		sortedtypes.push("SRM2");
		sortedtypes.push("SRM4");
		sortedtypes.push("SRM6");
		sortedtypes.push("SSRM2");
		sortedtypes.push("SSRM4");
		sortedtypes.push("SSRM6");
		sortedtypes.push("LRM5");
		sortedtypes.push("LRM10");
		sortedtypes.push("LRM15");
		sortedtypes.push("LRM20");
		// Sort all items of unique types.
		for(int i = 0; i < sortedtypes.Size(); i++)
		{
			type = sortedtypes[i];
			type.toLower();
			for(int x = 0; x < weapon_items.Size(); x++)
			{
				String thing = weapon_items[x];
				thing.ToLower();
				if(thing == type)
				{
					newinv.push(weapon_items[x]);
				}
			}
		}
		// Re-allocate
		weapon_items.Clear();
		for(int i = 0; i < newinv.Size(); i++) weapon_items.push(newinv[i]);
	}
	
	void mech_weapons()
	{
		if((ticks - prevticks ) > 5)
		{
			buttonTick = true;
			prevticks = ticks;
		}

		// Process Heat levels and struct functionality.
		deltaHeat = HeatLevel-prevheat;
		class<Heatsink> hs = "Heatsink";
		class<Heatsink> dhs = "DoubleHeatsink";
		process_antimissilesystem();
		
		HeatEfficiency = baseHeatEfficiency+( countStruct("Heatsink")*GetDefaultByType(hs).cooling );
		HeatEfficiency += baseHeatEfficiency+( countStruct("DoubleHeatsink")*GetDefaultByType(dhs).cooling );
		Mech_HasJets = (countStruct("JumpJet") > 0);
		Mech_JetCount = countStruct("JumpJet");
		if(supersink) HeatEfficiency *= 2;
		if(HeatLevel > 0) HeatLevel -= HeatEfficiency;
		if(HeatLevel < 0) HeatLevel = 0;
		if(HeatLevel > 120) DamageMobj(self,null,random(6,12),"overheating",DMG_NO_ARMOR | DMG_NO_FACTOR);
		if(HeatLevel <= 30) heatwarn = false;
		if(HeatLevel > 55 && !heatwarn)
		{
			A_PlaySound("Mech/HeatWarn",1,1);
			mechsounds.pushSound("Mech/Betty/HeatCritical");
			heatwarn = true;
		}
		if(HeatLevel >= 85 && !doShutdown && canShutdown) 
		{
			A_Print("Shutdown sequence initiated!");
			mechsounds.pushSound("Mech/Betty/ShutdownInit");
			doShutdown = true;
			canShutdown = false;
			shutdown_timer = ticks;
		}
		if(HeatLevel <= 65) canShutdown = true;
		if( ((ticks - shutdown_timer) > 105) && doShutdown )
		{
			A_StopSound(1);
			A_Print("Shutting down...");
			A_PlaySound("Mech/Betty/ShuttingDown",1);
			doShutdown = true;
			lockangle = angle;
			lockpitch = pitch;
			mech_shutdown = true;
			shutdown_timer = ticks;
			A_PlaySound("Mech/Shutdown",2);
		}
		if(HeatLevel > 200) HeatLevel = 200;
		
		/*
		if(targetenemy)
		{
			console.printf("Targeted - Name: %s / Health: %d",targetenemy.getTag(),targetenemy.health);
		}
		*/
		
		
		//torsoYaw = angle_relative;
		if(selectedWeapon > weapons)selectedWeapon = 1;
		if(selectedGroup > 4)selectedGroup = 1;
		if(GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK)
		{
			//console.printf("Firing: %d",selectedGroup);
			FireWeapons(weapon_groupfire);
			weapons_fired = true;
			if(buttonTick)buttonTick = false;
		}
		else if(weapons_fired) 
		{	
			nextWeapon(true);
			weapons_fired = false;
		}
		
		if(countinv("IBTN_SETWEAPGRP"))
		{	
			if(countinv("IBTN_SETWEAPGRP") > 4)
			{
				console.printf("ERROR: Invalid weapon group :> %d",countinv("IBTN_SETWEAPGRP"));
				TakeInventory("IBTN_SETWEAPGRP",999);
			}
			else
			{
				setWeaponGroupAt(selectedWeapon,countinv("IBTN_SETWEAPGRP"));
				maxgroup = getMaxWeaponGrouping();
			}
			TakeInventory("IBTN_SETWEAPGRP",999);
		}
		
		if(countinv("IBTN_SHOOTALLWEAPONSLIKEAMADLAD"))
		{
			FireGroup(0,true); // pew pew pew, whoosh, whoosh, whoosh, pow, pow, po.. *explodes*
			TakeInventory("IBTN_SHOOTALLWEAPONSLIKEAMADLAD",1);
		}
		
		if(countinv("IBTN_NXTGROUP"))
		{
			int grp = getWeaponGroupAt(selectedWeapon)+1;
			if(grp > maxgroup)grp = 1;
			selectedWeapon = getNearestWeaponAt(grp);
			TakeInventory("IBTN_NXTGROUP",1);
		}
		
		if(countinv("IBTN_PRVGROUP"))
		{
			int grp = getWeaponGroupAt(selectedWeapon)-1;
			if(grp < 1)grp = maxgroup;
			selectedWeapon = getNearestWeaponAt(grp);
			TakeInventory("IBTN_PRVGROUP",1);
		}
		
		if(countinv("IBTN_SHUTDOWN"))
		{
			A_Print("Shutting down...");
			mechsounds.pushSound("Mech/Betty/ShuttingDown");
			A_PlaySound("Mech/Shutdown",1);
			mech_shutdown = true;
			manualshutdown = true;
			lockpitch = pitch;
			lockangle = angle;
			TakeInventory("IBTN_SHUTDOWN",1);
		}
		
		// Don't hold onto dead target.
		if(targetenemy && targetenemy.health <= 0) targetenemy = null;
		
		if(!targetenemy && targetreticle)
		{
			// Don't hold onto dead/invalid target.
			targetreticle.RDeconstruct();
			targetreticle = null;
		}
		
		if(countinv("IBTN_TARGET"))
		{
			TakeInventory("IBTN_TARGET",999);
			
			// Get reference to shootable actor under players aim.
			// AimLineAttack or AimTarget fail to respect viewheight, hence the LineTrace.
			FLineTraceData lt;
			LineTrace(angle, 9999, pitch, 0, viewheight, 0.0,0.0, lt);
			if(lt.HitActor)
			{
				SoundEmitter.SE_Trigger("Mech/Target/Get",pos);
				if(targetreticle)targetreticle.RDeconstruct();
				targetenemy = lt.HitActor;
				targetreticle = MechTargetReticle.InitCreate(self, targetenemy, 16);
			}
		}
		
		if(countinv("IBTN_bFIREMODE"))
		{
			weapon_groupfire = !weapon_groupfire;
			if(weapon_groupfire){
				mechsounds.pushSound("Mech/Betty/Groupfire");
				mechsounds.pushSound("Mech/Betty/Engaged");
				TakeInventory("IBTN_bFIREMODE",1);
			} else {
				mechsounds.pushSound("Mech/Betty/Chainfire");
				mechsounds.pushSound("Mech/Betty/Engaged");
				TakeInventory("IBTN_bFIREMODE",1);
			}
			TakeInventory("IBTN_bFIREMODE",1);
		}
		
		if( GetPlayerInput(INPUT_BUTTONS) & BT_USER1 ) FireGroup(1);
		if( GetPlayerInput(INPUT_BUTTONS) & BT_USER2 ) FireGroup(2);
		if( GetPlayerInput(INPUT_BUTTONS) & BT_USER3 ) FireGroup(3);
		if( GetPlayerInput(INPUT_BUTTONS) & BT_USER4 ) FireGroup(4);
		
		if(countinv("IBTN_NEXTWEAPON"))
		{
			A_PlaySound("Mech/NextWeapon",6);
			selectedWeapon++;
			TakeInventory("IBTN_NEXTWEAPON",1);
			//buttonTick = false;
		}		
		if(countinv("IBTN_PREVWEAPON"))
		{
			A_PlaySound("Mech/NextWeapon",6);
			selectedWeapon--;
			if(selectedWeapon < 1) selectedWeapon = weapons;
			TakeInventory("IBTN_PREVWEAPON",1);
			//buttonTick = false;
		}
		
		prevheat = HeatLevel;
		ticks++;
	}
	
	virtual void SetupWeapons() 
	{
		setupHardpoints( (0,20), (0,0), (-30,-15), (30,-15), (-120,0), (120,0), (-60,-30), (60,-30) );
		setupHardpointSlots();
	}
	
	void startMechbay()
	{
		let bay = Spawn("mechbay",pos);
		float xo = (cos(angle+12))*32;
		float yo = (sin(angle+12))*32;
		let door = Spawn("Door_3D",(pos.x+xo,pos.y+yo,pos.z+60));
		if(bay)bay.angle = angle;
		if(door)door.angle = angle+128;
		mech_shutdown = true;
		mechsounds.pushSound("Mech/Betty/SystemsCheck");
		A_PlaySound("Mech/Power",4);
		mechsounds.pushSound("Mech/StartupDone");
		manualshutdown = false;
		prevticks = ticks;
		lockangle = angle;
		lockpitch = pitch;
	}
	
	// Native functions.
	void DamageHardpoint(MechHardpoint hp, float dmg, bool noarmor=false, bool crit=false)
	{
		if(hp.armor > 0 && !noarmor) 
		{
			if(hp.armor-dmg <= 0) A_PlaySound("Mech/Damaged/NoArmor",1);
			// Random chance armor doesn't absorb the remaining damage.
			if(dmg > hp.armor && random(1,3)==3) 
			{
				hp.armor = 0;
				DamageHardpoint(hp,dmg-hp.armor,random(0,1));
			}
			else
			{
				hp.armor -= dmg;
				if(hp.armor < 0) hp.armor = 0;
			}
		}
		else if(hp.internalhp > 0)
		{
			if(random(0,20-dmg)==(20-dmg) || crit) 
			{
				A_PlaySound("Mech/Damaged/Critical",3);
				mechsounds.pushSound("Mech/Betty/CriticalHit");
				if(hp == hardpoints.lt) mechsounds.pushSound("Mech/Betty/LeftTorso");
				if(hp == hardpoints.rt) mechsounds.pushSound("Mech/Betty/RightTorso");
				if(hp == hardpoints.la) mechsounds.pushSound("Mech/Betty/LeftArm");
				if(hp == hardpoints.ra) mechsounds.pushSound("Mech/Betty/RightArm");
				if(hp == hardpoints.ll) mechsounds.pushSound("Mech/Betty/LeftLeg");
				if(hp == hardpoints.rl) mechsounds.pushSound("Mech/Betty/RightLeg");
				if(hp == hardpoints.ct) mechsounds.pushSound("Mech/Betty/CenterTorso");
				if(random(0,1)==1)DestroyHardpointItems(hp,false);
			}
			hp.internalhp -= dmg;
			if(hp.internalhp <= 0) 
			{
				hp.internalhp = 0;
				if( random(1,3)==3 ) 
				{
					SpreadHardpointDamage(hp,dmg/2);
					A_PlaySound("Mech/Damaged/Explosion",3);
				}
			
				A_PlaySound("Mech/Damaged/HardpointDead",3);
				if(hp == hardpoints.lt) mechsounds.pushSound("Mech/Betty/LeftTorso");
				if(hp == hardpoints.rt) mechsounds.pushSound("Mech/Betty/RightTorso");
				if(hp == hardpoints.la) mechsounds.pushSound("Mech/Betty/LeftArm");
				if(hp == hardpoints.ra) mechsounds.pushSound("Mech/Betty/RightArm");
				if(hp == hardpoints.ll) mechsounds.pushSound("Mech/Betty/LeftLeg");
				if(hp == hardpoints.rl) mechsounds.pushSound("Mech/Betty/RightLeg");
				if(hp != hardpoints.ct) mechsounds.pushSound("Mech/Betty/Destroyed");
	
				DestroyHardpointItems(hp);
			}
		}
		else
		{
			SpreadHardpointDamage(hp,dmg);
		}
	}
	
	void SpreadHardpointDamage(MechHardpoint hp, float dmg)
	{
		if(hp == hardpoints.la) DamageHardpoint(hardpoints.lt,dmg/2);
		if(hp == hardpoints.ra) DamageHardpoint(hardpoints.rt,dmg/2);
		if(hp == hardpoints.lt) DamageHardpoint(hardpoints.ct,dmg/4);
		if(hp == hardpoints.rt) DamageHardpoint(hardpoints.ct,dmg/4);
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{	
		if(checkVoodoo()) return super.DamageMobj(inflictor,source,damage,mod,flags,angle);
		
		float newdmg = float(damage)/10;
		if( !source ) 
		{
			ProcessHardpointDamage(mod,newdmg);
			return 0;
		}
		
		Actor damager = inflictor;
		if(mod == "hitscan") damager = source;
		double shootslope = (source.height/2);

		// Preform ray cast to determine where the shooter is aiming.
		FLineTraceData lt;
		damager.LineTrace(inflictor.angle+90,2048,source.pitch+random(-8,16),0,shootslope-random(0,source.height/4),0,0,lt);
		vector3 dmgpos = lt.HitLocation;
		double plrdmgz = (viewheight*Player.crouchfactor);

		vector2 mechangle = ( pos.x, pos.y );
		vector2 dmgpos2D  = ( dmgpos.x, dmgpos.y );
		mechangle = MDMath.VRotate(mechangle,angle+90);
		int lrpos = AngleTo(source);
		float hitangle = abs(atan2(mechangle.x - dmgpos.x , mechangle.y - dmgpos.y)) + frandom(-16,16);
		
		// Legs
		if( dmgpos.z < pos.z+(plrdmgz/4) ) 
		{ 
			if(lrpos > 0) ProcessHardpointDamage("MechDamage_LL",newdmg,damager);
			if(lrpos < 0) ProcessHardpointDamage("MechDamage_RL",newdmg,damager);
		}
		else // Torso
		{	
			// left/right torsos
			if( hitangle > 40 && hitangle < 100)
			{
				if(lrpos < 0) ProcessHardpointDamage("MechDamage_RT",newdmg,damager);
				if(lrpos > 0) ProcessHardpointDamage("MechDamage_LT",newdmg,damager);
			}
			// Left/right arm
			else if( hitangle >= 100 )
			{
				if(lrpos < 0) ProcessHardpointDamage("MechDamage_RA",newdmg,damager);
				if(lrpos > 0) ProcessHardpointDamage("MechDamage_LA",newdmg,damager);
			}
			// Center torso
			else
			{
				ProcessHardpointDamage("MechDamage_CT",newdmg,damager);
			}
		}
		
		return 0;
	}
	
	void ProcessHardpointDamage(Name mod, float damage, Actor damager = NULL)
	{	
		bool heatdmg = ( mod == "overheating" );
		//if(mod == "MechDamage_HD" || (heatdmg && random(1,12)==12) ) DamageHardpoint(hardpoints.hd,damage,heatdmg&&random(0,1));
		if(mod == "MechDamage_CT" || (heatdmg && random(1,5)==5) ) DamageHardpoint(hardpoints.ct,damage,heatdmg&&random(0,1));
		if(mod == "MechDamage_LT" || (heatdmg && random(1,3)==3) ) DamageHardpoint(hardpoints.lt,damage,heatdmg&&random(0,1));
		if(mod == "MechDamage_RT" || (heatdmg && random(1,3)==3) ) DamageHardpoint(hardpoints.rt,damage,heatdmg&&random(0,1));
		if(mod == "MechDamage_LA" || (heatdmg && random(1,4)==4) ) DamageHardpoint(hardpoints.la,damage,heatdmg&&random(0,1));
		if(mod == "MechDamage_RA" || (heatdmg && random(1,4)==4) ) DamageHardpoint(hardpoints.ra,damage,heatdmg&&random(0,1));
		if(mod == "MechDamage_LL" || (heatdmg && random(1,7)==7) ) DamageHardpoint(hardpoints.ll,damage,heatdmg&&random(0,1));
		if(mod == "MechDamage_RL" || (heatdmg && random(1,7)==7) ) DamageHardpoint(hardpoints.rl,damage,heatdmg&&random(0,1));
		
		if(  hardpoints.hd.internalhp <= 0 || hardpoints.ct.internalhp <= 0 ||
			(hardpoints.ll.internalhp <= 0 && hardpoints.rl.internalhp <= 0)   ) 
		{
			Die(NULL,damager);
			health = 0;
			player.health = 0;
		}
	}
	
	override void PostBeginPlay()
	{
		// Setup mech support systems.
		if(!player) return;
		
		SetupWeapons();
		selectedGroup = 1;
		boblendir = 1;
		selectedWeapon = 1;
		weapons_tonnage += enginesize;
		maxgroup = getMaxWeaponGrouping();
		defaultfov = player.desiredFOV;
		
		// SoundQueue 
		mechsounds = SoundQueue.SQ_Create(self, 32);
		
		weapons_fired = false;
		if(countStruct("JumpJet")>0) mech_jetsfuel = 100;
		weapon_groupfire = false;
		LegAng = angle;
		//angle = 0;
		speed = 0; // Stop normal movement;
		// Convert KPH to UPT
		//startMechbay();
		MoveSpeed = ceil((MoveSpeedKPH*15000)/100000);
		MoveSpeed_Max = MoveSpeed;
		throttle_max = 1;
		if(defaultmovement) 
		{
			A_SetSpeed(MoveSpeed*0.08);
			level.aircontrol = 1;
			level.airfriction = 0.87;
		}
		
		super.PostBeginPlay();
	}
	
	override void tick()
	{	
		
		if(defaultmovement)
		{			
			// Roll/Sway system
			uint btns = player.cmd.buttons;
			bool strafing = (btns & BT_MOVELEFT) | (btns & BT_MOVERIGHT);
			if(btns & BT_MOVELEFT) rolloffs -= 1;
			if(btns & BT_MOVERIGHT) rolloffs += 1;
			if(!strafing) rolloffs *= 0.90;
			if(abs(rolloffs) < 0.2) rolloffs = 0;
			rolloffs = clamp(rolloffs,-2.25,2.25);
			
			if( rolloffs != 0 ) A_SetRoll(rolloffs);
		}
		
		if(!checkVoodoo() && health > 0) 
		{
			// Overtonnage logic
			if(overtonnage)
			{
				float truetonnage = mech_shutdown ? mech_tonnage*0.5 : mech_tonnage;
				overfactor = clamp(truetonnage/(weapons_tonnage*0.35), 0.1, 1.0);
				A_SetSpeed(MoveSpeed*0.12*overfactor*throttle_max);
			}
			
		    // Process hardpoint damage effects
			if( hardpoints.ll.internalhp <= 0 || 
				hardpoints.rl.internalhp <= 0   )
			{
				throttle_max = 0.5;
				LegSpeed = 1;
			}
			else if( hardpoints.lt.internalhp < hardpoints.lt.max_internal || 
				     hardpoints.rt.internalhp < hardpoints.rt.max_internal    )
			{
				throttle_max = 0.8;
			}
			else
			{
				throttle_max = 1.0;
			}
		
			mechsounds.Tick();
			if(!mech_shutdown)
			{
				// Make sure player doesn't have any actual weapons.
				for(let w = Inv; w != null; w = w.Inv)
				{
					let weap = Weapon(w);
					if(weap)
					{
						if(!(weap is "CrosshairHandler")) weap.Destroy();
					}
				}
			
				if(vel.length() > 0) A_Explode(3+(vel.length()*1.5),30,!XF_HURTSOURCE);
				mech_movement(); 
				mech_weapons();
			}
			if(mech_shutdown)process_shutdown();
		}
		else 
		{ 
			speed = 1; 
		}
		super.tick();
	}
	
}
extend class MechWarrior
{
	float TiltOsc;
    float StepOsc;
    float TiltOffset;
    float StepOffset;
    float CrouchMulti;

    void Bobbing() {
		// Don't bob on voodoos!
		if(!player || !player.mo || player.mo != self) return;
		
		float tiltosc_amp =  10 + (vel.Length()/3);
		float steposc_amp =  15 + (vel.Length()/2);
		tiltosc_amp = clamp(tiltosc_amp,0,18);
		steposc_amp = clamp(steposc_amp,0,24);
        TiltOsc += tiltosc_amp;
        StepOsc += steposc_amp;
		
        CrouchMulti = 2 - Player.CrouchFactor;

        if (TiltOsc >= 360.0 || TiltOsc < 0.0)    {
            TiltOsc = 0.0;
        }
        if (StepOsc >= 360.0 || StepOsc < 0.0)    {
            StepOsc = 0.0;
        }

		int vel = vel.length();
		if(vel != 0)
		{
			TiltOffset  = sin(TiltOsc);
			TiltOffset *= (vel/2) - (LegVel*2);
			TiltOffset *= 0.15;
			if(defaultmovement) StepOffset *= 3;
			TiltOffset *= CrouchMulti;

			StepOffset  = sin(StepOsc);
			StepOffset *= (vel/2) + (LegVel*2);
			StepOffset *= (1.78 + ((mech_tonnage-40)/100));
			StepOffset *= 0.8;
			if(defaultmovement) StepOffset *= 0.7;
			StepOffset *= CrouchMulti;
		}
		
		A_SetRoll(-TiltOffset);
        //SetOrigin(Vec3Angle(TiltOffset * 0.5, angle+90, 0, false), true);
        Player.ViewZ += StepOffset;
    }
}
