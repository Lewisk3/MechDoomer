// Weapon base

class Mechbase_Actor : Actor
{
	actor hitactor;
	double heatgen;
	vector3 spawnpos;
	double basedamage;
	int truedamage;
	MechWarrior mechplayer;
	float minimum_range;
	float maximum_range;
	bool cosmetic;
	Sound firesound;
	
	Property FireSound : firesound;
	Property Heat : heatgen;
	Property ConstDamage: truedamage;
	Property MinimumRange : minimum_range;
	Property MaximumRange : maximum_range;
	
	override void BeginPlay()
	{
		A_PlaySound(firesound,CHAN_WEAPON,1,0,0);
		super.BeginPlay();
	}
	
	void BaseInit()
	{
		spawnpos = pos;
		// SetDamage(truedamage);
		_SetBaseDamage();
	}
	void Converge(float spd=0.30)
	{
		if(mechplayer)
		{
			float truespd = vel.length()*spd;
			vector3 npos = pos-vel;
			vector3 tpos = mechplayer.pos;
			tpos.z += (mechplayer.viewheight*mechplayer.player.crouchfactor);
			float ato = AngleTo(mechplayer);
			float pto = MDMath.getPitchBetween(pos,tpos);
			npos.x += ( cos(ato)*truespd);
			npos.y += ( sin(ato)*truespd);
			npos.z += (-sin(pto)*truespd);
			npos += vel;
			SetOrigin(npos,true);
		}
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		hitactor = other;
		return super.CanCollideWith(other, passive);
	}
	
	override void Tick()
	{
		if(truedamage && hitactor && hitactor.bSHOOTABLE)
		{
			if(pos.z >= hitactor.pos.z && pos.z <= hitactor.pos.z+hitactor.height)
			{
				if(hitactor != mechplayer && !cosmetic) 
				{
					hitactor.DamageMobJ(self,mechplayer,truedamage,damagetype,0,mechplayer.angle);
					SetState(ResolveState("Death"));
				}
			}
			hitactor = NULL;
		}
		if(mechplayer && CVar.GetCVar("mwd_weaponsconverge",mechplayer.player).getBool())
			Converge();
			
		super.Tick();
	}
	float getTravelDistance()
	{
		return MDMath.Distance3D(pos, spawnpos);
	}
	float getPitchTo(Vector3 topos)
	{	
		return MDMath.getPitchBetween(pos, topos);
	}
	void adjustHeatLevel(double amt)
	{
		if(mechplayer && !cosmetic) mechplayer.HeatLevel += amt*MWHEAT_MOD;
	}
	void SetConstDamage(int newdamage)
	{
		truedamage = newdamage;
	}
	void _SetBaseDamage()
	{
		basedamage = !truedamage ? GetMissileDamage(0,1) : truedamage;
	}
	void setHeat(double val)
	{
		heatgen=val;
	}
}

class Mechbase_Weapon : Inventory
{
	int cooldown_timer;
	float volleycooldown;
	float cooldown;
	int group;
	int WeaponID;
	MechHardpoint hardpoint;
	bool dofire;
	bool isHomming;
	int volley_amt;
	int volley_inital;
	bool volley_cosmetic;
	int hardslots;
	float weight;
	Name displayName;
	class<Mechbase_Actor> weapType;
	int weapDistance;
	int weapSpeed;
	int worth;
	int ammouse;
	int ammogive;
	float lockonspeed;
	float hitscan_dmg;
	bool aimtarget;
	bool target_inview;
	float hitscan_distance;
	//float hitscan_amt;
	int delay;
	class<Mechbase_Ammo> ammotype;
	Sound atksnd;
	
	
	Property DisplayName : displayName;
	Property DefaultGroup : group;
	Property WeaponType : weapType;
	Property Hitscan : hitscan_dmg, hitscan_distance;
	Property AmmoType : ammotype;
	Property AmmoGive : ammogive;
	Property AmmoUse : ammouse;
	Property CValue : worth;
	Property IsHommingMissile : isHomming;
	Property LockingSpeed : lockonspeed;
	Property WeaponDelay : delay;
	Property AttackSound : atksnd;
	Property WeaponParams : weapDistance, weapSpeed;
	Property HardslotSize : hardslots;
	Property Tonnage : weight;
	Property Cooldown : cooldown, volleycooldown;
	
	// Hardpoint processing
	int dmg_taken;
	bool broken;
	
	Default
	{
		Mechbase_Weapon.DisplayName "Base Weapon";
		Mechbase_Weapon.DefaultGroup 1;
		Mechbase_Weapon.WeaponParams 18, 30;
		Mechbase_Weapon.Tonnage 1;
		Mechbase_Weapon.HardslotSize 1;
		Inventory.maxamount 12; // Each weapon should have atleast 12 available slots.
	}
	
	action bool checkCooldown()
	{
		return (invoker.cooldown_timer == 0);
	}

	action bool FireBullets(int damage,int distance=0,int sxoff=1, int syoff=1)
	{
		if(!checkCooldown()) return false;
		let plr = MechWarrior(invoker.Owner);
		if(invoker.ammouse > 0)
		{
			if(plr.countammo(invoker.ammotype) < invoker.ammouse) return false;
			plr.TakeAmmo(invoker.ammotype,invoker.ammouse);
		}
		if(plr)
		{
			SoundEmitter.SE_Trigger(invoker.atksnd,plr.pos);
			plr.LineAttack(plr.angle,distance,plr.pitch,damage,"Ballistic","BulletPuff");
		}
		invoker.cooldown_timer = invoker.delay;
		return true;
	}
	action bool FireVolley(int amt=0, int xspread=5, int yspread=5, Sound volleysnd="", bool extra_cosmetic=false)
	{
		if(!invoker.dofire && checkCooldown())
		{
			let plr = MechWarrior(invoker.Owner);
			if(!plr) return false;
			if(invoker.ammouse > 0 && plr.countammo(invoker.ammotype) < invoker.ammouse) return false;
			SoundEmitter.SE_Trigger(volleysnd,plr.pos);
			invoker.dofire = true;
			invoker.volley_amt = amt;
			invoker.volley_inital = amt;
			invoker.volley_cosmetic = extra_cosmetic;
		}
		else if(invoker.volley_amt > 0)
		{
			// Extra_Cosmetic will make only the first object fired deal damage/generate heat.
			bool cosmetic = invoker.volley_cosmetic ? (invoker.volley_amt < invoker.volley_inital) : false;
			if(FireWeapon(invoker.weapType,invoker.hardpoint.pos.x+random(-xspread,xspread),
						  invoker.hardpoint.pos.y+random(-yspread,yspread),invoker.weapDistance,invoker.weapSpeed,false,cosmetic))
			{
				invoker.volley_amt--;
				invoker.cooldown_timer = invoker.volleycooldown*35.0;
			}
		}
		if(invoker.volley_amt <= 0 && invoker.dofire)
		{
			invoker.dofire = false;
			invoker.cooldown_timer = invoker.cooldown*35.0;
			return false;
		}
		return true;
	}
	action bool FireWeapon(class<Mechbase_Actor> type, int xoffset, int yoffset, int distance, int spd, bool instant=false, bool cosmetic=false)
	{	
		if(checkCooldown() || instant)
		{
			let plr = MechWarrior(invoker.Owner);
			if(!plr)return false;
			if(invoker.ammouse > 0)
			{
				if(plr.countammo(invoker.ammotype) < invoker.ammouse) return false;
				plr.TakeAmmo(invoker.ammotype,invoker.ammouse);
			}
			SoundEmitter.SE_Trigger(invoker.atksnd,plr.pos);
			xoffset += random(-5,5);
			yoffset += random(-5,5);
			double offsangle = plr.angle;
			double offspitch = plr.pitch;
			Array<FoundStruct> tmp;
			bool onarms = ( invoker.hardpoint == plr.hardpoints.la && plr.FindStructs("StructActuator", plr.hardpoints.la, true, tmp) ) || 
						  ( invoker.hardpoint == plr.hardpoints.ra && plr.FindStructs("StructActuator", plr.hardpoints.ra, true, tmp) );
			bool onlegs = ( invoker.hardpoint == plr.hardpoints.ll || invoker.hardpoint == plr.hardpoints.rl);
			
			// If this weapon is NOT on an actuated arm, fire from torso aim.
			if(!onarms)
			{
				// Align to cockpit model's rotation.
				let cockpit = plr.models_reference.cockpit;
				if(cockpit) offsangle = cockpit.angle;
			}
			if(onlegs) offsangle = plr.LegAng;
			
			vector2 offs = MDMath.VOffset(offsangle, distance, xoffset, 1);			
			Vector3 lpos = plr.Vec3Offset(offs.x,offs.y,(plr.viewheight*plr.player.CrouchFactor)+yoffset);
			
			let weap = Mechbase_Actor(Spawn(type,lpos));
			if(weap)
			{
				plr.A_AlertMonsters(1024);
				invoker.cooldown_timer = invoker.cooldown*35.0;
				weap.target = invoker.Owner;
				weap.mechplayer = MechWarrior(invoker.Owner);
				weap.pitch = offspitch;
				weap.angle = offsangle;
				weap.vel = (
						cos(offsangle)*cos(offspitch),
						sin(offsangle)*cos(offspitch),
						-sin(offspitch)
						) * spd;
				weap.cosmetic = cosmetic;
				return true;
			}
		}
		return false;
	}
	
	void weapon_tick()
	{
		let plr = MechWarrior(Owner);
		if(!plr) return;
		
		// Discard lock if we're not a homing weapon and we've just been selected.
		if(plr.selectedWeapon == WeaponID && !isHomming && plr.locktimer )
		{
			plr.locktimer = 0;
			plr.targetlocked = false;
		}
		
		if(isHomming && Owner)
		{
			// If this weapon is selected.
			if(plr.selectedWeapon == WeaponID)
			{	
				// Target locked logic.		
				aimtarget = (plr.targetenemy && plr.targetreticle && target_inview);

				if(plr.locktimer == 0 && aimtarget)SoundEmitter.SE_Trigger("Mech/Target/BeginLock",Owner.pos);
				if(plr.locktimer < 100 && aimtarget) plr.locktimer += lockonspeed;
				if(plr.locktimer > 90 && !plr.targetlocked && aimtarget) 
				{
					plr.targetlocked = true;
					plr.prevlock = plr.targetenemy;
					SoundEmitter.SE_Trigger("Mech/Target/Locked",Owner.pos);
				}
				if(!aimtarget && plr.locktimer > 0) plr.locktimer -= lockonspeed*2;
				if(plr.locktimer < 100) plr.targetlocked = false;				
				if(plr.targetenemy && !plr.prevlock) plr.prevlock = plr.targetenemy;
				if(plr.targetlocked && plr.targetenemy != plr.prevlock) 
				{
					plr.locktimer = 0;
					plr.prevlock = NULL;
				}
				//console.printf("[Missile Status]\n LOS: %i\n Lock Process: %i%\n Has Lock: %i", aimtarget, plr.locktimer, plr.targetlocked);
				
				// Note: IsVisible appears to need an entire tic to work properly,
				// this is why it's cached to target_inview.
				LookExParams visview;
				visview.FOV = plr.player.FOV;
				visview.maxDist = double.infinity;
				visview.flags = LOF_NOSIGHTCHECK;	
				target_inview = plr.IsVisible(plr.targetenemy, true, visview); 	
			}
			
		}
		
		if(cooldown_timer > 0)cooldown_timer--;
		if(dofire)FireVolley();
	}
	
	override void PostBeginPlay()
	{
		cooldown_timer = 0;
		dofire = false;
		super.PostBeginPlay();
	}
	
	override void tick()
	{
		weapon_tick();
		super.tick();
	}

	virtual bool MWFire()
	{
		let plr = MechwarriorBase(Owner);
		if(!plr) return false;
		
		int curammo = 0;
		bool ret;
		if(ammotype) curammo = plr.countammo(ammotype);
		if(weapType)
		{
			ret = FireWeapon(weapType,hardpoint.pos.x,hardpoint.pos.y,weapDistance,weapSpeed);
		}
		else
		{
			ret = FireBullets(hitscan_dmg,hitscan_distance);
		}
		if(curammo > 0)
		{
			if(plr.countammo(ammotype) == 0)
			{
				// If you want to make a betty skin, this is just another option.
				plr.mechsounds.pushSound("Mech/Betty/NoAmmo");
			}
		}
		return ret;
	}
}


// Missiles
class MechMissile : Mechbase_Actor
{
	float realdamage;
	bool homming;
	bool inrange;
	
	Property Homming : homming;
	
	Default
	{	
		Radius 11;
		Height 8;
		//+DEHEXPLOSION
		//+ROCKETTRAIL
		//+PUFFGETSOWNER
		//+SCREENSEEKER
		SeeSound "weapons/rocklf";
		//DeathSound "weapons/rocklx";
		Projectile;
	}
	
	override void PostBeginPlay()
	{
		BaseInit();
		if(mechplayer && mechplayer.targetlocked) tracer = mechplayer.targetenemy;
		if(homming) bSEEKERMISSILE = true;
		if(minimum_range > 0) 
		{
			inrange = false;
			SetConstDamage(0);
			realdamage = 0; 
		}
		else
		{
			inrange = true;
		}
		super.PostBeginPlay();
	}
	
	override void tick()
	{
		float distance = getTravelDistance();
		if(inrange)
		{
			realdamage = basedamage * (1.0-(distance/(maximum_range*4.5)));
			realdamage = clamp(realdamage,0,basedamage);
			SetConstDamage(floor(realdamage));
			if(distance > maximum_range*4.5) inrange = false;
		}
		else if( distance >= (minimum_range*4.5) && distance < (maximum_range*4.5) )
		{
			inrange = true; 
			SetConstDamage(basedamage); 
		}
		
		Spawn("MissileLight", Vec3Offset(cos(angle)*-10,sin(angle)*-10,0));
		super.tick();
	}
	
	  States
	  {
		  Spawn:
			MISS B 1;
			MISS AB 1 adjustHeatLevel(heatgen);
		  SpawnLoop:
			MISS AB 1 Bright A_JumpIfTargetInLOS("Seek");
			Loop;
		  Seek:
			MISS ABAB 1 Bright 
			{
				if(homming && tracer) 
				{
					vector3 corrected_pos = (tracer.pos.x, tracer.pos.y, tracer.pos.z+(tracer.height/2));
					pitch = getPitchTo(corrected_pos);
					A_SeekerMissile(20,20,SMF_CURSPEED|SMF_PRECISE,0,maximum_range/64);
				}
			}
		  goto SpawnLoop;
		  Death:
			TNT1 A 2 Bright 
			{ 
				if(inrange) 
				{
					A_PlaySound("weapons/rocklx");
					A_Explode(damage/2,256,0); 
					Spawn("MissileExplosion",pos); 
				}
				else
				{
					let misl = Spawn("MissileDebris", pos);
					misl.Scale.x = Scale.x;
					misl.Scale.y = Scale.y;
					misl.angle = angle;
				}
			}
			Stop;
	  }
}
class MissileLight : Actor
{
	Default
	{
		+NOINTERACTION;
	}
	States
	{
		Spawn:
			TNT1 A 1;
		stop;
	}
}


// Lasers
class Laser : Mechbase_Actor
{
	Color gfx_color;
	double realdamage;
	Property FXColor : gfx_color;
	
	Default
	{
		Height 2;
		Radius 3;
		+NOGRAVITY;
		Alpha 1.0;
		RenderStyle "Add";
		Decal "DoomImpScorch";
		+PUFFGETSOWNER
		Laser.FXColor "FF FF FF";
		Mechbase_Actor.Heat 1;
		Speed 0.1;
		//RenderStyle "Add";
		Projectile;
	}

	override void tick()
	{
		if(!basedamage) BaseInit();
		realdamage = basedamage * (1.0-(getTravelDistance()/(maximum_range*6)));
		realdamage = clamp(realdamage,0,basedamage);
		SetConstDamage(floor(realdamage));
		super.tick();
	}

	States
	{
		Spawn:
			LASR A 1 NoDelay adjustHeatLevel(heatgen);
		SpawnLoop:
			LASR A 1;
		loop;
		Death:
			LASR A 1;
			LASR A 1
			{
				// console.printf("Damage: %d", floor(realdamage) );
				for(int i = 0; i < 30; i++)
				{
					A_SpawnParticle(gfx_color,SPF_FULLBRIGHT | SPF_RELATIVE,16,2,
					random(-45,45),random(-30,30),0,random(-30,30),0,3,0.5,0);
				}
				SoundEmitter.SE_Trigger("Laser/Impact",pos);
			}
		stop;
	}
}

class PPCExplosion : Actor
{
	Default
	{
		+NOGRAVITY
		+NOBLOCKMAP
		XScale 0.8;
		YScale 0.8;
	}

	States
	{
		Spawn:
			PEXP OPABCDEFGHIJKLMN 2;
		stop;
	}
}

class MissileExplosion : Actor
{
	Default
	{
		+NOGRAVITY
		+NOBLOCKMAP
		XScale 1.6;
		YScale 1.6;
	}

	States
	{
		Spawn:
			EXPL ABCDEFGHIJKLMNOP 2;
		stop;
	}
}

class RandomExplosions : MissileExplosion
{
	int expl_count;
	int wait;
	float zoffs;
	vector3 spawnpos;
	float timer;
		
	static void Trigger(vector3 pos, int amt, int tics, float zoffset)
	{
		let rexpl = RandomExplosions(Spawn("RandomExplosions",pos));
		if(rexpl)
		{
			rexpl.spawnpos = pos;
			rexpl.expl_count = amt;
			rexpl.wait = tics;
			rexpl.zoffs = zoffset;
		}
	}
	
	void DoExplosion()
	{
		let expl = Spawn("MissileExplosion",spawnpos);
		if(expl)
		{
			float angle = frandom(-180,180);
			float dist = frandom(-50,50);
			vector3 npos = expl.pos;
			npos.x += cos(angle)*dist;
			npos.y += sin(angle)*dist;
			npos.z += zoffs+frandom(-15,15);
			expl.SetOrigin(npos,false);
			float scalemod = frandom(0.5,1.5);
			expl.A_SetScale(scalemod,scalemod);
			expl.bSPRITEFLIP = random(0,1);
		}
	}
	
	override void Tick()
	{
		if(!timer && expl_count > 0) 
		{
			timer = wait+random(wait*0.5,wait);
			DoExplosion();
			expl_count--;
		}
		else
		{
			timer--;
		}
		super.Tick();
	}
	
	States
	{
		Spawn:
			TNT1 A 1;
			TNT1 A 0 A_JumpIf(expl_count, "Spawn");
		Death:
			TNT1 A 1;
		stop;
	}
}

class AMS_Missile : Mechbase_Actor
{
	int projdmg;
	float convergefactor;
	property Effectiveness : projdmg;
	property Efficiency : convergefactor;
	
	
	Default
	{
		Projectile;
		+SEEKERMISSILE
		-NOBLOCKMAP
		Height 4;
		Radius 3;
		Speed 9;
		Scale 0.15;
		AMS_Missile.Effectiveness 12;
		AMS_Missile.Efficiency 0.5;
	}
	
	override void PostBeginPlay()
	{
		speed *= convergefactor;
		super.PostBeginPlay();
	}
	
	States
	{
	  Spawn:
		AMSL A 4;
	  SpawnLoop:
		AMSL A 1 Bright
		{
			if(tracer)
			{
				angle = AngleTo(tracer);
				if(tracer.damage <= 0) 
				{
					tracer.Destroy();
					return ResolveState(Null);
				}
				if(Distance3D(tracer) <= radius*4) 
				{
					tracer.SetDamage(tracer.damage-projdmg); 
					return ResolveState("Death");
				}
				A_SeekerMissile(20,20,SMF_CURSPEED,999/64);
			}
			else
			{
				Die(self,self);
			}
			return ResolveState(Null);
		}
		Loop;
	  Death:
		TNT1 A 1 
		{	
			let exp = MissileExplosion(Spawn("MissileExplosion",pos));
			if(exp)
			{
				exp.A_SetScale(0.3,0.3);
			}
		}
		Stop;
	}
}

class PPCBall : Mechbase_Actor
{	
	Default
	{
		Height 3;
		Radius 3;
		Damage 40;
		Speed 1;
		Alpha 0.75;
		RenderStyle "Add";
		DamageType "Lightning";
		+PUFFGETSOWNER
		XScale 0.25;
		YScale 0.2;
		Projectile;
	}

	override void tick()
	{
		Converge();
		if(!basedamage) BaseInit();
		if(minimum_range > 0)
		{
			if( getTravelDistance() >= (minimum_range*3) ) 
			{
				A_SetRenderStyle(1.0,STYLE_NORMAL);
				SetConstDamage(basedamage);
			}
			else
			{
				SetConstDamage(0);
			}
		}
		else 
		{
			A_SetRenderStyle(1.0,STYLE_NORMAL);
		}
		super.tick();
	}

	States
	{
		Spawn:
			MPPC A 1;
			TNT1 A 0 
			{				
				adjustHeatLevel(heatgen);
			}
		SpawnLoop:
			MPPC A 1;
		loop;
		
		Death:
			MPPC A 1;
			TNT1 A 5 
			{
				// /A_Explode();
				Spawn("PPCExplosion",pos);
			}
			TNT1 A 0 
			{
				if(damage) 
				{
					vector3 spos = pos;
					spos.x += frandom(-8,8);
					spos.y += frandom(-8,8);
					let expl = Spawn("MissileExplosion",spos);
					expl.Scale.x = frandom(0.6,1.3);
					expl.Scale.y = frandom(0.6,1.3);
				}
			}
			stop;
	}
}

class Flame : Mechbase_Actor
{
	Default
	{
		Speed 10;
		DamageType "Fire";
		RenderStyle "Add";
		Alpha 1.0;
		XScale 0.45;
		YScale 0.45;
		Gravity 1.6;
		Projectile;
	}
	States
	{
		Spawn:
			FIO1 B 1;
			TNT1 A 0 
			{
				adjustHeatLevel(heatgen);
			}
		SpawnLoop:
			FIO1 BCDEFGHIJKLMN 1
			{
				vel.z -= Gravity;
			}
		stop;
		 
		Death:
			FIO2 A 2 A_FadeOut(0.1);
		stop;
	}
}

class GaussBall : Mechbase_Actor
{
	Default
	{
		Speed 30;
		Projectile;
	}

	States
	{
		Spawn:
			GAUS A 1;
			TNT1 A 0 
			{
				adjustHeatLevel(heatgen);
			}
		SpawnLoop:
			GAUS A 1;
		loop;
		
		Death:
			GAUS A 1;
			GAUS A 1 
			{
				let deb = Spawn("Debris_Spawner",pos);
				if(deb)
				{
					deb.angle = angle;
					deb.pitch = pitch;
				}
			}
		stop;
	}
}

class AutocannonBall : Mechbase_Actor
{
	Default
	{
		Speed 60;
		Radius 10;
		Height 5;
		Projectile;
	}

	States
	{
		Spawn:
			AUTO A 1;
			TNT1 A 0 
			{
				adjustHeatLevel(heatgen);
			}
		SpawnLoop:
			AUTO A 1;
		loop;
		
		Death:
			AUTO A 1;
			AUTO A 1 
			{
				let deb = Spawn("Debris_Spawner",pos);
				if(deb)
				{
					deb.angle = angle;
					deb.pitch = pitch;
				}
			}
		stop;
	}
}
class MechBullet : Mechbase_Actor
{
	Default
	{
		Damage 5;
		Speed 100;
		Projectile;
	}
	
	override void tick()
	{
		if(!basedamage) BaseInit();
		if(maximum_range > 0)
		{
			if( getTravelDistance() >= (maximum_range*3) ) Destroy();
		}
		super.tick();
	}
	
	States
	{
		Spawn:
			AUTO A 1;
		loop;
		
		Death:
			PUFF ABCD 2;
		stop;
	}
}

// Targetting effects (Adaptation of Xasers rocket-lock from Argent)

class MechTargetCamera : Actor
{
	vector3 offset;
	
	Default
	{
		+NOINTERACTION
	}

	static MechTargetCamera Create(Actor reticle, Actor obj,vector3 offs)
	{
		let cam = MechTargetCamera(Spawn("MechTargetCamera",(0,0,0)));
		cam.tracer = obj;
		cam.offset = offs;
		cam.master = reticle;
		
		return cam;
	}

	States
	{
		Spawn:
			TNT1 A 1
			{
				if(tracer && tracer.health > 0)
				{
				    A_Warp(AAPTR_TRACER, 2, offset.x, offset.y + tracer.height/2, 0, 
						WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE, null, 0, 1.5);
					angle = tracer.angle-180;
				} else { return ResolveState("Death"); }
				
				return ResolveState(Null);
			}
		loop;
		
		Death:
			TNT1 A 1;
		stop;
	}
}

class MechTargetReticle : Actor
{
	Vector2 offset;
	Vector2 dest_offset;
	MechTargetCamera cam;
	
	Array<MechTargetReticle> corners;

	Default
	{
		+NOINTERACTION
		//RenderStyle 'Add';
		Alpha 1.0;
		Scale 0.5;
	}

	override void tick()
	{
		// Move to destination offset
		if(dest_offset.x > offset.x) offset.x += 4;
		if(dest_offset.x < offset.x) offset.x -= 4;
		if(dest_offset.y > offset.y) offset.y += 4;
		if(dest_offset.y < offset.y) offset.y -= 4;
		if( abs(dest_offset.x-offset.x) < 2) offset.x = dest_offset.x;
		if( abs(dest_offset.y-offset.y) < 2) offset.y = dest_offset.y;
		
		super.tick();
	}

	States
	{
	Spawn:
		RETC A 0 Bright; // primer state. The frame gets changed on spawn.
		RETC "#" 1 Bright 
		{
			if(CVar.GetCVar("mwd_viewport_target",master.player).getBool())
			{
				sprite = GetSpriteIndex("TNT1");
			}
			RFollowTracer();
		}
		Wait;
	Death:
		RETC "#" 1;
		stop;
	}

	static MechTargetReticle InitCreate(Actor shooter, Actor victim, int size)
	{
		if(shooter && victim) {
			
			let masterReticle        = MechTargetReticle.RSpawn(shooter, victim, (-size -victim.radius/2,       victim.height/2), 1);
			masterReticle.corners.Push(MechTargetReticle.RSpawn(shooter, victim, ( size +victim.radius/2,       victim.height/2), 0));
			masterReticle.corners.Push(MechTargetReticle.RSpawn(shooter, victim, (-size -victim.radius/2, size -victim.height/2), 3));
			masterReticle.corners.Push(MechTargetReticle.RSpawn(shooter, victim, ( size +victim.radius/2, size -victim.height/2), 2));
			masterReticle.cam = MechTargetCamera.Create(masterReticle,victim,(0,0,0));
			return masterReticle;
		}
		return null;
	}

	static MechTargetReticle RSpawn(Actor shooter, Actor victim, Vector2 destoff, int frame)
	{
		if(shooter && victim) {
			Vector2 rotpos = RotateVector((0, 1), shooter.AngleTo(victim));
			let newReticle = MechTargetReticle(Spawn('MechTargetReticle', victim.pos + (rotpos.x, rotpos.y, victim.height/2)));
			if(newReticle) {
				newReticle.master = shooter;
				newReticle.tracer = victim;
				newReticle.dest_offset = destoff;
				newReticle.frame  = frame;
			}
			return newReticle;
		}
		return null;
	}

	void RDeconstruct(bool alsoDie = true)
	{
		// [XA: Argent]
		// Remove thyself and minions.
		let plr = MechWarrior(master);
		// We check cam to make sure we're the master, otherwise we get 3 betty announcements.
		if(plr && cam && tracer && tracer.health <= 0)
		{
			plr.mechsounds.pushSound("Mech/Betty/TargetEliminated");
		}	
		for(int i = 0; i < corners.Size(); i++) {
			if(corners[i]) {
				corners[i].RDeconstruct(alsoDie);
			}
		}
		if(alsoDie) {
			SetStateLabel('Death');
		}
	}

	state RFollowTracer()
	{
		// [XA: Argent]
		// Keep the reticle indicator on target. Also check if the target still
		// exists; if they prematurely die or are removed, trigger fade-out.
		if(tracer && tracer.health > 0) 
		{
			A_Warp(AAPTR_TRACER, 2, offset.x, offset.y + tracer.height/2, tracer.AngleTo(master), WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_ABSOLUTEANGLE);
			return null;
		}
		else 
		{ 
			RDeconstruct(false);
			return ResolveState('Death');
		} 
	}
}




