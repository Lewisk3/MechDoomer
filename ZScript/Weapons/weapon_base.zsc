// Weapon base
class Mechbase_Actor : FastProjectile
{
	PlayerInfo controlplr;
	double heatgen;
	vector3 spawnpos;
	double basedamage;
	double truedamage;
	MechWarrior mechplayer;
	double minimum_range;
	double maximum_range;
	double projGravity; 
	bool cosmetic;
	Sound firesound;
	Sound DOS_firesound;
	
	Property FireSound : firesound;
	Property ClassicFireSound : DOS_firesound;
	Property Heat : heatgen;
	Property ConstDamage: truedamage;
	Property Gravity : projGravity;
	Property MinimumRange : minimum_range;
	Property MaximumRange : maximum_range;
	
	Default
	{
		+INTERPOLATEANGLES;
	}
	
	override void PostBeginPlay()
	{
		if(mechplayer.player ) 
			controlplr = mechplayer.player;
		else 
			controlplr = players[consoleplayer];
			
		// Swap to alt-sound if CVar is flipped.
		Sound finalsound = firesound;
		if(mechplayer && DOS_firesound && CVar.GetCVar("mwd_useclassicsound", controlplr).getBool())
			finalsound = DOS_firesound;
		
		if(finalsound) SoundOnActor.Trigger(finalsound, mechplayer);
		adjustHeatLevel(heatgen);
		super.PostBeginPlay();
	}
	
	void BaseInit()
	{
		spawnpos = pos;
		// SetDamage(truedamage);
		_SetBaseDamage();
	}
	void Converge(double spdfac=1.0)
	{
		double spd = (!mechplayer.player || mechplayer.checkAI()) ? 0.08*spdfac : CVar.GetCVar("mwd_converge_speed", controlplr).getFloat()*spdfac;
		if(mechplayer && spd > 0)
		{
			// Find distance to aim
			FLineTraceData lt;
			mechplayer.LineTrace( mechplayer.angle, 1000 * MWGAMEPLAY_UNITMETER, 
								  mechplayer.pitch, TRF_SOLIDACTORS, 
								  mechplayer.viewheight, 80,0, lt     );
			double aimdist = lt.Distance;
			aimdist = clamp(aimdist, 1, 256*256);
			double facedist = 20 * MWGAMEPLAY_UNITMETER;
			double distspd = (facedist/aimdist) * 0.24;
			double truespd = vel.length()*clamp(distspd, 0, spd);
			
			// Converge onto aim
			vector3 npos = Vec3Offset(-vel.x,-vel.y,-vel.z);
			vector3 tpos = mechplayer.pos;
			tpos.z += mechplayer.player ? (mechplayer.viewheight*mechplayer.player.crouchfactor) : mechplayer.viewheight;
			double ato = AngleTo(mechplayer);
			double pto = MDMath.getPitchBetween(pos,tpos);
			double cpitch = cos(-pto);
			vector3 addpos = (cos(ato)*truespd*cpitch, sin(ato)*truespd*cpitch, -sin(pto)*truespd);
			npos = level.Vec3Offset(npos, addpos+vel);
			SetOrigin(npos,true);
		}
	}
	
	override int SpecialMissileHit(Actor victim)
	{
		// Do not hit physical movement hitbox.
		if(victim is "Mechwarrior") return 1;

		if((victim is "MechHitBox") && MechHitBox(victim).mech == mechplayer) 
		{
			return 1;
		}
		if(truedamage)
		{
			bool is_battlearmor = (mechplayer.mechtype == mechplayer.MechType_BattleArmor);
			double damagefinal =  is_battlearmor ? ceil(truedamage*MWGAMEPLAY_BADMGSCALE) : truedamage;
			if(!cosmetic)
			{
				if(!(victim is "MechHitBox")) damagefinal *= MWGAMEPLAY_WEAPDMGSCALE;
				victim.DamageMobJ(self,mechplayer,damagefinal,damagetype,0,mechplayer.angle);
			}
			SetState(ResolveState("Death"));
			return 0;
		}
		return -1;
	}
	
	override void Tick()
	{
		if(mechplayer) Converge();	
		if(projGravity && pos.z > floorz)
		{
			A_SetPitch(pitch + (projGravity*0.2), SPF_INTERPOLATE);
			vel.z = -sin(pitch)*speed;
		}
		super.Tick();
	}
	double getTravelDistance(bool unitmeter=true)
	{
		double convert = (unitmeter ? MWGAMEPLAY_UNITMETER : 1.0);
		return MDMath.Distance3D(pos, spawnpos) / convert;
	}
	double getPitchTo(Vector3 topos)
	{	
		return MDMath.getPitchBetween(pos, topos);
	}
	void adjustHeatLevel(double amt)
	{
		if(mechplayer && !cosmetic) mechplayer.HeatLevel += amt*MWHEAT_MOD;
	}
	void SetConstDamage(double newdamage)
	{
		truedamage = newdamage;
	}
	void _SetBaseDamage()
	{
		basedamage = !truedamage ? GetMissileDamage(0,1) : truedamage;
	}
	void setHeat(double val)
	{
		heatgen=val;
	}
	
	void ExplodeEx(double pow, double dist, bool damagemechs=false)
	{
		let it = ThinkerIterator.Create("Actor");
		Actor act;
		while(act = Actor(it.Next()))
		{
			double todist = Distance3DSquared(act);
			double dmgfalloff = pow * (1. - (1./(todist - (dist*dist))));
			if(todist > dist*dist) continue; 
			if( (act is "Mechwarrior" || act is "MechHitbox") && !damagemechs) continue;
			act.DamageMobJ(self, mechplayer, dmgfalloff, "Explosive", 0, angle); 
		}
	}
}

class Mechbase_Weapon : Item_NoPickup
{
	Mechwarrior mechplr;
	string shopdesc;
	int cooldown_timer;
	double volleycooldown;
	double cooldown;
	int group;
	int WeaponID;
	MechHardpoint hardpoint;
	bool dofire;
	bool isHomming;
	int volley_amt;
	int volley_inital;
	double volley_xspread;
	double volley_yspread;
	bool volley_cosmetic;
	int hardslots;
	double weight;
	Name displayName;
	int weapDistance;
	int weapSpeed;
	int worth;
	int ammouse;
	int ammogive;
	double hitscan_dmg;
	double hitscan_distance;
	double basespreadx, basespready;
	string specprefix; // Special prefix for certain weapons.
	//double hitscan_amt;
	int delay;
	Sound atksnd, DOS_atksnd;
	
	int ammo_mode;
	int switch_timer; // Retarded solution but idgaf anymore.
	string weapname2;
	string weapname3;
	class<Mechbase_Actor> weapType;
	class<Mechbase_Actor> weapType2;
	class<Mechbase_Actor> weapType3;
	class<Mechbase_Ammo> ammotype;
	class<Mechbase_Ammo> ammotype2;
	class<Mechbase_Ammo> ammotype3;
	
	Property DisplayName : displayName;
	Property DefaultGroup : group;
	Property WeaponType : weapType;
	Property Hitscan : hitscan_dmg, hitscan_distance;
	Property AmmoType : ammotype;
	Property AmmoGive : ammogive;
	Property AmmoUse : ammouse;
	Property CValue : worth;
	Property IsHommingMissile : isHomming;
	Property WeaponDelay : delay;
	Property AttackSound : atksnd;
	Property ClassicAttackSound : DOS_atksnd;
	Property Distance_Speed : weapDistance, weapSpeed;
	Property HardslotSize : hardslots;
	Property Tonnage : weight;
	Property Cooldown : cooldown, volleycooldown;
	Property WeaponBaseSpread : basespreadx, basespready;
	Property WeaponMode2 : weapType2, ammotype2, weapname2;
	Property WeaponMode3 : weapType3, ammotype3, weapname3;
	Property FlavorText : shopdesc;
	
	// Hardpoint processing
	int dmg_taken;
	bool broken;
	
	Default
	{
		Mechbase_Weapon.DisplayName "Base Weapon";
		Mechbase_Weapon.DefaultGroup 1;
		Mechbase_Weapon.Distance_Speed 30, 69;
		Mechbase_Weapon.Tonnage 1;
		Mechbase_Weapon.HardslotSize 1;
		Mechbase_Weapon.WeaponBaseSpread 5, 5;
		Inventory.maxamount 12; // Each weapon should have atleast 12 available slots.
	}
	
	action bool checkCooldown()
	{
		return (invoker.cooldown_timer == 0);
	}

	action bool CheckClassicSounds() 
	{
		if(!invoker.mechplr) return false;	
		PlayerInfo controlplr = players[consoleplayer];
		if(invoker.mechplr.player) controlplr = invoker.mechplr.player;
		return CVar.GetCVar("mwd_useclassicsound", controlplr).GetBool();
	}

	action bool FireBullets(int damage,int distance=0,int sxoff=1, int syoff=1)
	{
		if(!checkCooldown()) return false;
		let plr = MechWarrior(invoker.Owner);
		if(invoker.ammouse > 0)
		{
			if(plr.countammo(invoker.ammotype) < invoker.ammouse) return false;
			plr.TakeAmmo(invoker.ammotype,invoker.ammouse);
		}
		if(plr)
		{
			SoundOnActor.Trigger(invoker.atksnd, plr);
			plr.LineAttack(plr.angle,distance,plr.pitch,damage,"Ballistic","BulletPuff");
		}
		invoker.cooldown_timer = invoker.delay;
		return true;
	}
	action bool FireVolley(int amt=0, double xspread=2, double yspread=2, Sound volleysnd="", Sound clsvolleysnd="", bool extra_cosmetic=false)
	{
		if(!invoker.dofire && checkCooldown())
		{
			let plr = MechWarrior(invoker.Owner);
			if(!plr) return false;
			if(invoker.ammouse > 0 && plr.countammo(invoker.ammotype) < invoker.ammouse) return false;
			SoundOnActor.Trigger(CheckClassicSounds() ? clsvolleysnd : volleysnd, plr);
			invoker.dofire = true;
			invoker.volley_amt = amt;
			invoker.volley_inital = amt;
			invoker.volley_cosmetic = extra_cosmetic;
			invoker.volley_xspread = xspread;
			invoker.volley_yspread = yspread;
		}
		else if(invoker.volley_amt > 0)
		{
			double rxoff = frandom(-64,64)*invoker.volley_xspread;
			double ryoff = frandom(-64,64)*invoker.volley_yspread;
			
			// Extra_Cosmetic will make only the first object fired deal damage/generate heat.
			bool cosmetic = invoker.volley_cosmetic ? (invoker.volley_amt < invoker.volley_inital) : false;
			if(FireWeapon(invoker.weapType,invoker.hardpoint.pos.x+rxoff,
						  invoker.hardpoint.pos.y+ryoff,invoker.weapDistance,invoker.weapSpeed,false,cosmetic))
			{
				invoker.volley_amt--;
				invoker.cooldown_timer = invoker.volleycooldown*35.0;
			}
		}
		if(invoker.volley_amt <= 0 && invoker.dofire)
		{
			invoker.dofire = false;
			invoker.cooldown_timer = invoker.cooldown*35.0;
			invoker.MWPostFire();
			return false;
		}
		return !checkCooldown() ? false : true;
	}
	action bool FireWeapon(class<Mechbase_Actor> type, int xoffset, int yoffset, int distance, int spd, bool instant=false, bool cosmetic=false)
	{	
		if(checkCooldown() || instant)
		{
			let plr = MechWarrior(invoker.Owner);
			if(!plr) return false;
			if(invoker.ammouse > 0)
			{
				if(plr.countammo(invoker.ammotype) < invoker.ammouse) return false;
				plr.TakeAmmo(invoker.ammotype,invoker.ammouse);
			}
			
			// Legacy Sound
			Sound finalsnd = invoker.atksnd;
			if(invoker.DOS_atksnd && CVar.GetCVar("mwd_useclassicsound", plr.player).getBool()) 
				finalsnd = invoker.DOS_atksnd;
			if(finalsnd) SoundOnActor.Trigger(finalsnd, plr);
			
			// Get shoot position and offsets
			xoffset += random(-invoker.basespreadx,invoker.basespreadx);
			yoffset += random(-invoker.basespready,invoker.basespready);
			let weapdefs = GetDefaultByType(type);
			if(MechMissile(weapdefs)) yoffset = clamp(yoffset, weapdefs.height, int.max);
			let mechparts = plr.models_reference;
			double offsangle = plr.angle;
			double offspitch = plr.pitch;
			Array<FoundStruct> tmp;
			bool onarms = ( invoker.hardpoint == plr.hardpoints.la && plr.FindStructs("StructActuator", plr.hardpoints.la, true, tmp) ) || 
						  ( invoker.hardpoint == plr.hardpoints.ra && plr.FindStructs("StructActuator", plr.hardpoints.ra, true, tmp) );
			bool onlegs = ( invoker.hardpoint == plr.hardpoints.ll || invoker.hardpoint == plr.hardpoints.rl);
			
			// If we've got a cockpit model, always default align to the camera.
			if(mechparts && mechparts.cockpit && mechparts.cockpit.cockpitcam)
				offsangle = mechparts.cockpit.cockpitcam.angle;
			
			// If this weapon is NOT on an actuated arm, fire from torso aim.
			bool notorsoaim = plr.player ? CVar.GetCVar("mwd_universalactuation", plr.player).getBool() : true;
			
			// Align to cockpit model's rotation.
			if(!onarms && !notorsoaim && mechparts.cockpit) 
				offsangle = mechparts.cockpit.angle;
			if(onlegs) 
				offsangle = plr.LegAng;
			
			// AI has no real cockpit control.
			if(!plr.player && !onlegs) offsangle = plr.angle;
			
			vector2 offs = MDMath.VOffset(offsangle, distance, xoffset, 1);			
			
			double heightmod = plr.player ? plr.viewheight*plr.player.CrouchFactor : plr.viewheight;
			Vector3 lpos = plr.Vec3Offset(offs.x,offs.y,heightmod+yoffset);
			
			let weap = Mechbase_Actor(Spawn(type,lpos));
			if(weap)
			{
				plr.A_AlertMonsters(1024);
				invoker.cooldown_timer = invoker.cooldown*35.0;
				weap.target = invoker.Owner;
				weap.mechplayer = MechWarrior(invoker.Owner);
				weap.pitch = offspitch;
				weap.angle = offsangle;
				weap.speed = spd;
				weap.vel = (
						cos(offsangle)*cos(-offspitch),
						sin(offsangle)*cos(-offspitch),
						-sin(offspitch)
						) * spd;
				weap.cosmetic = cosmetic;
				return true;
			}
		}
		if(!invoker.volley_amt) invoker.MWPostFire();
		return false;
	}
	
	int CheckAllAmmo()
	{
		int total = 0;
		if(ammotype ) total += mechplr.countammo(ammotype);
		if(ammotype2) total += mechplr.countammo(ammotype2);
		if(ammotype3) total += mechplr.countammo(ammotype3);
		return total;
	}
	
	virtual int DoAmmoSwitch(int amindex)
	{
		ammotype = NULL;
		ammo_mode = amindex-1;
		int totalammo = CheckAllAmmo();
		if(!totalammo) ammo_mode = -1;
		while(!ammotype || !mechplr.countammo(ammotype))
		{
			ammo_mode++;
			switch(ammo_mode)
			{
				case 0:
					weapType = default.weapType;
					ammotype = default.ammotype;
					displayName = default.displayName;
				break;
				case 1:
					weapType = weapType2;
					ammotype = ammotype2;
					displayName = weapname2;
				break;
				case 2:
					weapType = weapType3;
					ammotype = ammotype3;
					displayName = weapname3;
				break;
				default:
					ammotype = NULL;
					ammo_mode = -1;
				break;
			}
			if(!totalammo) break;
		}
		return ammo_mode;
	}
	
	void weapon_tick()
	{
		let plr = MechWarrior(Owner);
		if(!plr) return;
		mechplr = plr;
		if(switch_timer) switch_timer --;
		
		if(  ammotype && !mechplr.countammo(ammotype) && 
		    (ammotype2 || ammotype3) ) DoAmmoSwitch(ammo_mode+1);
		
		if( (!ammotype && ammouse) || (mechplr.getSelectedWeapon() is self.GetClass() && 
		    mechplr.btn_switchammo && (ammotype2 || ammotype3)) && !switch_timer ) 
		{
			switch_timer = 35/2;
			DoAmmoSwitch(ammo_mode+1);
			plr.A_StartLocalSound("Mech/NextWeapon",CHAN_WEAPON);
		}
		
		if(cooldown_timer > 0)cooldown_timer--;
		if(dofire)FireVolley();
	}
	
	override void PostBeginPlay()
	{
		cooldown_timer = 0;
		dofire = false;
		super.PostBeginPlay();
	}
	
	override void tick()
	{
		weapon_tick();
		super.tick();
	}

	virtual void MWPostFire() {}
	virtual bool MWFire()
	{
		let plr = MechwarriorBase(Owner);
		if(!plr) return false;
		
		int curammo = 0;
		bool ret;
		if(ammotype) curammo = plr.countammo(ammotype);
		if(weapType)
		{
			ret = FireWeapon(weapType,hardpoint.pos.x,hardpoint.pos.y,weapDistance,weapSpeed);
		}
		else
		{
			ret = FireBullets(hitscan_dmg,hitscan_distance);
		}
		if(curammo > 0)
		{
			if(plr.countammo(ammotype) <= 0)
			{
				// If you want to make a betty skin, this is just another option.
				plr.mechsounds.pushSound("Mech/Betty/NoAmmo");
			}
		}
		return ret;
	}
}


// Missiles
class MechMissile : Mechbase_Actor
{
	double realdamage;
	bool homming;
	bool inrange;
	vector2 homspread;
	double arc;
	double explosionscale;
	
	Property Homming : homming, arc;
	Property ExplosionScale : explosionscale;
	
	Default
	{	
		Radius 6;
		Height 2;
		Projectile;
		MechMissile.ExplosionScale 1.0;
	}
	
	override void PostBeginPlay()
	{
		BaseInit();
		if(mechplayer && mechplayer.targetlocked) tracer = mechplayer.targetenemy;
		if(homming)
		{
			homspread = (frandom(-25,25),frandom(-25,25));
		}
		if(minimum_range > 0) 
		{
			inrange = false;
			SetConstDamage(0);
			realdamage = 0; 
		}
		else
		{
			inrange = true;
		}
		Spawn("MissileLight", pos);
		super.PostBeginPlay();
	}
	
	override void tick()
	{
		double distance = getTravelDistance();
		if(inrange)
		{
			realdamage = basedamage * (1.0-(distance/maximum_range));
			realdamage = clamp(realdamage,0,basedamage);
			SetConstDamage(realdamage);
			if(distance > maximum_range) inrange = false;
		}
		else if( distance >= minimum_range && distance < maximum_range )
		{
			inrange = true; 
			SetConstDamage(basedamage); 
		}
		
		Spawn("MissileLight", Vec3Offset(cos(angle)*-10,sin(angle)*-10,0));
		super.tick();
	}
	
	double fDist()
	{
		return abs((pos - tracer.pos).Length() / MWGAMEPLAY_UNITMETER);
	}
	
	  States
	  {
		  Spawn:
			MISS A 1 NoDelay Bright
			{
				if(arc > 0 && tracer && (!CheckSight(tracer) || fDist() > 180)) 
				{
					A_SetPitch(pitch-arc);
					vel = (
						cos(angle)*cos(pitch),
						sin(angle)*cos(pitch),
						-sin(pitch)
					) * speed;
				}
			}
			MISS B 1 Bright;
		  Spawn.Loop:
			MISS AB 1 Bright 
			{
				if(tracer && CheckSight(tracer) && fDist() > 16 && getTravelDistance() < maximum_range) 
					return ResolveState("Seek");
				else
					return ResolveState(Null);
			}
			// Not seeking.
			TNT1 A 0 
			{
				A_SetPitch(pitch + 1.2*(getTravelDistance()/maximum_range), SPF_INTERPOLATE);
				vel = (
					cos(angle)*cos(pitch),
					sin(angle)*cos(pitch),
					-sin(pitch)
				) * speed;
			}
		  Loop;
		  Seek:
			MISS ABAB 1 Bright 
			{
				if(homming && tracer) 
				{
					vector3 corrected_pos = (tracer.pos.x, tracer.pos.y, tracer.pos.z+(tracer.height/2));
					// A_SetPitch(getPitchTo(corrected_pos)+arc, SPF_INTERPOLATE);
					vector3 sight = level.SphericalCoords( pos, 
						tracer.Vec3Offset(homspread.x,homspread.y,tracer.height/2), 
						(angle, pitch)
					); 
					double hspd = clamp(90/(sight.z/MWGAMEPLAY_UNITMETER), 0.25, 1.0);
					if(sight.z > 32 && sight.x < 60)
					{
						A_SetAngle(MDMath.Lerp(angle, angle-sight.x, hspd), SPF_INTERPOLATE);
						A_SetPitch(MDMath.Lerp(pitch, pitch-sight.y, hspd), SPF_INTERPOLATE);
					}
					vel = (
						cos(angle)*cos(pitch),
						sin(angle)*cos(pitch),
						-sin(pitch)
					) * speed;
					//A_SeekerMissile(20,20,SMF_CURSPEED|SMF_PRECISE,0,maximum_range/64);
				}
			}
		  goto Spawn.Loop;
		  Death:
			TNT1 A 2 Bright 
			{ 
				if(inrange) 
				{
					ExplodeEx(basedamage*2,128,0); 
					let expl = Spawn("MissileExplosion",pos);
					if(expl) expl.A_SetScale(explosionscale,explosionscale);
				}
				else
				{
					let misl = Spawn("MissileDebris", pos);
					misl.Scale.x = Scale.x;
					misl.Scale.y = Scale.y;
					misl.angle = angle;
				}
			}
			Stop;
	  }
}
class MissileLight : Actor
{
	Default
	{
		+NOINTERACTION;
	}
	States
	{
		Spawn:
			TNT1 A 1;
		stop;
	}
}


// Lasers
class Laser : Mechbase_Actor
{
	Color gfx_color;
	double realdamage;
	Property FXColor : gfx_color;
	
	Default
	{
		Height 1;
		Radius 1;
		+NOGRAVITY;
		Alpha 1.0;
		RenderStyle "Add";
		Decal "DoomImpScorch";
		+PUFFGETSOWNER
		Laser.FXColor "FF FF FF";
		Mechbase_Actor.Heat 1;
		Speed 0.1;
		Projectile;
	}

	override void tick()
	{
		if(!basedamage) BaseInit();
		realdamage = basedamage * (1.0-(getTravelDistance()/maximum_range));
		realdamage = clamp(realdamage,0,basedamage);
		SetConstDamage(floor(realdamage));
		super.tick();
	}

	States
	{
		Spawn:
			LASR A 1;
		loop;
		Death:
			LASR A 1;
			LASR A 1
			{
				// console.printf("Damage: %d", floor(realdamage) );
				for(int i = 0; i < 30; i++)
				{
					A_SpawnParticle(gfx_color,SPF_FULLBRIGHT | SPF_RELATIVE,16,2,
					random(-45,45),random(-30,30),0,random(-30,30),0,3,0.5,0);
				}
				A_StartSound("Laser/Impact",CHAN_BODY);
			}
		stop;
	}
}

class PPCExplosion : Actor
{
	Default
	{
		+NOGRAVITY
		+NOBLOCKMAP
		+NOINTERACTION
		XScale 0.8;
		YScale 0.8;
	}
	

	States
	{
		Spawn:
			// PPC Impacts sound really good without attenuation.
			TNT1 A 0 NoDelay S_StartSound("Classic/PPC/Impact", CHAN_BODY);
			PEXP OPABCDEFGHIJKLMN 2;
		stop;
	}
}

class MissileExplosion : Actor
{
	Default
	{
		+NOGRAVITY
		+NOBLOCKMAP
		+NOINTERACTION
		XScale 1.6;
		YScale 1.6;
	}

	States
	{
		Spawn:
			EXPL A 2 NoDelay
			{
				A_StartSound("Missiles/Explosion", CHAN_BODY);
				let deb = Debris_Spawner(Spawn("Debris_Spawner",pos));
				if(deb)
				{
					deb.scale = 0.37;
					deb.spread = 5;
					deb.pieces = 6;
					deb.angle = angle;
					deb.pitch = pitch;
					deb.SetDamage(0);
				}
			}
			EXPL BCDEFGHIJKLMNOP 2;
		stop;
	}
}

class RandomExplosions : MissileExplosion
{
	int expl_count;
	int wait;
	double zoffs;
	vector3 spawnpos;
	double timer;
	Actor owner;
		
	static RandomExplosions TriggerOnActor(Actor onactor, int amt, int tics, double zoffset)
	{
		let rexpl = RandomExplosions(Spawn("RandomExplosions",onactor.pos));
		if(rexpl)
		{
			rexpl.spawnpos = onactor.pos;
			rexpl.owner = onactor;
			rexpl.expl_count = amt;
			rexpl.wait = tics;
			rexpl.zoffs = zoffset;
		}
		return rexpl;
	}
	
	static RandomExplosions Trigger(vector3 pos, int amt, int tics, double zoffset)
	{
		let rexpl = RandomExplosions(Spawn("RandomExplosions",pos));
		if(rexpl)
		{
			rexpl.spawnpos = pos;
			rexpl.expl_count = amt;
			rexpl.wait = tics;
			rexpl.zoffs = zoffset;
		}
		return rexpl;
	}
	
	void Halt()
	{
		expl_count = 0;
	}
	
	void DoExplosion()
	{
		vector3 truepos = owner ? owner.pos : spawnpos;
		let expl = Spawn("MissileExplosion", truepos);
		if(expl)
		{
			double angle = frandom(-180,180);
			double dist = frandom(-50,50);
			vector3 npos = expl.pos;
			npos.x += cos(angle)*dist;
			npos.y += sin(angle)*dist;
			npos.z += zoffs+frandom(-15,15);
			expl.SetOrigin(npos,false);
			double scalemod = frandom(0.5,1.5);
			expl.A_SetScale(scalemod,scalemod);
			expl.bSPRITEFLIP = random(0,1);
		}
	}
	
	override void Tick()
	{
		if(!timer && expl_count > 0) 
		{
			timer = wait+random(wait*0.5,wait);
			DoExplosion();
			expl_count--;
		}
		else
		{
			timer--;
		}
		super.Tick();
	}
	
	States
	{
		Spawn:
			TNT1 A 1;
			TNT1 A 0 A_JumpIf(expl_count, "Spawn");
		Death:
			TNT1 A 1;
		stop;
	}
}

class AMS_Missile : Mechbase_Actor
{
	int projdmg;
	double convergefactor;
	property Effectiveness : projdmg;
	property Efficiency : convergefactor;
	
	
	Default
	{
		Projectile;
		+SEEKERMISSILE
		-NOBLOCKMAP
		Height 2;
		Radius 2;
		Speed 9;
		Scale 0.15;
		AMS_Missile.Effectiveness 12;
		AMS_Missile.Efficiency 0.5;
	}
	
	override void PostBeginPlay()
	{
		speed *= convergefactor;
		Spawn("MissileLight", pos);
		super.PostBeginPlay();
	}
	
	
	States
	{
	  Spawn:
		AMSL A 4;
	  SpawnLoop:
		AMSL A 1 Bright
		{
			let mechwp = Mechbase_Weapon(tracer);
			if(tracer)
			{
				angle = AngleTo(tracer);
				pitch = MDMath.GetPitchBetween(pos,tracer.pos);
				
				if(Distance3D(tracer) <= radius*4) 
				{
					if(!mechwp)
					{
						if(tracer.damage <= 0) 
						{
							tracer.ExplodeMissile(null, tracer.target);
							return ResolveState(Null);
						}
						
						tracer.SetDamage(tracer.damage-projdmg);
						return ResolveState("DeathCollide");
					}
					else 
					{
						tracer.SetState(tracer.FindState("Death"));
						tracer.ExplodeMissile(null, tracer.target);
						return ResolveState("DeathCollide");			
					}
				}
				A_SeekerMissile(20,20,SMF_CURSPEED,999/64);
			}
			else
			{
				return ResolveState("Death");
			}
			return ResolveState(Null);
		}
		Loop;
	  DeathCollide:
		TNT1 A 1 
		{	
			let exp = MissileExplosion(Spawn("MissileExplosion",pos));
			if(exp)
			{
				exp.A_SetScale(0.3,0.3);
			}
		}
		Death:
			TNT1 A 1;
		Stop;
	}
}

class PPCBall : Mechbase_Actor
{	
	Default
	{
		Height 3;
		Radius 3;
		Damage 0;
		Speed 1;
		Alpha 0.25;
		RenderStyle "Add";
		DamageType "Lightning";
		+PUFFGETSOWNER
		XScale 0.25;
		YScale 0.2;
		Projectile;
	}

	override void BeginPlay()
	{
		if(!basedamage) BaseInit();
		super.BeginPlay();
	}

	override int SpecialMissileHit(Actor victim)
	{
		if(!(victim is "MechHitbox") && !(victim is "Mechwarrior"))
		{
			A_Explode(128,256);
		}
		return super.SpecialMissileHit(victim);
	}

	override void tick()
	{
		Converge();
		if(minimum_range > 0)
		{
			if( getTravelDistance() >= minimum_range ) 
			{
				A_SetRenderStyle(1.0,STYLE_NORMAL);
				SetConstDamage(basedamage);
			}
			else
			{
				SetConstDamage(0);
			}
		}
		else 
		{
			A_SetRenderStyle(1.0,STYLE_NORMAL);
		}
		super.tick();
	}

	States
	{
		Spawn:
			MPPC A 1 Spawn("PPCLight", pos);
		loop;
		
		Death:
			MPPC A 1;
			TNT1 A 5 
			{
				// /A_Explode();
				Spawn("PPCExplosion",pos);
			}
			TNT1 A 0 
			{
				if(truedamage) 
				{
					vector3 spos = pos;
					spos.x += frandom(-8,8);
					spos.y += frandom(-8,8);
					let expl = Spawn("MissileExplosion",spos);
					expl.Scale.x = frandom(0.6,1.3);
					expl.Scale.y = frandom(0.6,1.3);
				}
			}
			stop;
	}
}
class PPCLight : AutocannonLight {}

class Flame : Mechbase_Actor
{
	Default
	{
		Speed 10;
		DamageType "Fire";
		RenderStyle "Add";
		Alpha 1.0;
		XScale 0.45;
		YScale 0.45;
		Gravity 1.6;
		Projectile;
	}
	override int SpecialMissileHit(Actor victim)
	{
		let mhit = MechHitBox(victim);
		if(mhit && mhit.mech && mhit.mech != mechplayer)
		{
			Mechwarrior(mhit.mech).heatlevel += (heatgen*MWHEAT_MOD)*1.5;
		}
		return super.SpecialMissileHit(victim);
	}
	
	States
	{
		Spawn:
			FIO1 BCDEFGHIJKLMN 1
			{
				vel.z -= Gravity;
			}
		stop;
		 
		Death:
			FIO2 A 2 A_FadeOut(0.1);
		stop;
	}
}

class GaussBall : Mechbase_Actor
{
	Default
	{
		Speed 30;
		Projectile;
	}
	
	States
	{
		Spawn:
			GAUS A 1;
		loop;
		
		Death:
			GAUS A 1;
			GAUS A 1 
			{
				let deb = Debris_Spawner(Spawn("Debris_Spawner",pos));
				if(deb)
				{
					deb.debris_type = "Gauss_Debris";
					deb.spread = 8;
					deb.pieces = 20;
					deb.angle = angle;
					deb.pitch = pitch;
					deb.SetDamage(0);
				}
			}
		stop;
	}
}

class AutocannonBall : Mechbase_Actor
{
	bool isCluster;
	int clusterAmt;
	Property ClusterMode : isCluster, clusterAmt;

	Default
	{
		Speed 80;
		Radius 10;
		Height 5;
		Projectile;
		AutocannonBall.ClusterMode false, 0;
		Mechbase_Actor.Gravity 1.0;
	}

	States
	{
		Spawn:
			AUTO A 1 NoDelay Spawn("AutocannonLight", pos);
		SpawnLoop:
			AUTO A 1;
		loop;
		
		Death:
			AUTO A 1;
			AUTO A 1 
			{
				let deb = Debris_Spawner(Spawn("Debris_Spawner",pos));
				if(deb && isCluster)
				{
					deb.spread = 30;
					deb.pieces = clusterAmt;
					deb.angle = angle;
					deb.pitch = pitch;
					deb.SetDamage(truedamage);
				}
				else if(deb)
				{
					deb.spread = 3;
					deb.pieces = 4;
					deb.angle = angle;
					deb.pitch = pitch;
					deb.SetDamage(0);
				}
			}
		stop;
	}
}
class AutocannonLight : MissileLight 
{
	States
	{
		Spawn:
			TNT1 A 4;
		stop;
	}
}



class MechBullet : Mechbase_Actor
{
	Default
	{
		Damage 5;
		Height 1;
		Speed 150;
		Projectile;
	}
	
	override void tick()
	{
		if(!basedamage) BaseInit();
		if(maximum_range > 0)
		{
			if( getTravelDistance() >= maximum_range ) Destroy();
		}
		super.tick();
	}
	
	override void BeginPlay()
	{
		MachineGunFlash.Init(self);
		super.BeginPlay();
	}
	
	States
	{
		Spawn:
			AUTO A 1 NoDelay Spawn("AutocannonLight", pos);
		SpawnLoop:
			AUTO A 1;
		loop;
		
		Death:
			PUFF ABCD 2;
		stop;
	}
}
class MachineGunFlash : PPCExplosion
{
	Default
	{
		XScale 0.05;
		YScale 0.05;
		RenderStyle "Add";
		Alpha 1.0;
		+FLATSPRITE
	}
	
	static MachineGunFlash Init(Actor from)
	{
		let mflash = MachineGunFlash(Spawn("MachineGunFlash", from.pos));
		if(mflash) mflash.master = from;
		return mflash;
	}
	
	override void PostBeginPlay()
	{
		if(master)
		{
			angle = master.angle;
			pitch = master.pitch+90;
			A_SetRoll(random(0,359));
		}
		super.PostBeginPlay();
	}
	
	States
	{
		Spawn:
			MGMZ A 2 Bright;
		stop;
	}
}

// Targetting effects (Adaptation of Xasers rocket-lock from Argent)

class MechTargetCamera : Actor
{
	vector3 offset;
	double fdist;
	
	Default
	{
		+NOINTERACTION
	}

	static MechTargetCamera Create(Actor reticle, Actor obj, vector3 offs, double fdist=2)
	{
		let cam = MechTargetCamera(Spawn("MechTargetCamera",(0,0,0)));
		cam.tracer = obj;
		cam.offset = offs;
		cam.master = reticle;
		cam.fdist = fdist;
		
		return cam;
	}

	States
	{
		Spawn:
			TNT1 A 1
			{
				if(tracer && tracer.health > 0)
				{
				    A_Warp(AAPTR_TRACER, fdist, offset.x, offset.y + tracer.height/2, 0, 
						WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE, null, 0, 1.5);
					angle = tracer.angle-180;
				} else { return ResolveState("Death"); }
				
				return ResolveState(Null);
			}
		loop;
		
		Death:
			TNT1 A 1;
		stop;
	}
}

class MechTargetReticle : Actor
{
	Vector2 offset;
	Vector2 dest_offset;
	MechTargetCamera cam;
	
	Array<MechTargetReticle> corners;

	Default
	{
		+NOINTERACTION
		//RenderStyle 'Add';
		Alpha 1.0;
		Scale 0.5;
	}

	override void tick()
	{
		// Move to destination offset
		if(dest_offset.x > offset.x) offset.x += 4;
		if(dest_offset.x < offset.x) offset.x -= 4;
		if(dest_offset.y > offset.y) offset.y += 4;
		if(dest_offset.y < offset.y) offset.y -= 4;
		if( abs(dest_offset.x-offset.x) < 2) offset.x = dest_offset.x;
		if( abs(dest_offset.y-offset.y) < 2) offset.y = dest_offset.y;
		
		super.tick();
	}

	States
	{
	Spawn:
		RETC A 0 Bright; // primer state. The frame gets changed on spawn.
		RETC "#" 1 Bright 
		{
			if(master && master.player && CVar.GetCVar("mwd_viewport_target",master.player).getBool())
			{
				sprite = GetSpriteIndex("TNT1");
			}
			RFollowTracer();
		}
		Wait;
	Death:
		RETC "#" 1;
		stop;
	}

	static MechTargetReticle InitCreate(Actor shooter, Actor victim, int size, double camdist)
	{
		if(shooter && victim) {
			
			let masterReticle        = MechTargetReticle.RSpawn(shooter, victim, (-size -victim.radius/2,       victim.height/2), 1);
			masterReticle.corners.Push(MechTargetReticle.RSpawn(shooter, victim, ( size +victim.radius/2,       victim.height/2), 0));
			masterReticle.corners.Push(MechTargetReticle.RSpawn(shooter, victim, (-size -victim.radius/2, size -victim.height/2), 3));
			masterReticle.corners.Push(MechTargetReticle.RSpawn(shooter, victim, ( size +victim.radius/2, size -victim.height/2), 2));
			masterReticle.cam = MechTargetCamera.Create(masterReticle,victim,(0,0,0),camdist);
			return masterReticle;
		}
		return null;
	}

	static MechTargetReticle RSpawn(Actor shooter, Actor victim, Vector2 destoff, int frame)
	{
		if(shooter && victim) {
			Vector2 rotpos = RotateVector((0, 1), shooter.AngleTo(victim));
			let newReticle = MechTargetReticle(Spawn('MechTargetReticle', victim.pos + (rotpos.x, rotpos.y, victim.height/2)));
			if(newReticle) {
				newReticle.master = shooter;
				newReticle.tracer = victim;
				newReticle.dest_offset = destoff;
				newReticle.frame  = frame;
			}
			return newReticle;
		}
		return null;
	}

	void RDeconstruct(bool alsoDie = true)
	{
		// [XA: Argent]
		// Remove thyself and minions.
		let plr = MechWarrior(master);
		// We check cam to make sure we're the master, otherwise we get 3 betty announcements.
		if(plr && cam && tracer && tracer.health <= 0)
		{
			plr.mechsounds.pushSound("Mech/Betty/TargetEliminated");
		}	
		for(int i = 0; i < corners.Size(); i++) {
			if(corners[i]) {
				corners[i].RDeconstruct(alsoDie);
			}
		}
		if(alsoDie) {
			SetStateLabel('Death');
		}
	}

	state RFollowTracer()
	{
		// [XA: Argent]
		// Keep the reticle indicator on target. Also check if the target still
		// exists; if they prematurely die or are removed, trigger fade-out.
		if(tracer && tracer.health > 0 && master) 
		{
			A_Warp(AAPTR_TRACER, 2, offset.x, offset.y + tracer.height/2, tracer.AngleTo(master), WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_ABSOLUTEANGLE);
			return null;
		}
		else 
		{ 
			RDeconstruct(false);
			return ResolveState('Death');
		} 
	}
}





