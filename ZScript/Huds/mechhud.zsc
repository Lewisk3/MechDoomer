
struct FadingText
{
	String txt;
	float alpha;
	int col;
}

class MechStatusBar : BaseStatusBar
{
	HUDFont mHUDFont;
	Actor prevtarg;
	float hud_alpha;
	int tAlign;
	TextureID compass;
	bool invalid;
	float compassoffs;
	float compassdir;
	int hpcounter;
	int scrwidth;
	int scrheight;
	bool inMenu;
	bool inHUDLoadout;
	Vector2 loadm_base;
	int loadm_selected;
	int loadm_invselected;
	int loadm_weapselected;
	int struc_invselected;
	int struc_weapselected;
	Mechbase_Weapon loadout_weapon;
	bool infomode;
	int internalcash;
	int cashcounter;
	String loadout_invweapon;
	int invoffset;
	FadingText dCash;
	vector2 font_scale;
	
	// Scalar constant
	float defwidth;
	float defheight;
	float hud_xoffs;
	float hud_yoffs;
	
	Font fnt;
	
	
	// All H_ function auto adjust to the screen resolution based on 1080p coords.	
	void H_DrawImage(String img, vector2 pos, uint flags=0, vector2 scale=(1,1), float alpha=-1, Color tint=Color(0,0,0,0))
	{
		alpha = (alpha < 0) ? hud_alpha : alpha;
		MD_SBS.DrawImage(img,pos,flags,alpha,scale,tint);
	}
	
	void H_DrawTexture(TextureID texture, Vector2 pos, int flags = 0, Vector2 scale = (1, 1))
	{
		MD_SBS.DrawTexture(texture,pos,flags,1.0,scale);
	}
	
	void H_Fill(Color col, double x, double y, double w, double h, int flags = 0)
	{
		MD_SBS.Fill(col,x,y,w,h,flags);
	}
	
	void H_SetClipRect(int x, int y, int width, int height, bool visualize=false)
	{
		if(visualize) MD_SBS.Fill(Color(255,0,255,0), x,y,width,height );			
		MD_SBS.SetClipRect(x,y,width,height);
	}
	
	void H_DrawStringBigFont(String str, vector2 pos, uint flags = 0, int translation = Font.CR_UNTRANSLATED, float alpha=-1)
	{
		alpha = (alpha < 0) ? hud_alpha : alpha;
		MD_SBS.DrawString("dbigfont", str, pos, flags, translation, alpha, font_scale);
	}
	
	void H_DrawString(String str, vector2 pos, uint flags = 0, int translation = Font.CR_UNTRANSLATED, float alpha=-1)
	{
		alpha = (alpha < 0) ? hud_alpha : alpha;
		MD_SBS.DrawString(fnt,str,pos,flags,translation,alpha,font_scale);
	}

	void drawAngledLine(int x, int y, int distance, float angle, float fov, Color c)
	{
		MD_SBS.DrawLine(x-24,y-20,x+(cos(angle+fov)*(distance*1.1)),y-(sin(angle+fov)*(distance*0.9)),c);
	}
	
	vector2 H_AdjustCoord(vector2 coord)
	{
		return MD_SBS.GetRelativePos(coord);
	}
	
	////////////////////////////////////////////////////////////////////////////
	
	Color getHealthyColor(float ratio, float tintalpha=1.0)
	{
		if(ratio <= 0) return StatusColor.HSLtoRGB(0,1.0,0.0,1.0);
		return StatusColor.HSLtoRGB(0.28*(ratio-0.3),1.0,0.5, tintalpha);
	}
	
	float point_distance(Actor one, Actor two, float scale)
	{
		int x = one.pos.x - two.pos.x;
		int y = one.pos.y - two.pos.y;
		int z = one.pos.z - two.pos.z;
		return sqrt( x*x + y*y + z*z )/scale;
	}
	
	bool isTypeOfStruct(String type)
	{	
		class<Mechbase_Utility> util = type;
		return util;
	}

	override void Init()
	{
		Super.Init();
		defwidth = 1920;
		defheight = 1080;
		hud_xoffs = 800;
		hud_yoffs = 860;
		SetSize(0, 320, 200);
		font_scale = (0.5, 0.5);
		compassoffs = 0;
		compassdir = 1;
		hud_alpha = 1.0;
		compass = TexMan.CheckForTexture("MBEARING",TexMan.TYPE_ANY);
		tAlign = DI_TEXT_ALIGN_CENTER | DI_SCREEN_CENTER_BOTTOM;
		internalcash = -1; 
		
		// Create the font used for the fullscreen HUD
		fnt = "MechFont";
		mHUDFont = HUDFont.Create(fnt);
		
	}
	
	override void Tick()
	{	
		if(CPlayer && CPlayer.mo)
		{
			let mech = MechWarrior(CPlayer.mo);	
			if(!mech || mech && !mech.inv_context) 
			{
				super.tick();
				return;
			}
			if(cashcounter != mech.inv_context.money_cbills) 
			{
				int money = mech.inv_context.money_cbills - cashcounter;
				if(mech.inv_context.money_cbills < cashcounter)
				{ 
					cashcounter+= money/20; 
					dCash.txt = money.."";
					dCash.col = Font.CR_DARKRED;
					if(cashcounter < mech.inv_context.money_cbills) cashcounter = mech.inv_context.money_cbills;
					if(money/20 == 0) cashcounter = mech.inv_context.money_cbills;
				}
				if(mech.inv_context.money_cbills > cashcounter)
				{ 
					cashcounter+= money/20; 
					dCash.txt = "+" .. money;
					dCash.col = Font.CR_GREEN;
					if(cashcounter > mech.inv_context.money_cbills) cashcounter = mech.inv_context.money_cbills;
					if(money/20 == 0) cashcounter = mech.inv_context.money_cbills;
				}
				
			}
		}
	
		super.tick();
	}
	
	void drawWeapons(HUDFont fnt, vector2 pos, float scalex, float scaley)
	{
		int lastweap;
		if(CPlayer && CPlayer.mo)
		{
			let mech = MechWarrior(CPlayer.mo);		
			for(let weap = mech.Inv; weap != null; weap = weap.Inv)
			{
				let ww = Mechbase_Weapon(weap);
				if(ww)
				{
					int ftranslation = Font.CR_GREEN;
					static const int group_colors[] =
					{
						Font.CR_GREEN,
						Font.CR_WHITE,
						Font.CR_YELLOW,
						Font.CR_LIGHTBLUE
					};
					int grp = clamp(ww.group-1,0,3);
					ftranslation = group_colors[grp];
					if(ww.ammotype && ww.ammouse > mech.countammo(ww.ammotype))ftranslation = Font.CR_DARKRED;
					if( ww.cooldown_timer > 0 )ftranslation = Font.CR_DARKRED;
					int selx = (ww.WeaponID+1)%2;
					int sely = (ww.WeaponID+1)/2;
					if(ww.ammotype)
						H_DrawString(ww.displayName .. " " .. mech.countammo(ww.ammotype),(pos.x+(selx*scalex),pos.y+(sely*scaley)),0,ftranslation);
					if(!ww.ammotype)
						H_DrawString(ww.displayName,(pos.x+(selx*scalex),pos.y+(sely*scaley)),0,ftranslation);
					if(lastweap < ww.WeaponID) lastweap = ww.WeaponID;
				}
			}
			// Special exclusive weapon drawing for a struct!
			
			int amsid=1;
			for(int i = 0; i < mech.inv_context.mechstructs.Size(); i++)
			{
				String cname = mech.inv_context.mechstructs[i].Tag;
				cname.ToLower();
				if(cname == "antimissilesystem")
				{
					int ftranslation = Font.CR_SAPPHIRE;
					int nselx = (lastweap+1+amsid)%2;
					int nsely = (lastweap+1+amsid)/2;
					class<AntiMissileSystem> defams = "AntiMissileSystem";
					let ams_def = GetDefaultByType(defams);
					if(ams_def.ammotype && ams_def.ammouse > mech.countammo(ams_def.ammotype))ftranslation = Font.CR_DARKRED;
					if(mech.ams_timer > 0)ftranslation = Font.CR_DARKRED;
					string prefix = ams_def.displayName;
					if(ams_def.ammotype)
					{
						H_DrawString(prefix .. " " .. mech.countammo(ams_def.ammotype),(pos.x+(nselx*scalex),pos.y+(nsely*scaley)),0,ftranslation);
					}
					else
					{
						H_DrawString(prefix,(pos.x+(nselx*scalex),pos.y+(nsely*scaley)),0,ftranslation);
						amsid++;
					}
				}
			}
		}
	}
	
	bool checkWeaponBusy(int ind)
	{
		if(CPlayer && CPlayer.mo)
		{
			let mech = MechWarrior(CPlayer.mo);		
			for(let weap = mech.Inv; weap; weap = weap.Inv)
			{
				let ww = Mechbase_Weapon(weap);
				if(ww)
				{
					if(ww.WeaponID == ind)
					{
						return (ww.cooldown_timer > 0);
					}
				}
			}
		}
		return false;
	}

	override void Draw (int state, double TicFrac)
	{
		if(!automapactive) Super.Draw (state, TicFrac);
		
		if(inMenu)H_DrawString("HUD is in menu.",(100,-500));
		if(CPlayer && CPlayer.mo)
		{
			let mech = MechWarrior(CPlayer.mo);
			if(!mech) 
			{
				console.printf("Failed to display HUD, unsupported player class!");
				return;
			}
			else if(!mech.inv_context)
			{
				return;
			}
		}
		if (state == HUD_StatusBar)
		{
			//BeginStatusBar();
			//DrawFullScreenStuff (TicFrac);
		}
		else if (state == HUD_Fullscreen)
		{
			BeginHUD();
			DrawMainBar (TicFrac);
			if( 
				CVar.GetCVar("hud_scale",CPlayer).getInt() >  1 || 
			    CVar.GetCVar("uiscale",CPlayer).getInt()   != 1 || 
			   !CVar.GetCVar("hud_aspectscale",CPlayer).getBool()  )
			{
				invalid = true;
			}
		}
		if(invalid && !automapactive)
		{
			console.printf("- HUD is not being displayed properly -");
			console.printf(" Please do the following to fix it");
			console.printf(" Customize Controls -> MechDoomer Controls");
			console.printf(" Bind \"Fix HUD\" button.");
		}
	}
	
	int realAngle(float ang)
	{
		return acos(cos(ang));
	}
	
	void DrawBars()
	{
		if(CPlayer && CPlayer.mo) 
		{
			let mech = MechWarrior(CPlayer.mo);
			if(!mech) return;
			
			vector2 throttlepos = (707, 389);
			vector2 jetpos = (270, 350);
			vector2 heatpos = (-75, 350);
			vector2 deltapos = (230, 350);
			
			if(!mech.defaultmovement)
			{
				H_DrawString(int(mech.MoveSpeedKPH*mech.throttle) .. "Kph" ,(throttlepos.x-100,throttlepos.y+25),MD_SBS.SS_SCREEN_CENTER);
				H_DrawImage("Throttle",(throttlepos.x+13,throttlepos.y-39),MD_SBS.SS_SCREEN_CENTER);
				if(abs(mech.throttle) <= 0.01)
					H_Fill(Color(int(100*hud_alpha),0,255,0), throttlepos.x,throttlepos.y, 14, -3, MD_SBS.SS_SCREEN_CENTER);
				if(mech.throttle > 0)
				{
					H_Fill(Color(int(100*hud_alpha),0,255,0), throttlepos.x,throttlepos.y, 14, -(mech.throttle*150), MD_SBS.SS_SCREEN_CENTER);
				}
				else
				{
					H_Fill(Color(int(100*hud_alpha),0,0,255), throttlepos.x,throttlepos.y, 14, -(mech.throttle*140), MD_SBS.SS_SCREEN_CENTER);
				}
				
				// Torso angle
				if( !mech.pilotlook ) 
				{
					float angdiff = MDMath.NormalizeAngle(mech.angle-mech.LegAng);
					float angmax = angdiff/(mech.uncappedtorso ? 180 : mech.MaxYaw);
					H_Fill(Color(int(255*hud_alpha),0,255,0),960,45,-(angmax*185),10);
					if( abs(angdiff) <= 1)H_Fill(Color(int(255*hud_alpha),0,255,0),960,45,4,10);
				}
			}
			
			if(mech.Mech_HasJets) 
			{
				H_DrawString("Jets",(jetpos.x,jetpos.y+30),MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(int(100*hud_alpha),255,0,0),jetpos.x,jetpos.y,132,20,MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(int(100*hud_alpha),0,255,0),jetpos.x,jetpos.y,mech.mech_jetsfuel*1.32,20,MD_SBS.SS_SCREEN_CENTER);
			}
			H_DrawString("Heat",(heatpos.x-145,heatpos.y+30),MD_SBS.SS_SCREEN_CENTER);
			H_Fill(Color(int(255*hud_alpha),206,206,0),heatpos.x-147,heatpos.y,290,20, MD_SBS.SS_SCREEN_CENTER);
			double heatmid = MWHEAT_MAX*0.25;
			double sizemul = (200/MWHEAT_MAX)*3;
			if(mech.HeatLevel > heatmid)
			{
				float hmin = clamp(mech.HeatLevel-heatmid,0,heatmid);
				float hmax = clamp(-(mech.HeatLevel-heatmid),-heatmid,0);
				H_Fill(Color(int(255*hud_alpha),255,0,0),heatpos.x,heatpos.y,hmin*sizemul,20, MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(int(255*hud_alpha),255,0,0),heatpos.x,heatpos.y,hmax*sizemul,20, MD_SBS.SS_SCREEN_CENTER);
			}
			else
			{
				float hmin = clamp(mech.HeatLevel,0,heatmid);
				float hmax = clamp(-(mech.HeatLevel),-heatmid,0);
				H_Fill(Color(int(255*hud_alpha),2,30,216),heatpos.x,heatpos.y,143-(hmin)*sizemul,20, MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(int(255*hud_alpha),2,30,216),heatpos.x,heatpos.y,-(148+((hmax)*sizemul)),20, MD_SBS.SS_SCREEN_CENTER);
			}
			H_DrawString("dH/dT",(deltapos.x-127,deltapos.y+30),MD_SBS.SS_SCREEN_CENTER);
			H_Fill(Color(int(255*hud_alpha),206,206,0),deltapos.x-128,deltapos.y,125,20, MD_SBS.SS_SCREEN_CENTER);
			float hmax = clamp(-(mech.deltaHeat),-heatmid,0);
			H_Fill(Color(int(255*hud_alpha),2,30,216),deltapos.x,deltapos.y,-(130+((hmax)*sizemul)),20, MD_SBS.SS_SCREEN_CENTER);
			
		}
	}
	
	
	void Draw_Compass(float xoffs=0, float yoffs=0, float woffs=0)
	{
		if(!CPlayer || !CPlayer.mo) return;
		let mechplr = Mechwarrior(CPlayer.mo);
		if(!mechplr) return;
		if(!mechplr.defaultmovement)
		{
			H_DrawImage("MBEARMID",(960,74));
			if(mechplr.LegVel < 0) compassoffs += 0.79*abs(mechplr.LegVel);
			if(mechplr.LegVel > 0) compassoffs -= 0.79*abs(mechplr.LegVel);
			H_SetClipRect(780, 0, 360, 256);
			H_DrawTexture(compass, (1126+compassoffs, 90) );
			ClearClipRect();
			if(compassoffs > 239)compassoffs = -234;
			if(compassoffs < -239)compassoffs = 234;
		}
		
		vector2 offsetpos = (949+xoffs,118+yoffs);
		vector2 basepos   = (286+woffs,51);
		vector2 crectxy   = (basepos.x+(offsetpos.x/2)-(woffs*2), basepos.y+offsetpos.y-128);
		vector2 crectab   = (411+(woffs*2.3), 263);
		//offsetpos = H_AdjustCoord(offsetpos);
		//basepos   = H_AdjustCoord(basepos);
		//crectxy   = H_AdjustCoord(crectxy);
		//crectab   = H_AdjustCoord(crectab);
		
		float cang = mechplr.defaultmovement ? (mechplr.angle%360) : (mechplr.LegAng%360);
		float pang = cang-79;
		vector2 Npos = MDMath.VRotate(basepos,pang)+offsetpos;
		vector2 Spos = MDMath.VRotate(basepos,pang+180)+offsetpos;
		vector2 Epos = MDMath.VRotate(basepos,pang+90)+offsetpos;
		vector2 Wpos = MDMath.VRotate(basepos,pang-90)+offsetpos;
		
		H_SetClipRect(crectxy.x,crectxy.y, crectab.x,crectab.y);
		if(MDMath.inRange(cang,  90,89)) 
			H_DrawString("N",(Npos.x,offsetpos.y),0,Font.CR_GREEN);
		if(MDMath.inRange(cang, 270,89)) 
			H_DrawString("S",(Spos.x,offsetpos.y),0,Font.CR_GREEN);
		if(MDMath.inRange(cang,   0,89) ||
		  (MDMath.inRange(cang, 359,89) && 
		   MDMath.inRange(cang, 270,89)    ))
			H_DrawString("E",(Epos.x,offsetpos.y),0,Font.CR_GREEN);
		if(MDMath.inRange(cang, 180,89)) 
			H_DrawString("W",(Wpos.x,offsetpos.y),0,Font.CR_GREEN);
		Screen.ClearClipRect();
	}
	
	
	void Draw_Radar()
	{	
		if(CPlayer && CPlayer.mo)
		{
			float scale = 7;
			let mech = MechWarrior(CPlayer.mo);
			if(!mech) return;
			ThinkerIterator act_it = ThinkerIterator.Create("Actor");
			Actor obj;
						
			// Draw FOV bars (For some reason the xaxis needs to be divided by 2 to scale correctly.)
			float drawang = mech.defaultmovement ? 90 : mech.angle-mech.LegAng+90;
			drawAngledLine(257,220,165,drawang,mech.player.FOV/2,Color(int(255*hud_alpha),53,255,53));
			drawAngledLine(257,220,165,drawang,-mech.player.FOV/2,Color(int(255*hud_alpha),53,255,53));
	
			float radarx = 260;
			float radary = 200;
			H_DrawImage("MECRADAR",(radarx,radary),0,(1.1,0.9));
			
			while(obj = Actor(act_it.Next()))
			{			
				int x = mech.pos.x - obj.pos.x;
				int y = mech.pos.y - obj.pos.y;
				int dis = point_distance(obj,Actor(CPlayer.mo),scale);
				if( dis < 135 )
				{
					float frontangle = mech.angle+180;
					int dx = ( y * cos((frontangle) )) - ( x * sin((frontangle)) );
					int dy = ( y * sin((frontangle) )) + ( x * cos((frontangle)) );
					dx /= scale;
					dy /= scale;
					// If we're not the player and we're awake.
					let nmech = MechWarrior(obj);
					if( nmech != mech && obj.target != NULL)
					{
						if(obj.bSOLID && obj.bSHOOTABLE) H_DrawImage("ENEMYIND",(radarx-dx,radary-dy),0,(0.8,0.6));
						if(obj == mech.targetenemy) H_DrawString("+",(radarx-dx,radary-dy));
						
						//if(obj.bNOGRAVITY)DrawString(mHUDFont,"-",(dx-278,dy-200),tAlign,hud_alpha);
					}
				}
			}
		}
	}
	
	float GetHardpointVitalRatio(MechHardpoint hp)
	{
		float hp_vitals    = hp.armor+hp.internalhp;
		float hp_maxvitals = hp.max_armor+hp.max_internal;
		if(hp.internalhp <= 0) hp_vitals = 0;
		if(hp_vitals == 0) return 1.0;
		float vres = 1.0 - (hp_vitals / hp_maxvitals);
		if(vres < 0.1) vres = 0;
		return vres;
	}
	
	void DrawMainBar (double TicFrac)
	{
		if(CPlayer && CPlayer.mo)
		{		
			DrawKeys();
			let mech = MechWarrior(CPlayer.mo);
			if(!mech)return;	
			if(!mech.inv_context) return;
			
			invalid = false;
			
			if(!mech.modelcockpit) H_DrawImage(mech.hud_cockpit,(955,940+mech.boboffs),0,(3.2,2.0));
			if(mech.health <= 0) return;
			
			if(CVar.FindCVar("mwd_nohud").getBool()) return;
			
			H_DrawImage("CBILLS",(1740,405),0,(1.3,1));
			String cash = cashcounter .. "";
			H_DrawString(cash,(1755,395));
			
			if(dCash.txt != "" && dCash.alpha > 0) 
			{
				H_DrawString(dCash.txt,(1752,420),0,dCash.col,dCash.alpha);
				dCash.alpha -= 0.01;
			}
			if(dCash.txt != "" && dCash.alpha <= 0){ dCash.txt = ""; dCash.alpha = 1.0; }
			
			
			if(mech.mech_shutdown)return;
			Draw_Radar();
			Draw_Compass(0,-20,-20);
			H_DrawImage("MWTARGET",(200,836),0,(1.3,1.3));
			if(mech.targetenemy)
			{
				TexMan.SetCameraToTexture(Actor(mech.targetreticle.cam),"TargetCamera",90.0);
				TextureID targ = TexMan.CheckForTexture("TargetCamera",TexMan.TYPE_ANY);
				H_DrawTexture(targ,(199,834),0,(1.3,1.3));
				String dist = mech.Distance3D(mech.targetenemy)/5 .. "";
				dist.truncate(dist.Length()-6);
				H_DrawString("Type: " .. mech.targetenemy.getTag(),(86,960));
				H_DrawString("Distance: " .. dist .. "m",(86,980));
				// Enemy health bar
				float percenthealth = float(mech.targetenemy.SpawnHealth()-(mech.targetenemy.SpawnHealth()-hpcounter) ) / mech.targetenemy.SpawnHealth();
				if(mech.targetenemy.health < hpcounter)hpcounter -= (hpcounter-mech.targetenemy.health)*0.1;
				if(hpcounter == 0) hpcounter = mech.targetenemy.health;
				if(mech.targetenemy.health <= 0) hpcounter = 0;
				if(prevtarg != mech.targetenemy)
				{
					hpcounter = 0;
					prevtarg = mech.targetenemy;
				}
				H_Fill(Color(int(255*hud_alpha),0,0,0), 80, 920,
					242, 16, 0);
				H_Fill(Color(int(255*hud_alpha),0,173,0), 80, 920,
					percenthealth*242, 16, 0);
				String percenthp = percenthealth*100 .. "";
				percenthp.truncate(percenthp.Length()-6);
				H_DrawString(percenthp .. "%" ,(170,920));
			}
			drawWeapons(mHUDFont,(1370,55),220,50);
			
			// Draw armor/paperdoll

			
			float hd_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.hd);
			float ct_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.ct);
			float lt_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.lt);
			float rt_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.rt);
			float la_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.la);
			float ra_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.ra);
			float ll_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.rl);
			float rl_dmg = 1.0-GetHardpointVitalRatio(mech.inv_context.hardpoints.ll);
			
			//console.printf("%f :> %d",ct_dmg,mech.inv_context.hardpoints.ct.armor+mech.inv_context.hardpoints.ct.internalhp);
			
			int pd_flags = MD_SBS.SS_COORDS_TEXGRID | MD_SBS.SS_SCREEN_BOTTOM_RIGHT;
			String hudmech = mech.hud_mech.."A";
			Color hpcolor = getHealthyColor(1.0,0);
			vector2 hudmech_size = MD_SBS.GetImageSize(hudmech);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);

			vector2 clipoffset = (1428, 750);
			
			// CT -> clipoffset.x+hudmech_size.x/3, clipoffset.y, hudmech_size.x/7,hudmech_size.y/2
			// LT -> clipoffset.x+hudmech_size.x/4, clipoffset.y, hudmech_size.x/12,hudmech_size.y/2
			// RT -> clipoffset.x+hudmech_size.x/2.1, clipoffset.y, hudmech_size.x/13,hudmech_size.y/2
			// LA -> clipoffset.x, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3
			// RA -> clipoffset.x+hudmech_size.x/1.8, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3
			// LL -> clipoffset.x+hudmech_size.x/2, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2
			// RL -> clipoffset.x+hudmech_size.x/5.9, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2
			
			// CT
			hpcolor = getHealthyColor(ct_dmg,ct_dmg<1.0);
			H_SetClipRect(clipoffset.x+hudmech_size.x/3, clipoffset.y, hudmech_size.x/7,hudmech_size.y/2);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);
			ClearClipRect();
			// LT
			hpcolor = getHealthyColor(lt_dmg,lt_dmg<1.0);
			H_SetClipRect(clipoffset.x+hudmech_size.x/4, clipoffset.y, hudmech_size.x/12,hudmech_size.y/2);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);
			ClearClipRect();
			// RT
			hpcolor = getHealthyColor(rt_dmg,rt_dmg<1.0);
			H_SetClipRect(clipoffset.x+hudmech_size.x/2.1, clipoffset.y, hudmech_size.x/13,hudmech_size.y/2);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);
			ClearClipRect();
			// LA
			hpcolor = getHealthyColor(la_dmg,la_dmg<1.0);
			H_SetClipRect(clipoffset.x, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);
			ClearClipRect();
			// RA
			hpcolor = getHealthyColor(ra_dmg,ra_dmg<1.0);
			H_SetClipRect(clipoffset.x+hudmech_size.x/1.8, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);
			ClearClipRect();
			// LL
			hpcolor = getHealthyColor(ll_dmg,ll_dmg<1.0);
			H_SetClipRect(clipoffset.x+hudmech_size.x/2, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);
			ClearClipRect();
			// RL
			hpcolor = getHealthyColor(rl_dmg,rl_dmg<1.0);
			H_SetClipRect(clipoffset.x+hudmech_size.x/5.9, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2);
			H_DrawImage(hudmech,(-1.7,-1.0),pd_flags,tint:hpcolor);
			ClearClipRect();
			
		
			
			// Draw weapon indicator
			String weapind = "WEAPIND";
			int selx = (mech.selectedWeapon+1)%2;
			int sely = (mech.selectedWeapon+1)/2;
			vector2 weappos = ( 1450 + (selx*220), 64 + (sely*50) );
			if(checkWeaponBusy(mech.selectedWeapon)) weapind = "WEAPSEL";
			if(mech.selectedWeapon <= mech.inv_context.weapons_count)H_DrawImage(weapind,weappos,0,(0.8,0.6));
			
			// Draw speedometer.
			DrawBars();
			
			DrawObjectives();
			// Crosshair
			H_DrawImage (
				mech.crosshair_sprite,(0.5,0.5),
				MD_SBS.SS_COORDS_TEXGRID|MD_SBS.SS_SCREEN_CENTER,
				(1.35,1.25)
			);
		}
		//if(inHUDLoadout) drawLoadoutHUD();
	}

	void DrawObjectives()
	{
		string pstrs[4] = 
		{
			"Primary",
			"Secondary",
			"Tertiary",
			"Quaternary"
		};
		
		let mech = MechWarriorBase(CPlayer.mo); 
		if(!mech) return;
		if(!mech.display_objectives) return;
		vector2 objpos = (450,280);
		H_DrawString("MISSION OBJECTIVES",objpos,0,Font.CR_SAPPHIRE);
		
		int yoffs = 50;
		for(int i = 0; i < mech.objectives.Size(); i++)
		{
			let objt = mech.objectives[i];
			String prefix = pstrs[objt.priority] .. ":";
			String main   = objt.description;
			String suffix = objt.completed ? "Completed" : "In Progress";
			uint scol = objt.completed ? Font.CR_SAPPHIRE : Font.CR_GREEN;
			if(objt.failed) 
			{
				suffix = "Failed";
				scol = Font.CR_BRICK;
			}
			float xoffs = prefix.length()*17;
			H_DrawString(prefix,(objpos.x,objpos.y+yoffs),0,Font.CR_SAPPHIRE);
			H_DrawString(main,(objpos.x+xoffs,objpos.y+yoffs),0,Font.CR_GREEN);
			H_DrawString(suffix,(objpos.x+940,objpos.y+yoffs),0,scol);
			yoffs+=30;
		}
	}

	void DrawKeys()
	{
		if(!CPlayer) return;
		
		bool locks[6];
		String image;
		for(int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
		// key 1
		if (locks[1] && locks[4]) image = "STKEYS6";
		else if (locks[1]) image = "STKEYS0";
		else if (locks[4]) image = "STKEYS3";
		H_DrawImage(image, (32, 48+32),0,(6.0,4.6));
		// key 2
		if (locks[2] && locks[5]) image = "STKEYS7";
		else if (locks[2]) image = "STKEYS1";
		else if (locks[5]) image = "STKEYS4";
		else image = "";
		H_DrawImage(image, (32, 96+32),0,(6.0,4.6));
		// key 3
		if (locks[0] && locks[3]) image = "STKEYS8";
		else if (locks[0]) image = "STKEYS2";
		else if (locks[3]) image = "STKEYS5";
		else image = "";
		H_DrawImage(image, (32, 144+32),0,(6.0,4.6));
	}

	void DrawFullScreenStuff (double TicFrac) 
	{
		invalid = true;
	}
}

