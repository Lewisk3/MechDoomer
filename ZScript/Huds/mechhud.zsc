
struct FadingText
{
	String txt;
	double alpha;
	int col;
}

class MechStatusBar : BaseStatusBar
{
	Mechwarrior mechplr;
	HUDFont mHUDFont;
	Actor prevtarg;
	int tAlign;
	TextureID compass;
	bool invalid;
	double compassoffs;
	double compassdir;
	int hpcounter;
	int scrwidth;
	int scrheight;
	bool inHUDLoadout;
	Vector2 loadm_base;
	int loadm_selected;
	int loadm_invselected;
	int loadm_weapselected;
	int struc_invselected;
	int struc_weapselected;
	Mechbase_Weapon loadout_weapon;
	bool infomode;
	int internalcash;
	int cashcounter;
	String loadout_invweapon;
	int invoffset;
	FadingText dCash;
	vector2 font_scale;
	double prevMS; // TicFrac is honestly useless to me, this makes way more sense.
	
	// Scalar constant
	double defwidth;
	double defheight;
	double hud_xoffs;
	double hud_yoffs;
	
	Font fnt;
	
	// H_ Functions
	mixin HUDScaleFunctions;
	
	Color getHealthyColor(double ratio, double tintalpha=1.0)
	{
		if(ratio <= 0) return StatusColor.HSLtoRGB(0,1.0,0.0,1.0);
		return StatusColor.HSLtoRGB(0.28*(ratio-0.3),1.0,0.5, tintalpha);
	}
	
	double point_distance(Actor one, Actor two, double scale)
	{
		int x = one.pos.x - two.pos.x;
		int y = one.pos.y - two.pos.y;
		int z = one.pos.z - two.pos.z;
		return sqrt( x*x + y*y + z*z )/scale;
	}
	
	bool isTypeOfStruct(String type)
	{	
		class<Mechbase_Utility> util = type;
		return util;
	}

	override void Init()
	{
		Super.Init();
		defwidth = 1920;
		defheight = 1080;
		hud_xoffs = 800;
		hud_yoffs = 860;
		SetSize(0, 320, 200);
		font_scale = (0.5, 0.5);
		compassoffs = 0;
		compassdir = 1;
		compass = TexMan.CheckForTexture("MBEARING",TexMan.TYPE_ANY);
		tAlign = DI_TEXT_ALIGN_CENTER | DI_SCREEN_CENTER_BOTTOM;
		internalcash = -1; 
		
		// Create the font used for the fullscreen HUD
		fnt = "MechFont";
		mHUDFont = HUDFont.Create(fnt);
		
	}
	
	override void Tick()
	{	
		if(CPlayer && CPlayer.mo)
		{
			if(!mechplr) mechplr = MechWarrior(CPlayer.mo);
			if(!mechplr || mechplr && !mechplr.inv_context) 
			{
				super.tick();
				return;
			}
			if(cashcounter != mechplr.inv_context.money_cbills) 
			{
				int money = mechplr.inv_context.money_cbills - cashcounter;
				if(mechplr.inv_context.money_cbills < cashcounter)
				{ 
					cashcounter+= money/20; 
					dCash.txt = money.."";
					dCash.col = Font.CR_DARKRED;
					if(cashcounter < mechplr.inv_context.money_cbills) cashcounter = mechplr.inv_context.money_cbills;
					if(money/20 == 0) cashcounter = mechplr.inv_context.money_cbills;
				}
				if(mechplr.inv_context.money_cbills > cashcounter)
				{ 
					cashcounter+= money/20; 
					dCash.txt = "+" .. money;
					dCash.col = Font.CR_GREEN;
					if(cashcounter > mechplr.inv_context.money_cbills) cashcounter = mechplr.inv_context.money_cbills;
					if(money/20 == 0) cashcounter = mechplr.inv_context.money_cbills;
				}
				
			}
		}
	
		super.tick();
	}
	
	// This function is a bit questionably implemented, not sure if this is intended
	// behavior or not but, the hAlert struct can be accessed from Play and UI without
	// much issue, for some reason.
	
	void DrawCockpitMessages()
	{
		int msize = mechplr.hAlert.cockpit_messages.Size();
		String message_one = msize>0 ? mechplr.hAlert.cockpit_messages[0] : "";
		String message_two = msize>1 ? mechplr.hAlert.cockpit_messages[1] : "";
		double alpha_one = mechplr.hAlert.mtimer1;
		double alpha_two = mechplr.hAlert.mtimer2;
		double ypos = 28;
		
		// Milliseconds are way more natural to work with than Tic Fractions.
		if(!prevMS)
		{
			prevMS = MSTime();
			return;
		}
		double ftime = MSTime()-prevMS;
		prevMS = MSTime();
		double dtime = 1000.0 / 60.0;
		double deltatime = (ftime/dtime);
		double fadeamt = 0.1 * deltatime;
		
		// Message and alpha processing.
		if(message_one != "")
		{
			H_DrawImage("MSGBAR",(960,ypos),MD_SBS.SS_SCREEN_TOP_LEFT,scale:(3.0,2.0), alpha:alpha_one);
			H_DrawString(message_one, (32,ypos-12), scale:(2.5, 1.8), alpha:alpha_one);
		}
		ypos = 1080-28;
		if(message_two != "")
		{
			H_DrawImage("MSGBAR",(960,ypos),MD_SBS.SS_SCREEN_TOP_LEFT,scale:(3.0,2.0), alpha:alpha_two);
			H_DrawString(message_two, (32,ypos-12), scale:(2.5, 1.8), alpha:alpha_two);
		}
		
		if(alpha_one > 0 && message_one != "")
		{	
			mechplr.hAlert.mtimer1 -= fadeamt;
			if(mechplr.hAlert.mtimer1 <= 0.1) 
			{
				mechplr.hAlert.cockpit_messages[0] = "";
				if(message_two == "")
					MechDoomerEvents.SendNetworkEvent("cockpit_alert:[reset]");
			}
		}
		if(alpha_two > 0 && message_two != "")
		{	
			mechplr.hAlert.mtimer2 -= fadeamt;
			if(mechplr.hAlert.mtimer2 <= 0.1) 
			{
				mechplr.hAlert.cockpit_messages[1] = "";
				MechDoomerEvents.SendNetworkEvent("cockpit_alert:[reset]");
			}
		}
	}
	
	void drawWeapons(HUDFont fnt, vector2 pos, double scalex, double scaley)
	{
		int lastweap;
		if(CPlayer && CPlayer.mo)
		{
			let mech = MechWarrior(CPlayer.mo);		
			for(let weap = mech.Inv; weap != null; weap = weap.Inv)
			{
				let ww = Mechbase_Weapon(weap);
				if(ww)
				{
					int ftranslation = Font.CR_GREEN;
					static const int group_colors[] =
					{
						Font.CR_GREEN,
						Font.CR_WHITE,
						Font.CR_YELLOW,
						Font.CR_LIGHTBLUE
					};
					int grp = clamp(ww.group-1,0,3);
					ftranslation = group_colors[grp];
					if(ww.ammotype && ww.ammouse > mech.countammo(ww.ammotype))ftranslation = Font.CR_DARKRED;
					if( ww.cooldown_timer > 0 )ftranslation = Font.CR_DARKRED;
					int selx = (ww.WeaponID+1)%2;
					int sely = (ww.WeaponID+1)/2;
					if(ww.ammotype)
						H_DrawString(ww.specprefix..ww.displayName .. " " .. mech.countammo(ww.ammotype),(pos.x+(selx*scalex),pos.y+(sely*scaley)),0,ftranslation);
					if(!ww.ammotype)
						H_DrawString(ww.specprefix..ww.displayName,(pos.x+(selx*scalex),pos.y+(sely*scaley)),0,ftranslation);
					if(lastweap < ww.WeaponID) lastweap = ww.WeaponID;
				}
			}
			// Special exclusive weapon drawing for a struct!
			
			int amsid=1;
			for(int i = 0; i < mech.inv_context.mechstructs.Size(); i++)
			{
				String cname = mech.inv_context.mechstructs[i].Tag;
				class<AntiMissileSystem> basecast = cname;
				if(basecast)
				{
					int ftranslation = Font.CR_SAPPHIRE;
					int nselx = (lastweap+1+amsid)%2;
					int nsely = (lastweap+1+amsid)/2;
					let ams_def = GetDefaultByType(basecast);
					if(ams_def.ammotype && ams_def.ammouse > mech.countammo(ams_def.ammotype))ftranslation = Font.CR_DARKRED;
					if(mech.ams_passive) ftranslation = Font.CR_BRICK;  
					if(mech.ams_timer > 0) ftranslation = Font.CR_DARKRED;
					string prefix = ams_def.displayName;
					if(ams_def.ammotype)
					{
						H_DrawString(prefix .. " " .. mech.countammo(ams_def.ammotype),(pos.x+(nselx*scalex),pos.y+(nsely*scaley)),0,ftranslation);
						amsid++;
					}
					else
					{
						H_DrawString(prefix,(pos.x+(nselx*scalex),pos.y+(nsely*scaley)),0,ftranslation);
						amsid++;
					}
				}
			}
		}
	}
	
	bool checkWeaponBusy(int ind)
	{
		if(CPlayer && CPlayer.mo)
		{
			let mech = MechWarrior(CPlayer.mo);		
			for(let weap = mech.Inv; weap; weap = weap.Inv)
			{
				let ww = Mechbase_Weapon(weap);
				if(ww)
				{
					if(ww.WeaponID == ind)
					{
						return (ww.cooldown_timer > 0);
					}
				}
			}
		}
		return false;
	}

	void DrawNAVBar(PlayerPawn plr, Actor nav, vector2 pos, double range=220)
	{				
		double diff = MDMath.NormalizeAngle(plr.angle - plr.AngleTo(nav));
		vector2 dpos = (
			pos.x + (sin(diff)* range),
			pos.y
		);
		if(abs(diff) <= 90) 
		{
			String dimg = (abs(diff) <= 3) ? "CNAV_ON" : "CNAV_OFF";
			MD_SBS.DrawImage(dimg,dpos,0,1.0,scale:(5.5,2.0));
		}
	}
	ui void DrawCompass(PlayerPawn plr, Actor navp, vector2 pos, vector2 navpos, double range_one=550, double range_two=-150, double scale=2.0)
	{	
		double ang = MDMath.NormalizeAngle(plr.angle-(90*scale));
		double degree_per = 2.0*scale;
		vector2 apos = (
			pos.x - ang*degree_per,
			pos.y
		);
		vector2 bpos = apos;
		bpos.x -= 720*scale;
		H_SetClipRect((pos.x-range_one), pos.y-64, range_one+range_two, 96*scale, false);
		MD_SBS.DrawImage("Compass",apos, scale:(scale,scale));
		MD_SBS.DrawImage("Compass",bpos, scale:(scale,scale));
		// NAVBar draw is called so we keep the cliprect when drawing the bars.
		if(navp) DrawNAVBar(plr, navp, navpos);
		MD_SBS.ClearClipRect();
		
		// Draw Arrows
		double midx = pos.x-(720/scale)+(4*scale);
		double leftx  = midx-(720/scale)+(6*scale)-range_two;
		double rightx = midx+(720/scale)-(2*scale)+range_two;
		double midy = pos.y-(6*scale);
		if(navp)
		{
			double navd = MDMath.NormalizeAngle(plr.angle - plr.AngleTo(navp));
			double navz = plr.pos.z - navp.pos.z;
			if(navz >  10 || abs(navz) < 10) 
				MD_SBS.DrawImage("AR_DOWN" , (midx, pos.y+(24*scale)), 0, scale:(scale,scale));
			if(navz < -10 || abs(navz) < 10) 
				MD_SBS.DrawImage("AR_UP"   , (midx, pos.y-(16*scale)), 0, scale:(scale,scale));
			if(navd < -3) MD_SBS.DrawImage("AR_LEFT" , ( leftx, midy), 0, scale:(scale,scale));
			if(navd >  3) MD_SBS.DrawImage("AR_RIGHT", (rightx, midy), 0, scale:(scale,scale));
		}
	}

	double alt_cache;
	double alt_interp_timer;
	void DrawAltimeter(PlayerPawn plr, Actor target, vector2 pos, double interp=0.05)
	{
		double frame_ms = MSTime()-alt_interp_timer;
		double deltatime = (1000./60.)/frame_ms;
		alt_interp_timer = MSTime();
		
		double toz = plr.pos.z;
		toz = clamp(toz, -1100, 16800);
		if(!alt_cache) alt_cache = plr.pos.z;
		
		// Interpolate to new pos
		if(alt_cache != plr.pos.z) alt_cache = MDMath.Lerp(alt_cache, toz, interp*deltatime);
		double targz = target ? target.pos.z-plr.pos.z : 0;
		
		vector2 dpos = (
			pos.x,
			pos.y + alt_cache*0.1
		);
		vector2 trpos = (
			 pos.x*1.05,
			 (pos.y/2.86) - targz*0.1
		);
		vector2 lrpos = (
			pos.x*0.92,
			pos.y/2.86
		);
		if(plr.pos.z <= -1100 || plr.pos.z >= 16800) 
			lrpos.y -= (plr.pos.z*0.01);
		
		// Draw elements
		H_SetClipRect(pos.x-125, pos.y-1050, 200, 260, false);
		MD_SBS.DrawImage("ALTMETER",  dpos, scale:(2.0,2.0));
		MD_SBS.DrawImage("ALTLEVEL", lrpos, scale:(3.5,3.0));
		if(target)
		{
			if( targz < 1000 && targz > -1200) 
				MD_SBS.DrawImage("AR_LEFT", trpos, 0, scale:(1.5,1.5));
			else if(targz > 1000)
				MD_SBS.DrawImage("AR_UP", (pos.x,pos.y/3.65), 0, scale:(2.0,1.5));
			else if(targz < -1200)
				MD_SBS.DrawImage("AR_DOWN", (pos.x,pos.y/2.3), 0, scale:(2.0,1.5));
		}	
		MD_SBS.ClearClipRect();
	}

	override void Draw (int state, double TicFrac)
	{
		if(!automapactive) Super.Draw (state, TicFrac);
		
		if(CPlayer && CPlayer.mo)
		{
			let mech = MechWarrior(CPlayer.mo);
			if(!mech) 
			{
				MD_SBS.DrawString("MechFont", "Debug Active - Mechsim Disabled.", (0,25), MD_SBS.SS_SCREEN_TOP_CENTER, Font.CR_DARKRED, scale:(1.0, 1.0));
				return;
			}
			else if(!mech.inv_context)
			{
				return;
			}
		}
		
		// Always draw HUD
		BeginHUD();
		DrawMainBar (TicFrac);
	}
	
	int realAngle(double ang)
	{
		return acos(cos(ang));
	}
	
	
	
	void DrawBars()
	{
		if(automapactive) return;
		if(CPlayer && CPlayer.mo) 
		{
			let mech = MechWarrior(CPlayer.mo);
			if(!mech) return;
			
			vector2 throttlepos = (707, 389);
			vector2 jetpos = (270, 350);
			vector2 heatpos = (-75, 350);
			vector2 deltapos = (230, 350);
			
			if(!mech.defaultmovement)
			{
				H_DrawString(int(mech.MoveSpeedKPH*mech.throttle) .. "Kph" ,(throttlepos.x-100,throttlepos.y+25),MD_SBS.SS_SCREEN_CENTER);
				H_DrawImage("Throttle",(throttlepos.x+13,throttlepos.y-39),MD_SBS.SS_SCREEN_CENTER);
				if(abs(mech.throttle) <= 0.01)
					H_Fill(Color(int(100),0,255,0), throttlepos.x,throttlepos.y, 14, -3, MD_SBS.SS_SCREEN_CENTER);
				if(mech.throttle > 0)
				{
					H_Fill(Color(int(100),0,255,0), throttlepos.x,throttlepos.y, 14, -(mech.throttle*150), MD_SBS.SS_SCREEN_CENTER);
				}
				else
				{
					H_Fill(Color(int(100),0,0,255), throttlepos.x,throttlepos.y, 14, -(mech.throttle*140), MD_SBS.SS_SCREEN_CENTER);
				}
				
				// Torso angle
				if( !mech.pilotlook ) 
				{
					double angdiff = MDMath.NormalizeAngle(mech.angle-mech.LegAng);
					double angmax = angdiff/(mech.uncappedtorso ? 180 : mech.MaxYaw);
					H_Fill(Color(int(255),0,255,0),960,130,-(angmax*200),10);
					if( abs(angdiff) <= 1)H_Fill(Color(255,0,255,0),960,130,4,10);
				}
			}
			
			if(mech.Mech_HasJets) 
			{
				H_DrawString("Jets",(jetpos.x,jetpos.y+30),MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(100,255,0,0),jetpos.x,jetpos.y,132,20,MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(100,0,255,0),jetpos.x,jetpos.y,mech.mech_jetsfuel*1.32,20,MD_SBS.SS_SCREEN_CENTER);
			}
			H_DrawString("Heat",(heatpos.x-145,heatpos.y+30),MD_SBS.SS_SCREEN_CENTER);
			H_Fill(Color(255,206,206,0),heatpos.x-147,heatpos.y,290,20, MD_SBS.SS_SCREEN_CENTER);
			double heatmid = MWHEAT_MAX*0.25;
			double sizemul = (200/MWHEAT_MAX)*3;
			if(mech.HeatLevel > heatmid)
			{
				double hmin = clamp(mech.HeatLevel-heatmid,0,heatmid);
				double hmax = clamp(-(mech.HeatLevel-heatmid),-heatmid,0);
				H_Fill(Color(255,255,0,0),heatpos.x,heatpos.y,hmin*sizemul,20, MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(255,255,0,0),heatpos.x,heatpos.y,hmax*sizemul,20, MD_SBS.SS_SCREEN_CENTER);
			}
			else
			{
				double hmin = clamp(mech.HeatLevel,0,heatmid);
				double hmax = clamp(-(mech.HeatLevel),-heatmid,0);
				H_Fill(Color(255,2,30,216),heatpos.x,heatpos.y,143-(hmin)*sizemul,20, MD_SBS.SS_SCREEN_CENTER);
				H_Fill(Color(255,2,30,216),heatpos.x,heatpos.y,-(148+((hmax)*sizemul)),20, MD_SBS.SS_SCREEN_CENTER);
			}
			H_DrawString("dH/dT",(deltapos.x-127,deltapos.y+30),MD_SBS.SS_SCREEN_CENTER);
			H_Fill(Color(255,206,206,0),deltapos.x-128,deltapos.y,125,20, MD_SBS.SS_SCREEN_CENTER);
			double hmax = clamp(-(mech.deltaHeat),-heatmid,0);
			H_Fill(Color(255,2,30,216),deltapos.x,deltapos.y,-(130+((hmax)*sizemul)),20, MD_SBS.SS_SCREEN_CENTER);
			
		}
	}
	
	
	void Draw_Radar()
	{	
		if(CPlayer && CPlayer.mo)
		{
			double ranges[4] = 
			{
				1000,
				500,
				250,
				2000
			};
			
			let mech = MechWarrior(CPlayer.mo);
			if(!mech) return;
			double range = ranges[mech.radar_range];
			double scale = range * 0.04;
			ThinkerIterator act_it = ThinkerIterator.Create("Actor");
			Actor obj;
						
			// Draw FOV bars (For some reason the xaxis needs to be divided by 2 to scale correctly.)
			double drawang = mech.defaultmovement ? 90 : mech.angle-mech.LegAng+90;
			drawAngledLine(238,180,156,drawang,mech.player.FOV/2,Color(255,53,255,53));
			drawAngledLine(238,180,156,drawang,-mech.player.FOV/2,Color(255,53,255,53));
	
			double radarx = 240;
			double radary = 180;
			H_DrawImage("MECRADAR",(radarx,radary),0,(1.0,0.9));
			
			string metertext = String.Format("%.1fm",range);
			if(range >= 1000)
			{
				metertext = String.Format("%.1fkm",range/1000);
			}
			
			H_DrawString("\c[GREEN]R: " .. metertext, (65,35), scale:(1.25,1.35));
		
			while(obj = Actor(act_it.Next()))
			{			
				int x = mech.pos.x - obj.pos.x;
				int y = mech.pos.y - obj.pos.y;
				int dis = obj.Distance2D(CPlayer.mo) / MWGAMEPLAY_UNITMETER;
				if( dis < range )
				{
					double frontangle = mech.angle+180;
					int dx = ( y * cos((frontangle) )) - ( x * sin((frontangle)) );
					int dy = ( y * sin((frontangle) )) + ( x * cos((frontangle)) );
					dx /= scale;
					dy /= scale;
					// If we're not the player and we're awake.
					let nmech = MechWarrior(obj);
					if( nmech != mech && obj.target != NULL)
					{
						if(obj.bSOLID && obj.bSHOOTABLE) H_DrawImage("ENEMYIND",(radarx-dx,radary-dy),0,(0.8,0.6));
						if(obj == mech.targetenemy) H_DrawString("+",(radarx-dx,radary-dy));
					}
				}
			}
		}
	}
	
	double GetHardpointVitalRatio(MechHardpoint hp)
	{
		double hp_vitals    = hp.armor+hp.internalhp;
		double hp_maxvitals = hp.max_armor+hp.max_internal;
		if(hp.internalhp <= 0) hp_vitals = 0;
		if(hp_vitals == 0) return 1.0;
		double vres = 1.0 - (hp_vitals / hp_maxvitals);
		if(vres < 0.1) vres = 0;
		return vres;
	}
	
	void DrawMainBar (double TicFrac)
	{
		if(CPlayer && CPlayer.mo)
		{		
			DrawKeys();			
			let mech = MechWarrior(CPlayer.mo);
			if(!mech)return;	
			if(!mech.inv_context) return;
			
			invalid = false;
			
			if(!mech.modelcockpit) H_DrawImage(mech.hud_cockpit,(955,940+mech.boboffs),0,(3.2,2.0));
			if(mech.health <= 0) return;
			
			if(CVar.FindCVar("mwd_nohud").getBool()) return;
			
			H_DrawImage("CBILLS",(1740,405),0,(1.3,1));
			String cash = cashcounter .. "";
			H_DrawString(cash,(1755,395));
			
			if(dCash.txt != "" && dCash.alpha > 0) 
			{
				H_DrawString(dCash.txt,(1752,420),0,dCash.col,(1,1),dCash.alpha);
				dCash.alpha -= 0.01;
			}
			if(dCash.txt != "" && dCash.alpha <= 0){ dCash.txt = ""; dCash.alpha = 1.0; }
			
			
			if(!mech.mech_shutdown)
			{
				Draw_Radar();
				DrawCompass(mech, mech.targetenemy, (1313,100),(970,115));
				DrawAltimeter(mech, mech.targetenemy, (270,1425));
				H_DrawImage("MWTARGET",(200,836),0,(1.3,1.3));
				if(mech.targetenemy)
				{	
					bool isNav = NAVPoint(mech.targetenemy) != NULL;
					Actor cam;
					if(!isNav)
						cam = mech.targetreticle.cam;
					else
						cam = mech.targetenemy;
						
					TexMan.SetCameraToTexture(cam,"TargetCamera",90.0);
					TextureID targ = TexMan.CheckForTexture("TargetCamera",TexMan.TYPE_ANY);
					H_DrawTexture(targ,(199,834),0,(1.3,1.3));
					String dist = mech.Distance3D(mech.targetenemy)/MWGAMEPLAY_UNITMETER .. "";
					dist.truncate(dist.Length()-6);
					
					String targetname = mech.targetenemy.getTag();
					targetname.Replace("_"," ");
					if(isNav)	
						H_DrawString(targetname,(86,960));
					else
						H_DrawString("Type: " .. targetname,(86,960));
						
					H_DrawString("Distance: " .. dist .. "m",(86,980));
					// Enemy health bar (If not NAVPoint)
					if(!NAVPoint(mech.targetenemy))
					{
						double percenthealth = double(mech.targetenemy.SpawnHealth()-(mech.targetenemy.SpawnHealth()-hpcounter) ) / mech.targetenemy.SpawnHealth();
						if(mech.targetenemy.health < hpcounter)hpcounter -= (hpcounter-mech.targetenemy.health)*0.1;
						if(hpcounter == 0) hpcounter = mech.targetenemy.health;
						if(mech.targetenemy.health <= 0) hpcounter = 0;
						if(prevtarg != mech.targetenemy)
						{
							hpcounter = 0;
							prevtarg = mech.targetenemy;
						}
						H_Fill(Color(255,0,0,0), 80, 920, 242, 16, 0);
						H_Fill( Color(255,0,173,0), 80, 920,
								percenthealth*242, 16, 0     );						
						String percenthp = percenthealth*100 .. "";
						percenthp.truncate(percenthp.Length()-6);
						H_DrawString(percenthp .. "%" ,(170,920));
					}
				}
				drawWeapons(mHUDFont,(1370,55),220,50);
				
				String hud_mech = mech.hud_mech;
				if(hud_mech.ByteAt(0) == "#")
				{
					hud_mech.Remove(0,1);
					DrawPaperDoll(hud_mech, false);
				}
				else
					DrawPaperDoll(hud_mech, true);
					
				// Draw weapon indicator
				if(!automapactive)
				{
					String weapind = "WEAPIND";
					int selx = (mech.selectedWeapon+1)%2;
					int sely = (mech.selectedWeapon+1)/2;
					vector2 weappos = ( 1450 + (selx*220), 64 + (sely*50) );
					if(checkWeaponBusy(mech.selectedWeapon)) weapind = "WEAPSEL";
					if(mech.selectedWeapon <= mech.inv_context.weapons_count)H_DrawImage(weapind,weappos,0,(0.8,0.6));
				}
					
				// Draw speedometer.
				DrawBars();
				DrawObjectives();
				// Crosshair
				double chscale = CVar.GetCVar("mwd_crosshairsize",mech.player).GetFloat();
				if(mech.inv_context.weapons_count && !automapactive)
				{
					H_DrawImage (
						mech.crosshair_sprite,(0.5,0.5),
						MD_SBS.SS_COORDS_TEXGRID|MD_SBS.SS_SCREEN_CENTER,
						(1.35*chscale,1.25*chscale)
					);
				}
			}
			// Draw messages on top.
			DrawCockpitMessages();
		}
	}

	void DrawPaperDoll(String paperdoll, bool clipmode=true)
	{
		double hd_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.hd);
		double ct_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.ct);
		double lt_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.lt);
		double rt_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.rt);
		double la_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.la);
		double ra_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.ra);
		double ll_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.ll);
		double rl_dmg = 1.0-GetHardpointVitalRatio(mechplr.inv_context.hardpoints.rl);
		
		vector2 hmechpos;
		Color hpcolor;
		int pd_flags;
		
		if(mechplr.hud_htal)
		{	
			vector2 clippos = (1370,810);
			hmechpos = (-590,-360);
			hpcolor  = getHealthyColor(1.0,0);
			pd_flags = MD_SBS.SS_TEXCOORDS_ABSOLUTE | MD_SBS.SS_SCREEN_BOTTOM_RIGHT;
			H_SetClipRect(clippos.x,clippos.y-128,256,115,false);
			H_DrawImage("HTALBASE",hmechpos,pd_flags,scale:(1.3,1.3),tint:hpcolor);
			// HD
			hmechpos += (44, 88);
			hpcolor = getHealthyColor(hd_dmg,(hd_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x,clippos.y,28,42*hd_dmg,false);
			H_DrawImage("HBARTHIC",hmechpos,pd_flags,scale:(1.3,0.5),tint:hpcolor);
			ClearClipRect();
			// LT
			hmechpos += (34, 4);
			hpcolor = getHealthyColor(lt_dmg,(lt_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x+34,clippos.y,14,70*lt_dmg,false);
			H_DrawImage("HBARTHIN",hmechpos,pd_flags,scale:(1.3,0.7),tint:hpcolor);
			ClearClipRect();
			// CT
			hmechpos += (27, 0);
			hpcolor = getHealthyColor(ct_dmg,(ct_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x+34+27,clippos.y,14,90*ct_dmg,false);
			H_DrawImage("HBARTHIN",hmechpos,pd_flags,scale:(1.3,1.0),tint:hpcolor);
			ClearClipRect();
			// RT
			hmechpos += (27, 0);
			hpcolor = getHealthyColor(rt_dmg,(rt_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x+34+27+27,clippos.y,14,70*rt_dmg,false);
			H_DrawImage("HBARTHIN",hmechpos,pd_flags,scale:(1.3,0.7),tint:hpcolor);
			ClearClipRect();
			// LA
			hmechpos += (32, 0);
			hpcolor = getHealthyColor(la_dmg,(la_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x+34+27+27+32,clippos.y,28,70*la_dmg,false);
			H_DrawImage("HBARTHIC",hmechpos,pd_flags,scale:(1.3,0.7),tint:hpcolor);
			ClearClipRect();
			// RA
			hmechpos += (27, 0);
			hpcolor = getHealthyColor(ra_dmg,(ra_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x+34+27+27+32+27,clippos.y,28,70*ra_dmg,false);
			H_DrawImage("HBARTHIC",hmechpos,pd_flags,scale:(1.3,0.7),tint:hpcolor);
			ClearClipRect();
			// LL
			hmechpos += (32, 0);
			hpcolor = getHealthyColor(ll_dmg,(ll_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x+34+27+27+32+27+32,clippos.y,28,90*ll_dmg,false);
			H_DrawImage("HBARTHIC",hmechpos,pd_flags,scale:(1.3,1.0),tint:hpcolor);
			ClearClipRect();
			// RL
			hmechpos += (27, 0);
			hpcolor = getHealthyColor(rl_dmg,(rl_dmg<1.0)*0.7);
			H_SetClipRect(clippos.x+34+27+27+32+27+32+27,clippos.y,28,90*rl_dmg,false);
			H_DrawImage("HBARTHIC",hmechpos,pd_flags,scale:(1.3,1.0),tint:hpcolor);
			ClearClipRect();
		}
		else
		{
			hmechpos = (-382,-245);
			hpcolor  = getHealthyColor(1.0,0);
			pd_flags = MD_SBS.SS_TEXCOORDS_ABSOLUTE | MD_SBS.SS_SCREEN_BOTTOM_RIGHT;
			if(!clipmode)
			{
				// HD
				hpcolor = getHealthyColor(hd_dmg,hd_dmg<1.0);
				H_DrawImage(paperdoll.."_HD",hmechpos,pd_flags,tint:hpcolor);
				// CT
				hpcolor = getHealthyColor(ct_dmg,ct_dmg<1.0);
				H_DrawImage(paperdoll.."_CT",hmechpos,pd_flags,tint:hpcolor);
				// LT
				hpcolor = getHealthyColor(lt_dmg,lt_dmg<1.0);
				H_DrawImage(paperdoll.."_LT",hmechpos,pd_flags,tint:hpcolor);
				// RT
				hpcolor = getHealthyColor(rt_dmg,rt_dmg<1.0);
				H_DrawImage(paperdoll.."_RT",hmechpos,pd_flags,tint:hpcolor);
				// LA
				hpcolor = getHealthyColor(la_dmg,la_dmg<1.0);
				H_DrawImage(paperdoll.."_LA",hmechpos,pd_flags,tint:hpcolor);
				// RA
				hpcolor = getHealthyColor(ra_dmg,ra_dmg<1.0);
				H_DrawImage(paperdoll.."_RA",hmechpos,pd_flags,tint:hpcolor);
				// LL
				hpcolor = getHealthyColor(ll_dmg,ll_dmg<1.0);
				H_DrawImage(paperdoll.."_LL",hmechpos,pd_flags,tint:hpcolor);
				// RL
				hpcolor = getHealthyColor(rl_dmg,rl_dmg<1.0);
				H_DrawImage(paperdoll.."_RL",hmechpos,pd_flags,tint:hpcolor);
			}
			else
			{
				
				String hudmech = paperdoll.."A";
				
				vector2 hudmech_size = MD_SBS.GetImageSize(hudmech);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				vector2 clipoffset = (1445, 750);
				// CT -> clipoffset.x+hudmech_size.x/3, clipoffset.y, hudmech_size.x/7,hudmech_size.y/2
				// LT -> clipoffset.x+hudmech_size.x/4, clipoffset.y, hudmech_size.x/12,hudmech_size.y/2
				// RT -> clipoffset.x+hudmech_size.x/2.1, clipoffset.y, hudmech_size.x/13,hudmech_size.y/2
				// LA -> clipoffset.x, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3
				// RA -> clipoffset.x+hudmech_size.x/1.8, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3
				// LL -> clipoffset.x+hudmech_size.x/2, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2
				// RL -> clipoffset.x+hudmech_size.x/5.9, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2
				// CT
				hpcolor = getHealthyColor(ct_dmg,ct_dmg<1.0);
				H_SetClipRect(clipoffset.x+hudmech_size.x/3, clipoffset.y, hudmech_size.x/7,hudmech_size.y/2);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				ClearClipRect();
				// LT
				hpcolor = getHealthyColor(lt_dmg,lt_dmg<1.0);
				H_SetClipRect(clipoffset.x+hudmech_size.x/4, clipoffset.y, hudmech_size.x/12,hudmech_size.y/2);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				ClearClipRect();
				// RT
				hpcolor = getHealthyColor(rt_dmg,rt_dmg<1.0);
				H_SetClipRect(clipoffset.x+hudmech_size.x/2.1, clipoffset.y, hudmech_size.x/13,hudmech_size.y/2);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				ClearClipRect();
				// LA
				hpcolor = getHealthyColor(la_dmg,la_dmg<1.0);
				H_SetClipRect(clipoffset.x, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				ClearClipRect();
				// RA
				hpcolor = getHealthyColor(ra_dmg,ra_dmg<1.0);
				H_SetClipRect(clipoffset.x+hudmech_size.x/1.8, clipoffset.y+hudmech_size.y/6, hudmech_size.x/4,hudmech_size.y/3);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				ClearClipRect();
				// LL
				hpcolor = getHealthyColor(ll_dmg,ll_dmg<1.0);
				H_SetClipRect(clipoffset.x+hudmech_size.x/2, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				ClearClipRect();
				// RL
				hpcolor = getHealthyColor(rl_dmg,rl_dmg<1.0);
				H_SetClipRect(clipoffset.x+hudmech_size.x/5.9, clipoffset.y+hudmech_size.y/2.5, hudmech_size.x/7,hudmech_size.y/2);
				H_DrawImage(hudmech,hmechpos,pd_flags,tint:hpcolor);
				ClearClipRect();
			}
		}
	}

	void DrawObjectives()
	{
		string pstrs[4] = 
		{
			"Primary",
			"Secondary",
			"Tertiary",
			"Quaternary"
		};
		
		let mech = MechWarriorBase(CPlayer.mo); 
		if(!mech) return;
		if(!mech.display_objectives) return;
		vector2 objpos = (-470,-200);
		uint flags = MD_SBS.SS_SCREEN_CENTER;
		double bigscale = 2.0;
		double smallscale = 1.2;
		H_DrawString("MISSION OBJECTIVES",objpos,flags,Font.CR_SAPPHIRE,(bigscale,bigscale));
		
		int yoffs = 50;
		for(int i = 0; i < mech.objectives.Size(); i++)
		{
			let objt = mech.objectives[i];
			String prefix = pstrs[objt.priority] .. ":";
			String main   = objt.description;
			String suffix = objt.completed ? "Completed" : "In Progress";
			uint scol = objt.completed ? Font.CR_SAPPHIRE : Font.CR_GREEN;
			if(objt.failed) 
			{
				suffix = "Failed";
				scol = Font.CR_BRICK;
			}
			double xoffs = prefix.length()*17;
			H_DrawString(prefix,(objpos.x,objpos.y+yoffs),flags,Font.CR_SAPPHIRE,(smallscale,smallscale));
			H_DrawString(main,(objpos.x+xoffs,objpos.y+yoffs),flags,Font.CR_GREEN,(smallscale,smallscale));
			H_DrawString(suffix,(objpos.x+940,objpos.y+yoffs),flags,scol,(smallscale,smallscale));
			yoffs+=30;
		}
	}

	void DrawKeys()
	{
		if(!CPlayer) return;
		
		bool locks[6];
		String image;
		for(int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
		// key 1
		if (locks[1] && locks[4]) image = "STKEYS6";
		else if (locks[1]) image = "STKEYS0";
		else if (locks[4]) image = "STKEYS3";
		H_DrawImage(image, (32, 48+32),0,(6.0,4.6));
		// key 2
		if (locks[2] && locks[5]) image = "STKEYS7";
		else if (locks[2]) image = "STKEYS1";
		else if (locks[5]) image = "STKEYS4";
		else image = "";
		H_DrawImage(image, (32, 96+32),0,(6.0,4.6));
		// key 3
		if (locks[0] && locks[3]) image = "STKEYS8";
		else if (locks[0]) image = "STKEYS2";
		else if (locks[3]) image = "STKEYS5";
		else image = "";
		H_DrawImage(image, (32, 144+32),0,(6.0,4.6));
	}

	void DrawFullScreenStuff (double TicFrac) {}
}



