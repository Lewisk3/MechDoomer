extend class Mechlab_Menu;

// Scalar functions (All H_ function auto adjust to the screen resolution based on 1080p coords.)	
void H_DrawImage(String img, vector2 pos, uint flags=0, vector2 scale=(1,1), float alpha=1, Color tint=Color(0,0,0,0))
{
	MD_SBS.DrawImage(img,pos,flags,alpha,scale,tint);
}
void H_DrawTexture(TextureID texture, Vector2 pos, int flags = 0, Vector2 scale = (1, 1), float alpha=1)
{
	MD_SBS.DrawTexture(texture,pos,flags,alpha,scale);
}
void H_DrawString(String str, vector2 pos, uint flags = 0, int translation = Font.CR_UNTRANSLATED, vector2 scale=(1,1), float alpha=1)
{
	vector2 finalscale = (font_scale.x*scale.x, font_scale.y*scale.y);
	float fontscale = CVar.GetCVar("mwd_fontscale", mechplr.player).getFloat();
	finalscale *= fontscale;
	MD_SBS.DrawString(mFont,str,pos,flags,translation,alpha,finalscale);
}
void H_DrawLine(int x0, int y0, int x1, int y1, Color color)
{
	MD_SBS.DrawLine(x0,y0,x1,y1, color);
}

// Rect utilities
vector2, vector2 GetActualRectPos(Rect r)
{
	vector2 pos0, pos1;
	pos0 = MD_SBS.GetRelativePos( (r.x,r.y) );
	pos1 = MD_SBS.GetRelativePos( (r.x+r.w,r.y+r.h) );
	return pos0, pos1;
}
void initRect(Rect r, double x, double y, double w, double h)
{
	r.x = x;
	r.y = y;
	r.w = w;
	r.h = h;
}
void drawRect( Rect r, Color c, bool absolute=false )
{
	if(!absolute)
	{
		H_DrawLine(r.x,     r.y,     r.x+r.w, r.y+r.h, c);  //: \
		H_DrawLine(r.x,     r.y,     r.x+r.w, r.y,     c);  //: -
		H_DrawLine(r.x,     r.y+r.h, r.x+r.w, r.y+r.h, c);  //: _
		H_DrawLine(r.x,     r.y,     r.x,     r.y+r.h, c);  //: |
		H_DrawLine(r.x+r.w, r.y,     r.x+r.w, r.y+r.h, c);  //:  |
	}
	else
	{
		Screen.DrawLine(r.x,     r.y,     r.x+r.w, r.y+r.h, c);  //: \
		Screen.DrawLine(r.x,     r.y,     r.x+r.w, r.y,     c);  //: -
		Screen.DrawLine(r.x,     r.y+r.h, r.x+r.w, r.y+r.h, c);  //: _
		Screen.DrawLine(r.x,     r.y,     r.x,     r.y+r.h, c);  //: |
		Screen.DrawLine(r.x+r.w, r.y,     r.x+r.w, r.y+r.h, c);  //:  |
	}
}
bool checkCollision( Rect one, Rect two )
{
	vector2 a0, a1, b0, b1;
	a0 = (one.x, one.y);
	a1 = (one.x+one.w, one.y+one.h);
	[b0, b1] = GetActualRectPos(two);
	
	bool collision;
		
	collision = (a0.x < b1.x && a1.x > b0.x && a0.y < b1.y && a1.y > b0.y);
	
	Color c = collision ? Color(255,255,0,0) : debug_color;
	
	//drawRect(one, c, true);
	//drawRect(two, c);

	return collision;
}

// Controls
override bool OnUIEvent(UiEvent ev)
{
	if(ev.Type == UIEvent.Type_KeyDown)
	{
		if(MechDoomerEvents.checkBoundKeyName(ev.KeyChar,"Mech_LoadoutUI")) Close();
	}
	
	if(ev.Type == UIEvent.Type_MouseMove)
	{
		mpos.x = ev.MouseX-5;
		mpos.y = ev.MouseY-5;
		mouse.x = mpos.x;
		mouse.y = mpos.y;
	}
	
	if(ev.Type == UIEvent.Type_RButtonDown) mstats.right_btn = true;
	if(ev.Type == UIEvent.Type_RButtonUp  ) 
	{
		if(mstats.right_btn) mstats.right_pressed = true;
		mstats.right_btn = false;
	}
	if(ev.Type == UIEvent.Type_LButtonDown) mstats.left_btn  = true;
	if(ev.Type == UIEvent.Type_LButtonUp  ) 
	{
		if(mstats.left_btn) mstats.left_pressed  = true;
		mstats.left_btn = false;
	}
	if(ev.Type == UIEvent.Type_WheelUp  ) mstats.scroll = -1;
	if(ev.Type == UIEvent.Type_WheelDown) mstats.scroll = 1;
	
	return false;
}
override bool MenuEvent (int mkey, bool fromcontroller)
{
	switch (mkey)
	{
	case MKEY_Back:
		Close();
		return true;
	}
	return false;
}

// Misc
void HUD_ChangePageRelative(int offs)
{
	mechplr.A_PlaySound("UI/PressButton",CHAN_WEAPON);
	mstats.left_btn = false;
	mstats.right_btn = false;
	hud_page += offs;
	page_init = false;
}