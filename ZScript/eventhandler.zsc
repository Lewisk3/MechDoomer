
class MechDoomerEvents : EventHandler 
{
	ColorTintShaderManager ShaderManager;
	ui Mechlab_Menu mechlab;
	double screenfade;
	Color screenfadecolor;
	
	ui void PrintException(String fmt, int xoffs=0, int yoffs=0)
	{	
		MD_SBS.DrawString(
			"BigFont", fmt, 
			(xoffs-880, yoffs-300),
			MD_SBS.SS_SCREEN_CENTER, Font.CR_RED
		);
	}
	
	override void RenderOverlay(RenderEvent e)
	{
		Screen.Dim(screenfadecolor,screenfade,0,0,Screen.GetWidth(),Screen.GetHeight());
	
		CVar rendermode = CVar.FindCVar("vid_rendermode");
		if(rendermode.GetInt() != 4)
		{
			Color dimcol = Color(0,0,0,0);
			Screen.Dim(dimcol,1.0,0,0,Screen.GetWidth(),Screen.GetHeight());
			PrintException("Please switch Render modes!\nThe only render mode supported currently is Hardware Accelerated.\nOpen the console and type vid_rendermode 4 or set it in \"Set Video Mode\"");
			return;
		}
		
		let plr = Mechwarrior(e.Camera);
		CVar target_mode;
		
		if(!plr) 
		{
			let cam = MechCockpitCamera(e.Camera);
			if(cam) plr = Mechwarrior(cam.mechowner);
		}
		if(plr) target_mode = CVar.GetCVar("mwd_viewport_target",plr.player);	
		
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		if(!automapactive && plr && plr.targetenemy && target_mode.getBool())
		{
			double fovH = (e.camera.player != NULL) ? e.camera.player.FOV : e.camera.cameraFOV;
			mwd_Matrix worldToClip = mwd_Matrix.worldToClip(e.viewPos, e.viewAngle, e.viewPitch, e.viewRoll, fovH);
			Actor projActor = plr.targetenemy;
			if (plr && projActor) 
			{
				// this moves the position of the actor into absolute coordinates relative to the viewPos
				// (which the view matrix is expecting)
				Vector3 adjustedWorldPos = e.viewPos + LevelLocals.vec3Diff(e.viewPos, projActor.pos);
				
				Vector3 positions[8];
				positions[0] = (adjustedWorldPos + ( projActor.radius,  projActor.radius, 0               ));
				positions[1] = (adjustedWorldPos + (-projActor.radius,  projActor.radius, 0               ));
				positions[2] = (adjustedWorldPos + ( projActor.radius, -projActor.radius, 0               ));
				positions[3] = (adjustedWorldPos + (-projActor.radius, -projActor.radius, 0               ));
				positions[4] = (adjustedWorldPos + ( projActor.radius,  projActor.radius, projActor.height));
				positions[5] = (adjustedWorldPos + (-projActor.radius,  projActor.radius, projActor.height));
				positions[6] = (adjustedWorldPos + ( projActor.radius, -projActor.radius, projActor.height));
				positions[7] = (adjustedWorldPos + (-projActor.radius, -projActor.radius, projActor.height));
				
				Vector3 ndcPositions[8];
				// ndcCounter tracks how many valid ndcPositions were found, if it's not 8 by the end of the loop then
				// we won't draw anything
				int ndcCounter = 0;
				bool anyOnScreen = false;
				for (int i = 0; i < 8; i++) 
				{
					Vector3 worldPos = positions[i];
					Vector3 ndcPos = worldToClip.multiplyVector3(worldPos).asVector3();
					
					if (ndcPos.x <= 1 && ndcPos.x >= -1 &&
						ndcPos.y <= 1 && ndcPos.y >= -1   ) anyOnScreen = true;
					if (ndcPos.z <= 1 && ndcPos.z >= -1) 
					{
						ndcCounter++;
						ndcPositions[i] = ndcPos;
					}
				}
				
				if (anyOnScreen && ndcCounter >= 8) 
				{
					// the infinities are used here since any real number will be automatically lower/higher than infinity/-infinity
					double lowestX  =  double.infinity;
					double lowestY  =  double.infinity;
					double highestX = -double.infinity;
					double highestY = -double.infinity;
					
					// create a bounding box from the projected positions
					for (int i = 0; i < 8; i++) 
					{
						Vector2 ndc = ndcPositions[i].xy;
						if (ndc.x < lowestX ) lowestX  = ndc.x;
						if (ndc.y < lowestY ) lowestY  = ndc.y;
						if (ndc.x > highestX) highestX = ndc.x;
						if (ndc.y > highestY) highestY = ndc.y;
					}
					
					Vector3 corners[4];
					corners[0] = (clamp(lowestX , -0.95, 0.95), clamp(lowestY , -0.95, 0.95), 0);
					corners[1] = (clamp(highestX, -0.95, 0.95), clamp(lowestY , -0.95, 0.95), 0);
					corners[2] = (clamp(lowestX , -0.95, 0.95), clamp(highestY, -0.95, 0.95), 0);
					corners[3] = (clamp(highestX, -0.95, 0.95), clamp(highestY, -0.95, 0.95), 0);
					string cornerTextures[4];
					cornerTextures[0] = "RETCC0";
					cornerTextures[1] = "RETCD0";
					cornerTextures[2] = "RETCA0";
					cornerTextures[3] = "RETCB0";
					Vector2 cornerDirs[4];
					cornerDirs[0] = (-1,  1);
					cornerDirs[1] = ( 1,  1);
					cornerDirs[2] = (-1, -1);
					cornerDirs[3] = ( 1, -1);
					
					for (int i = 0; i < 4; i++) 
					{
						Vector2 viewportPos = mwd_GlobalMaths.ndcToViewPort(corners[i]);
						viewportPos.y -= 15;	
						Screen.drawTexture(TexMan.checkForTexture(cornerTextures[i], TexMan.Type_Any), false, viewportPos.x, viewportPos.y);
					}
				}
			}
		}
	}
	
	override void WorldThingDamaged(WorldEvent e)
	{
		if(!e || !e.Thing || !e.DamageSource) return;
		String ThingHit = e.Thing.GetClassName();
		String SourceName = "UNDEFINED";
	
		// Make sure the damage is coming from the player.
		if (e.DamageSource)
		{SourceName = e.DamageSource.GetClassName();}
		
		// Make names easier to check against.
		SourceName.ToLower();
		ThingHit.ToLower();

		int Thinghealth = e.Thing.SpawnHealth();
		int gibhealth = -Thinghealth;
		if (e.Thing.Health <= 0) 
		{
			if(SourceName != "undefined" && e.DamageSource)
			{
				if(MechWarrior(e.DamageSource))
				{
					int amt = max(Thinghealth * 10.27,1);
					MechWarrior(e.DamageSource).adjustMoney(amt);
				}
			}
		}
	}
	
	clearscope static bool checkBoundKey(int keycode, String binding)
	{
		int btnone, btntwo;
		[btnone, btntwo] = Bindings.GetKeysForCommand(binding);
		btntwo = (btntwo == 0) ? btnone : btntwo;
		if(!btnone && !btntwo) return false;
		return (keycode == btnone || keycode == btntwo);
	}
	
	clearscope static bool checkBoundKeyName(int keychar, String binding)
	{
		int btnone, btntwo;
		[btnone, btntwo] = Bindings.GetKeysForCommand(binding);
		btntwo = (btntwo == 0) ? btnone : btntwo;
		if(!btnone && !btntwo) return false;
		String btns = KeyBindings.NameKeys(btnone, btntwo);
		return (keychar == btns.ByteAt(0)) || (keychar == btns.ByteAt(1));
	}
	
	// Returns: True if command on key is valid, false if it is not.
	override bool InputProcess(InputEvent e)
	{
		int keystatus = e.Type == e.Type_KeyDown ?  1 : 
						e.Type == e.Type_KeyUp   ? -1 : 0;
						
		if(keystatus != 0)
		{
			int keyscn = e.KeyScan;
			String onoff = keystatus < 0 ? "-" : "+";
			bool jets = checkBoundKey(keyscn,"Mech_JumpJets_Fire");
			bool look = checkBoundKey(keyscn,"Mech_PilotLook");
			bool loadout = checkBoundKey(keyscn,"Mech_LoadoutUI");
			
			if(jets) EventHandler.SendNetworkEvent(onoff.."mwd_user5");
			if(look) EventHandler.SendNetworkEvent(onoff.."mwd_pilotlook");
		
			if(loadout && keystatus > 0)
			{
				Menu m = Menu.GetCurrentMenu();
				let plr = Mechwarrior(players[consoleplayer].mo);
				if(!plr) return false;
				
				if (!Mechlab_Menu(m))
				{
					mechlab = new('Mechlab_Menu');
					mechlab.Init(null, plr);
					mechlab.ActivateMenu();
				}
				return true;
			}
		
			return jets | look;
		}
		return false;
	}

	override void WorldTick()
	{
		let plr = MechWarrior(players[consoleplayer].mo);
		
		/* Debug pickup-able anomalies. *\
		let it = ThinkerIterator.Create("Inventory");
		Actor act;
		while(act = Actor(it.Next()))
		{
			if( !(act is "Item_NoPickup") && plr.Distance3D(act) <= 16) console.printf("Pickup-able Inv: %s", act.getClassName());
		}
		*/
				
		if(!ShaderManager)
			ShaderManager = ColorTintShaderManager(StaticEventHandler.Find("ColorTintShaderManager"));
		else if(plr)
		{
			if(ShaderManager.resetInfrared)
			{
				plr.InfraredActive = false;
				ShaderManager.resetInfrared = false;
			}
			ShaderManager.imageEnhancementOn = plr.InfraredActive;
		}
	}
		
	override void NetworkProcess(ConsoleEvent e)
	{
		String netcmd = e.Name;
		let plr = MechWarrior(players[e.Player].mo);
		if(plr)
		{
			// Process mechlab netevents
			if(netcmd == "screen_setfadecolor") screenfadecolor = Color(255, e.Args[0],e.Args[1],e.Args[2]);
			if(netcmd == "screen_setfade") 
			{
				screenfade = e.Args[0]/255.0;
			}
			if(netcmd == "screen_toggleinfrared") 
			{
				if(ShaderManager)
				{
					plr.InfraredActive = !plr.InfraredActive;
					ShaderManager.imageEnhancementOn = plr.InfraredActive;
					if(plr.InfraredActive) 
					{
						plr.mechSounds.pushSound("Mech/Betty/LightAmp");
						plr.mechSounds.pushSound("Mech/Betty/Engaged");
						plr.A_PlaySound("Mech/Infrared",CHAN_WEAPON);
					}
				}
			}
			if(netcmd == "toggle_objectives") plr.display_objectives = !plr.display_objectives;
			if(netcmd == "exchange_mech" && plr.inv_context.mechs.Size() >= e.Args[0]) plr.StartMechChange(e.Args[0]);
			if(netcmd == "engine_dequip" && plr.inv_context.engine) plr.DequipEngine();
			if(netcmd == "dronebackchase" && !plr.isdead && !plr.pilotlook && !plr.mech_shutdown) plr.ToggleDrone(200,0,15,false);
			if(netcmd == "droneviewswitch" && !plr.isdead && plr.dronecam) plr.dronecam.frontcam = !plr.dronecam.frontcam;
			if(netcmd == "kill mech") { plr.hardpoints.hd.internalhp = 0; plr.DamageMobJ(null,null,1,""); }
			if(netcmd == "repair_hardpoint") plr.repairHardpointStat(e.Args[0],e.Args[1]);
			if(netcmd == "adjust_armor") plr.AdjustMaxArmor(plr.hardpoints.FindByIndex(e.Args[0]),e.Args[1], true);
			if(netcmd == "equip_invweap") plr.equipWeaponInv(e.Args[0]+1,plr.hardpoints.FindByIndex(e.Args[1]),1);
			if(netcmd == "move_weapinv" ) plr.moveWeaponToInv(e.Args[0]);
			if(netcmd == "equip_structinvweap") plr.equipStructInv(e.Args[0]+1,plr.hardpoints.FindByIndex(e.Args[1]),1);
			if(netcmd == "movestruct_weapinv") plr.moveStructToInv(e.Args[0],1);
			if(netcmd == "items_getlist") plr.GetAllItems(plr.shopitems);
			if(netcmd == "mechs_getlist") plr.GetAllMechs(plr.shopmechs);
			if(netcmd == "sort_inv") plr.sortWeaponInv();
			if(netcmd == "sort_mechs") plr.SortMechs(plr.inv_context.mechs);
			if(netcmd == "throttledecay_toggle") 
			{
				CVar throtd = CVar.FindCVar("mwd_throttledecay");
				throtd.SetBool(!throtd.GetBool());
			}
			if(netcmd == "shop_buyitem" ) 
			{
				let item = plr.shopitems[e.Args[0]];
				if(item) 
				{
					plr.adjustMoney(-e.Args[1]);
					plr.addWeaponToInv(item.Tag);
				}
			}
			if(netcmd == "shop_buymech" ) 
			{
				let mech = plr.shopmechs[e.Args[0]];
				if(mech)
				{
					let defs = GetDefaultByType(mech.baseclass);
					plr.inv_context.mechs.Push(plr.CreateStoredMech(mech.baseclass));
					// console.printf("Obtained: %s [MECHBAY#%d]", defs.getClassName(), plr.inv_context.mechs.Size()-1);
					plr.adjustMoney(-e.Args[1]);
				}
				
			}
			if(netcmd == "remove_inv")
			{
				class<Mechbase_Weapon>  witem = plr.inv_context.weapon_items[e.Args[0]].Tag;
				class<Mechbase_Utility> uitem = plr.inv_context.weapon_items[e.Args[0]].Tag;
				class<Mechbase_Engine>  eitem = plr.inv_context.weapon_items[e.Args[0]].Tag;
				
				if(uitem) plr.adjustMoney(GetDefaultByType(uitem).worth);
				if(witem) plr.adjustMoney(GetDefaultByType(witem).worth);
				if(eitem) plr.adjustMoney(Mechbase_Engine.GetRealWorth(eitem));
				plr.inv_context.RemoveItem(e.Args[0],1);
			}
			if(netcmd == "sell_mech")
			{
				let mech = plr.inv_context.mechs[e.Args[0]];
				if(mech) 
				{
					double value = GetDefaultByType(mech.baseclass).worth/2;
					plr.RemoveInventory(mech.inv_context);
					plr.inv_context.mechs.delete(e.Args[0]);
					plr.adjustMoney(value);
				}
			}
			
			if(netcmd == "iamspaceatandt") 
			{
				plr.adjustMoney(e.Args[0]);
				console.printf("Obtained: %d cbills from a totally legitimate source.", e.Args[0]);
			}
			
			if(netcmd == "+mwd_user5")plr.btn_userfive = true;
			if(netcmd == "-mwd_user5")plr.btn_userfive = false;
			if(netcmd == "+mwd_pilotlook" && plr.modelcockpit && !plr.dronecam) plr.pilotlook = true;
			if(netcmd == "-mwd_pilotlook")plr.pilotlook = false;
			Array<String> netcmds;
			netcmds.Clear();
			netcmd.split(netcmds,":");
			// Objective netevents
			if(netcmds[0] == "objective")
			{
				if(netcmds[1] == "add")
				{
					if(e.IsManual) console.printf("Objective added : \"%s\"",netcmds[2]);
					plr.AddObjective(netcmds[2],netcmds[3].ToInt(),netcmds[4].ToInt());
				}
				if(netcmds[1] == "clear") 
					plr.ClearObjectives();
					
				if(netcmds[1] == "complete") 
				{
					let obj = plr.GetObjective(netcmds[2].ToInt());
					if(obj) obj.completed = true;
				}
				if(netcmds[1] == "fail") 
				{
					let obj = plr.GetObjective(netcmds[2].ToInt());
					if(obj)
					{
						obj.completed = false;
						obj.failed = true;
					}
				}
			}
			if(netcmds[0] == "givemech")
			{
				class<MechWarrior> mech = netcmds[1];
				if(mech)
				{
					plr.inv_context.mechs.Push(plr.CreateStoredMech(mech));
					console.printf("Obtained: %s [MECHBAY#%d]", netcmds[1], plr.inv_context.mechs.Size()-1);
				}
				else
				{
					console.printf("Unknown mech type \"%s\"", netcmds[1]);
				}
			}
			if(netcmds[0] == "autil_useitem") plr.ActivateArmorUtility(netcmds[1],e.Args[0]);
			if(netcmds[0] == "debug_dmg")
			{
				plr.ProcessHardpointDamage(netcmds[1],10);
			}
			if(netcmds[0] == "giveinvbutton")
			{
				class<Inventory> item = netcmds[1];
				if(item && (item is "I_Boolean"))
				{
					plr.GiveInventory(item,1);
				}
				else
				{
					console.printf("No such button, %s!", netcmds[1]);
				}
			}
			if(netcmds[0] == "mechsetgroup")
			{
				int amt = (netcmds[1].CharCodeAt(0))-48;
				plr.GiveInventory("IBTN_SETWEAPGRP",amt);
			}
			if(netcmds[0] == "giveweapon")
			{
				class<Mechbase_Weapon> mweap = netcmds[1];
				class<Mechbase_Utility> mutil = netcmds[1];
				if(mweap || mutil)
				{
					console.printf("Obtained: " .. netcmds[1]);
					plr.addWeaponToInv(netcmds[1]);
				}
				else
				{
					console.printf("Weapon not of type \"Mechbase_Weapon\" or \"Mechbase_Utility\"");
				}
			}
		}
	}	
}

// Real-Time/Shader EventHandler (By Cherno)
class ColorTintShaderManager : StaticEventHandler
{
	//map running time. 
	//We use a custom variable instead of relying on level.time
	//because we only want the timer to increasewhen the game is not paused
	int timer;
	
	//keeps track to the time that has passed since starting a transition,
	//either from 0 to transTimerMax when activing Image Enhancement,
	//or from transTimerMax to 0 when deactivating.
	int transTimer;
	
	//the speed of the transition in tics. may never be 0 or we get a divide by zero error!
	const transTimerMax = 20;
	
	//is image enhancement activated (on)? when sweitched from on to off, or vice versa, the transitioning will start
	int imageEnhancementOn;
	bool resetInfrared;
	
	//the transitioning progress, normalized between 0.0 and 1.0
	double transFrac;
	
	//since we can't have Vector3 constants, these are the red, green and blue color values for the image enhancement effect.
	const imageEnhancementColorR = 10.0;
	const imageEnhancementColorG = 3.0;
	const imageEnhancementColorB = 0.0;
	
	override void WorldTick()
	{
		//Update the ColorTint shader so it gets the current map time
		Shader.SetUniform1f(players[consoleplayer], "ColorTint", "timer", timer);
		transFrac = double(transTimer) / transTimerMax;
		if(imageEnhancementOn == true && transTimer <= transTimerMax)
		{
			Vector3 tintColor2 = (imageEnhancementColorR,imageEnhancementColorG,imageEnhancementColorB) * transFrac;
			Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", tintColor2 );
			transTimer++;	
		}
		else if(imageEnhancementOn == false && transTimer >= 0)
		{
			Vector3 tintColor2 = (imageEnhancementColorR,imageEnhancementColorG,imageEnhancementColorB) * transFrac;
			Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", tintColor2 );
			transTimer--;
		}	
		timer++;
	}

	//reset the image enhancement effect when existing or starting a map
	override void WorldLoaded(WorldEvent e)
	{
		timer = 0;
		if(!e.IsSaveGame) 
			resetInfrared = true;
		else
			transTimer = 0;
		Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", (0.0,0.0,0.0) );
	}
	
	override void WorldUnloaded(WorldEvent e)
	{
		timer = 0;
		if(!e.IsSaveGame) 
			resetInfrared = true;
		else
			transTimer = 0;
		Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", (0.0,0.0,0.0) );
	}
}

