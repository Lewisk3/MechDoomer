
class MechDoomerEvents : EventHandler 
{
	ColorTintShaderManager ShaderManager;
	ui Mechlab_Menu mechlab;
	
	ui void PrintException(String fmt, int xoffs=0, int yoffs=0)
	{	
		MD_SBS.DrawString(
			"BigFont", fmt, 
			(xoffs-880, yoffs-300),
			MD_SBS.SS_SCREEN_CENTER, Font.CR_RED
		);
	}
	
	override void RenderOverlay(RenderEvent e)
	{
		// NOTE: vid_rendermode does not exist in LZDoom, apparently.
		CVar rendermode = CVar.FindCVar("vid_rendermode");
		if(rendermode && rendermode.GetInt() != 4)
		{
			Color dimcol = Color(0,0,0,0);
			Screen.Dim(dimcol,1.0,0,0,Screen.GetWidth(),Screen.GetHeight());
			PrintException("Please switch Render modes!\nThe only render mode supported currently is Hardware Accelerated.\nOpen the console and type vid_rendermode 4 or set it in \"Set Video Mode\"");
			return;
		}
		
		let plr = Mechwarrior(e.Camera);
		NAVPoint nav;
		CVar target_mode;		
		
		if(!plr) 
		{
			let cam = MechCockpitCamera(e.Camera);
			if(cam) plr = Mechwarrior(cam.mechowner);
		}
		
		if(plr) 
		{
			target_mode = CVar.GetCVar("mwd_viewport_target",plr.player);	
			nav = NAVPoint(plr.targetenemy);
		}
		if(nav && !automapactive)
		{
			let proj = MD_SBS.GetRenderEventViewProj(e);
			bool front;
			vector2 ptarget;
			[front, ptarget] = MD_SBS.GetActorHUDPos(proj, nav, 0,0,nav.height*2);
			vector2 distscale = (0.15,0.15);
			distscale *= plr.Distance2D(nav)/1200.;
			distscale.x = clamp(distscale.x, 0.15, 0.25);
			distscale.y = clamp(distscale.y, 0.15, 0.25);
			if(front) 
				MD_SBS.DrawImage("NAV", ptarget, 0, 1.0, distscale, absolute:true);
		}
		
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		if( !automapactive && plr && plr.targetenemy && 
			!nav && target_mode.getBool() )
		{
			double fovH = (e.camera.player != NULL) ? e.camera.player.FOV : e.camera.cameraFOV;
			mwd_Matrix worldToClip = mwd_Matrix.worldToClip(e.viewPos, e.viewAngle, e.viewPitch, e.viewRoll, fovH);
			Actor projActor = plr.targetenemy;
			double projRadius = projActor.radius;
			double projHeight = projActor.height;
			double bottom = 0;
			double top = projHeight;
			if(projActor is "MechHitbox")
			{
				let hbox = MechHitBox(projActor);
				if(projActor)
				{
					let mech = Mechwarrior(hbox.mech);
					projRadius = mech.mech_radius;
					projHeight = mech.mech_height;
					bottom = mech.pos.z-projActor.pos.z;
					top = projHeight;
				}
			}
			if (plr && projActor) 
			{
				// this moves the position of the actor into absolute coordinates relative to the viewPos
				// (which the view matrix is expecting)
				Vector3 adjustedWorldPos = e.viewPos + LevelLocals.vec3Diff(e.viewPos, projActor.pos);
				
				Vector3 positions[8];
				positions[0] = (adjustedWorldPos + ( projRadius,  projRadius, bottom    ));
				positions[1] = (adjustedWorldPos + (-projRadius,  projRadius, bottom    ));
				positions[2] = (adjustedWorldPos + ( projRadius, -projRadius, bottom    ));
				positions[3] = (adjustedWorldPos + (-projRadius, -projRadius, bottom    ));
				positions[4] = (adjustedWorldPos + ( projRadius,  projRadius, top		));
				positions[5] = (adjustedWorldPos + (-projRadius,  projRadius, top		));
				positions[6] = (adjustedWorldPos + ( projRadius, -projRadius, top		));
				positions[7] = (adjustedWorldPos + (-projRadius, -projRadius, top		));
				
				Vector3 ndcPositions[8];
				// ndcCounter tracks how many valid ndcPositions were found, if it's not 8 by the end of the loop then
				// we won't draw anything
				int ndcCounter = 0;
				bool anyOnScreen = false;
				for (int i = 0; i < 8; i++) 
				{
					Vector3 worldPos = positions[i];
					Vector3 ndcPos = worldToClip.multiplyVector3(worldPos).asVector3();
					
					if (ndcPos.x <= 1 && ndcPos.x >= -1 &&
						ndcPos.y <= 1 && ndcPos.y >= -1   ) anyOnScreen = true;
					if (ndcPos.z <= 1 && ndcPos.z >= -1) 
					{
						ndcCounter++;
						ndcPositions[i] = ndcPos;
					}
				}
				
				if (anyOnScreen && ndcCounter >= 8) 
				{
					// the infinities are used here since any real number will be automatically lower/higher than infinity/-infinity
					double lowestX  =  double.infinity;
					double lowestY  =  double.infinity;
					double highestX = -double.infinity;
					double highestY = -double.infinity;
					
					// create a bounding box from the projected positions
					for (int i = 0; i < 8; i++) 
					{
						Vector2 ndc = ndcPositions[i].xy;
						if (ndc.x < lowestX ) lowestX  = ndc.x;
						if (ndc.y < lowestY ) lowestY  = ndc.y;
						if (ndc.x > highestX) highestX = ndc.x;
						if (ndc.y > highestY) highestY = ndc.y;
					}
					
					Vector3 corners[4];
					corners[0] = (clamp(lowestX , -0.95, 0.95), clamp(lowestY , -0.95, 0.95), 0);
					corners[1] = (clamp(highestX, -0.95, 0.95), clamp(lowestY , -0.95, 0.95), 0);
					corners[2] = (clamp(lowestX , -0.95, 0.95), clamp(highestY, -0.95, 0.95), 0);
					corners[3] = (clamp(highestX, -0.95, 0.95), clamp(highestY, -0.95, 0.95), 0);
					string cornerTextures[4];
					cornerTextures[0] = "RETCC0";
					cornerTextures[1] = "RETCD0";
					cornerTextures[2] = "RETCA0";
					cornerTextures[3] = "RETCB0";
					Vector2 cornerDirs[4];
					cornerDirs[0] = (-1,  1);
					cornerDirs[1] = ( 1,  1);
					cornerDirs[2] = (-1, -1);
					cornerDirs[3] = ( 1, -1);
					
					for (int i = 0; i < 4; i++) 
					{
						Vector2 viewportPos = mwd_GlobalMaths.ndcToViewPort(corners[i]);
						viewportPos.y -= 15;	
						Screen.drawTexture(TexMan.checkForTexture(cornerTextures[i], TexMan.Type_Any), false, viewportPos.x, viewportPos.y);
					}
				}
			}
		}
		
		// Print distance on HUD space
		// Uses SBS's lesser known 3D features :P
		if(plr && plr.targetenemy && !NAVPoint(plr.targetenemy))
		{
			double mdist = plr.Distance3D(plr.targetenemy)/MWGAMEPLAY_UNITMETER;
			String dist = String.Format("%.0fm", mdist);
			bool infront;
			ViewProjection viewproj = MD_SBS.GetMechViewProj(plr);
			vector2 apos;
			[infront, apos] = MD_SBS.GetActorHUDPos(
				viewproj,
				plr.targetenemy, plr.targetenemy.radius, 0, 0
			);
			if(infront)
			{
				MD_SBS.DrawString3D(
					"MechFont", 
					dist, 
					apos, 0, 
					Font.CR_GOLD, 
					scale:(1.25,1.25),
					distance: e.Camera.Distance2D(plr.targetenemy)
				);
			}
		}
	}
	
	// Whatever, it works. Until it's actually possible to make a toggle switch for UI
	// without using hacky code, i'm not going to bother adjusting this.
	ui int keycache;
	override bool InputProcess(InputEvent e)
	{
		let plr = Mechwarrior(players[consoleplayer].mo);
		Menu m = Menu.GetCurrentMenu();
		if(plr && !plr.uiopen_mechlab) keycache = e.KeyChar;
		if(plr && plr.uiopen_mechlab)
		{
			if (!Mechlab_Menu(m))
			{
				let mechlab = Mechlab_Menu(new('Mechlab_Menu'));
				mechlab.Init(null, plr, keycache);
				mechlab.ActivateMenu();
				return true;
			}
		}
		return false;
	}
		
	override void WorldThingDamaged(WorldEvent e)
	{
		if(!e || !e.Thing || !e.DamageSource) return;
		String ThingHit = e.Thing.GetClassName();
		String SourceName = "UNDEFINED";
	
		// Make sure the damage is coming from the player.
		if (e.DamageSource)
		{SourceName = e.DamageSource.GetClassName();}
		
		// Make names easier to check against.
		SourceName.MakeLower();
		ThingHit.MakeLower();

		int Thinghealth = e.Thing.SpawnHealth();
		int gibhealth = -Thinghealth;
		if (e.Thing.Health <= 0) 
		{
			if(SourceName != "undefined" && e.DamageSource)
			{
				if(MechWarrior(e.DamageSource))
				{
					int amt = max(Thinghealth * 15.60,1);
					MechWarrior(e.DamageSource).adjustMoney(amt);
				}
			}
		}
	}

	override void WorldLoaded(WorldEvent e)
	{
		// Check the map for its own NAV points, if they don't exist
		// create NAV Alpha at the start of the map.
		PlayerPawn plr = players[consoleplayer].mo;
		if(!plr) return;
		
		double spawnangle = plr.angle;
		vector3 spawnpos = plr.pos;
		if(!NAVPoint.NextNAV(NAVPoint.ALPHA))
		{
			let nav = Actor.Spawn("NAV_Alpha", spawnpos);
			if(nav) nav.angle = spawnangle;
		}
	}
	
	override void WorldTick()
	{
		let plr = MechWarrior(players[consoleplayer].mo);
		
		/* Debug pickup-able anomalies. *\
		let it = ThinkerIterator.Create("Inventory");
		Actor act;
		while(act = Actor(it.Next()))
		{
			if( !(act is "Item_NoPickup") && plr.Distance3D(act) <= 16) console.printf("Pickup-able Inv: %s", act.getClassName());
		}
		*/
		
		// Hitbox debugging
		let it = ThinkerIterator.Create();
		Actor act;
		while(act = Actor(it.Next()))
		{
			if(!act.bSHOOTABLE) continue;
			bool hasdebug = act.FindInventory("RadiusDebugMe")!=NULL;
			if(mwd_debug_hitboxes && !hasdebug && !(act is "Mechwarrior")) 
			{
				RadiusDebug.Enable(act);
			}
			if(!mwd_debug_hitboxes && hasdebug)
			{
				RadiusDebug.Disable(act);
			}
		}
		
		if(!plr)
		{
			let newplr = players[consoleplayer].mo;
			if(!newplr) return;
			
			// What a "classy" state name, mark... 
			State brutal_edgydoomer = newplr.FindState("Death.Rape",true);
			if(brutal_edgydoomer && !newplr.FindInventory("DishonorBoolean")) 
			{
				let whyudothis = DishonorablePlayer(Actor.Spawn("DishonorablePlayer", newplr.pos));
				if(whyudothis)
				{
					whyudothis.edgyboi = newplr;
					newplr.GiveInventory("DishonorBoolean", 1);
				}
			}
		}
				
		if(!ShaderManager)
			ShaderManager = ColorTintShaderManager(StaticEventHandler.Find("ColorTintShaderManager"));
		else if(plr)
		{
			if(ShaderManager.resetInfrared)
			{
				plr.InfraredActive = false;
				ShaderManager.resetInfrared = false;
			}
			ShaderManager.imageEnhancementOn = plr.InfraredActive;
		}
	}
		
	override void NetworkProcess(ConsoleEvent e)
	{
		String netcmd = e.Name;
		let def_plr = PlayerPawn(players[e.Player].mo);
		let plr = MechWarrior(def_plr);
		
		// Unspecific netevents
		if(def_plr || plr)
		{
			// Command+Args
			Array<String> netcmds;
			netcmds.Clear();
			netcmd.split(netcmds,":");
			if(netcmds[0] == "destroy_object")
			{
				// Objective netevents
				class<Object> thing = netcmds[1];
				if(thing)
				{
					int count = 0;
					let objIt = ThinkerIterator.Create("Object");
					Object FoundObj;
					while(FoundObj = objIt.Next())
					{
						if(FoundObj is thing) 
						{
							FoundObj.Destroy();
							count++;
						}
					}
					console.printf("\c[Red]Destroyed \c[White]%d \c[Blue]Objects \c[White]of type \c[Green]\"%s\"", count, netcmds[1]);
				}
			}
		}
		
		if(plr)
		{
			if(netcmd == "screen_setfadecolor") plr.screen_fadecolor = Color(255, e.Args[0],e.Args[1],e.Args[2]);
			if(netcmd == "screen_setfade") 
			{
				plr.screen_fade = e.Args[0]/255.0;
			}
			// Process mechlab netevents	
			if(netcmd ==  "open_mechlab") plr.uiopen_mechlab = true;
			if(netcmd == "close_mechlab") plr.uiopen_mechlab = false;
			
			if(netcmd == "screen_toggleinfrared") 
			{
				if(ShaderManager)
				{
					plr.InfraredActive = !plr.InfraredActive;
					ShaderManager.imageEnhancementOn = plr.InfraredActive;
					if(plr.InfraredActive) 
					{
						plr.mechSounds.pushSound("Mech/Betty/LightAmp");
						plr.mechSounds.pushSound("Mech/Betty/Engaged");
						plr.S_StartSound("Mech/Infrared",CHAN_WEAPON);
					}
				}
			}
			if(netcmd == "cycle_navpoint") 
			{
				int curnav = NAVPoint.ALPHA-1;
				NAVPoint TargetNAV = NAVPoint(plr.targetenemy);
				if(TargetNAV) curnav = TargetNAV.SEQ;
				NAVPoint nav = NAVPoint.NextNAV(curnav);
				if(nav) plr.targetenemy = nav;
				SoundEmitter.SE_Trigger("Mech/NavBlip",plr.pos);
			}
			if(netcmd == "toggle_ams") 
			{
				if(!plr.CheckHasAMS())
				{
					plr.Cockpit_Alert("\c[GREEN]Not equipped with an AntiMissileSystem.");
				}
				else
				{
					SoundOnActor.Trigger("Mech/Blip",plr);
					String alertmsg = "\c[GREEN] AntiMissileSystems: ";
					plr.ams_passive = !plr.ams_passive;	
					if(!plr.ams_passive) 
						alertmsg = alertmsg.."Disabled.";
					else
						alertmsg = alertmsg.."Enabled.";
					plr.Cockpit_Alert(alertmsg);
				}
			}
			if(netcmd == "hud_toggle_htal") 
			{
				SoundOnActor.Trigger("Mech/Blip",plr);
				plr.hud_htal = !plr.hud_htal;
			}
			if(netcmd == "hud_resetanimflags") plr.hAlert.hud_powersequence = 0;
			if(netcmd == "toggle_autopilot") plr.ToggleAutopilot();
			if(netcmd == "toggle_objectives") plr.display_objectives = !plr.display_objectives;
			if(netcmd == "exchange_mech" && plr.inv_context.mechs.Size() >= e.Args[0]) plr.StartMechChange(e.Args[0]);
			if(netcmd == "engine_dequip" && plr.inv_context.engine) plr.DequipEngine();
			if(netcmd == "dronebackchase" && !plr.isdead && !plr.pilotlook && !plr.mech_shutdown) plr.ToggleDrone(200,0,15,false);
			if(netcmd == "droneviewswitch" && !plr.isdead) 
			{
				if(!plr.dronecam) plr.ToggleDrone(200,0,15,false);
				plr.dronecam.frontcam = !plr.dronecam.frontcam;
			}
			if(netcmd == "kill mech") { plr.hardpoints.hd.internalhp = 0; plr.DamageHardpoint(plr.hardpoints.hd, 1); }
			if(netcmd == "repair_hardpoint") plr.repairHardpointStat(e.Args[0],e.Args[1]);
			if(netcmd == "adjust_armor") plr.AdjustMaxArmor(plr.hardpoints.FindByIndex(e.Args[0]),e.Args[1], true);
			if(netcmd == "equip_invweap") plr.equipWeaponInv(e.Args[0]+1,plr.hardpoints.FindByIndex(e.Args[1]),1);
			if(netcmd == "move_weapinv" ) plr.moveWeaponToInv(e.Args[0]);
			if(netcmd == "equip_structinvweap") plr.equipStructInv(e.Args[0]+1,plr.hardpoints.FindByIndex(e.Args[1]),1);
			if(netcmd == "movestruct_weapinv") plr.moveStructToInv(e.Args[0],1);
			if(netcmd == "mechs_getlist") plr.GetAllMechs(plr.shopmechs);
			if(netcmd == "sort_inv") plr.sortWeaponInv();
			if(netcmd == "sort_mechs") plr.SortMechs(plr.inv_context.mechs);
			if(netcmd == "radar_switchrange")
			{
				SoundOnActor.Trigger("Mech/Blip",plr);
				if(plr.radar_scale == 2)
				{
					plr.Cockpit_Alert("\c[GREEN]Radar is hidden.");
				}
				else
				{
					plr.radar_range++;
					if(plr.radar_range > 3) plr.radar_range = 0;
				}
			}
			if(netcmd == "radar_switchscale")
			{
				plr.radar_scale++;
				if(plr.radar_scale > 2) plr.radar_scale = 0;
				SoundOnActor.Trigger("Mech/Blip",plr);
			}
			if(netcmd == "throttledecay_toggle") 
			{
				CVar throtd = CVar.FindCVar("mwd_throttledecay");
				bool bdecay = throtd.GetBool();
				throtd.SetBool(!bdecay);
				
				String alertmsg = "\c[GREEN] Throttle Decay: ";
				if(!bdecay) 
					alertmsg = alertmsg.."Enabled.";
				else
					alertmsg = alertmsg.."Disabled.";
				plr.Cockpit_Alert(alertmsg);
			}
			if(netcmd == "shop_buyitem" && plr.shopitems) 
			{
				let item = plr.shopitems.items[e.Args[0]];
				if(item) 
				{
					plr.adjustMoney(-e.Args[1]);
					plr.addWeaponToInv(item.Tag);
				}
			}
			if(netcmd == "shop_buymech" ) 
			{
				let mech = plr.shopmechs[e.Args[0]];
				if(mech)
				{
					let defs = GetDefaultByType(mech.baseclass);
					plr.inv_context.mechs.Push(plr.CreateStoredMech(mech.baseclass));
					// console.printf("Obtained: %s [MECHBAY#%d]", defs.getClassName(), plr.inv_context.mechs.Size()-1);
					plr.adjustMoney(-e.Args[1]);
				}
				
			}
			if(netcmd == "remove_inv")
			{
				class<Mechbase_Weapon>  witem = plr.inv_context.weapon_items[e.Args[0]].Tag;
				class<Mechbase_Utility> uitem = plr.inv_context.weapon_items[e.Args[0]].Tag;
				class<Mechbase_Engine>  eitem = plr.inv_context.weapon_items[e.Args[0]].Tag;
				
				if(uitem) plr.adjustMoney(GetDefaultByType(uitem).worth);
				if(witem) plr.adjustMoney(GetDefaultByType(witem).worth);
				if(eitem) plr.adjustMoney(Mechbase_Engine.GetRealWorth(eitem));
				plr.inv_context.RemoveItem(e.Args[0],1);
			}
			if(netcmd == "sell_mech")
			{
				let mech = plr.inv_context.mechs[e.Args[0]];
				if(mech) 
				{
					double value = GetDefaultByType(mech.baseclass).worth/2;
					plr.RemoveInventory(mech.inv_context);
					plr.inv_context.mechs.delete(e.Args[0]);
					plr.adjustMoney(value);
				}
			}
			
			if(netcmd == "iamspaceatandt") 
			{
				plr.adjustMoney(e.Args[0]);
				console.printf("Obtained: %d cbills from a totally legitimate source.", e.Args[0]);
			}
			if(netcmd == "commiespaceatandt")
			{
				for(int i = 0; i < MAXPLAYERS; i++)
				{
					if(playeringame[i]) 
					{
						let mplr = MechWarrior(players[i].mo);
						if(mplr)
						{
							mplr.adjustMoney(e.Args[0]);
							console.printf("[Player#%d]:> Received a small loan of %d cbills.", i, e.Args[0]);
						}
					}
				}
			}
			if(netcmd == "restoremechstatus")
			{
				let mplr = MechWarrior(players[e.Args[0]].mo);
				if(!mplr) mplr = plr;
				mplr.isdead = false;
				mplr.player.cheats &= ~CF_TOTALLYFROZEN;
				console.printf("Restored mech status for player #%d", mplr.PlayerNumber()); 
			}	
			if(netcmd == "-mwd_switchammo") plr.btn_switchammo = false;
			if(netcmd == "+mwd_switchammo") plr.btn_switchammo = true;
	
			if(netcmd == "+mwd_user5") plr.btn_jumpjets = true;
			if(netcmd == "-mwd_user5") plr.btn_jumpjets = false;
			if(netcmd == "+mwd_pilotlook" && plr.modelcockpit && !plr.dronecam) plr.pilotlook = true;
			if(netcmd == "-mwd_pilotlook")plr.pilotlook = false;
			Array<String> netcmds;
			netcmds.Clear();
			netcmd.split(netcmds,":");
			if(netcmds[0] == "createmech")
			{
				string type = netcmds[1];
				let mechact = MechwarriorBase(plr.Spawn(type,plr.pos));
				if(mechact)
				{
					mechact.docopy_novoodoo = true;
					mechact.setupInventory();
					mechact.mech_weapons();
					mechact.baseclass = type;
				}
			}
			if(netcmds[0] == "mechlab_alert")
			{
				plr.mechlab_alert("\c[RED]"..netcmds[1]);
				if(netcmds[1] ~== "[reset]") plr.hAlert.mechlab_text = "";
			}
			if(netcmds[0] == "cockpit_alert")
			{
				int msize = plr.hAlert.cockpit_messages.Size();
				if(netcmds[1] ~== "[clear1]") 
				{
					if(msize > 0) plr.hAlert.cockpit_messages[0] = "";
				}
				else if(netcmds[1] ~== "[clear2]") 
				{
					if(msize > 1) plr.hAlert.cockpit_messages[1] = "";
				}
				else if(netcmds[1] ~==  "[reset]") 
				{
					plr.hAlert.cockpit_messages.Clear();
				}
				else
				{
					plr.cockpit_alert("\c[GREEN]"..netcmds[1]);
				}
			}
			// Hardpoint debug
			if(netcmds[0] == "damage_hardpoint")
			{
				Name type = netcmds[1];
				double dmg = netcmds[2].ToDouble();
				MechHardpoint dhp;
				switch (type)
				{
					case 'hd': {dhp = plr.hardpoints.hd; break;}
					case 'ct': {dhp = plr.hardpoints.ct; break;}
					case 'lt': {dhp = plr.hardpoints.lt; break;}
					case 'rt': {dhp = plr.hardpoints.rt; break;}
					case 'la': {dhp = plr.hardpoints.la; break;}
					case 'ra': {dhp = plr.hardpoints.ra; break;}
					case 'll': {dhp = plr.hardpoints.ll; break;}
					case 'rl': {dhp = plr.hardpoints.rl; break;}
					default: break;
				}
				if(dhp) plr.DamageHardpoint(dhp, dmg);
			}
			// Objective netevents
			if(netcmds[0] == "objective")
			{
				if(netcmds[1] == "add")
				{
					if(e.IsManual) console.printf("Objective added : \"%s\"",netcmds[2]);
					plr.AddObjective(netcmds[2],netcmds[3].ToInt(),netcmds[4].ToInt());
				}
				if(netcmds[1] == "clear") 
					plr.ClearObjectives();
					
				if(netcmds[1] == "complete") 
				{
					let obj = plr.GetObjective(netcmds[2].ToInt());
					if(obj) obj.completed = true;
				}
				if(netcmds[1] == "fail") 
				{
					let obj = plr.GetObjective(netcmds[2].ToInt());
					if(obj)
					{
						obj.completed = false;
						obj.failed = true;
					}
				}
			}
			if(netcmds[0] == "givemech")
			{
				class<MechWarrior> mech = netcmds[1];
				if(mech)
				{
					plr.inv_context.mechs.Push(plr.CreateStoredMech(mech));
					console.printf("Obtained: %s [MECHBAY#%d]", netcmds[1], plr.inv_context.mechs.Size()-1);
				}
				else
				{
					console.printf("Unknown mech type \"%s\"", netcmds[1]);
				}
			}
			if(netcmds[0] == "autil_useitem") plr.ActivateArmorUtility(netcmds[1],e.Args[0]);
			if(netcmds[0] == "debug_dmg")
			{
				plr.ProcessHardpointDamage(netcmds[1],10);
			}
			if(netcmds[0] == "giveinvbutton")
			{
				class<Inventory> item = netcmds[1];
				if(item && (item is "I_Boolean"))
				{
					plr.GiveInventory(item,1);
				}
				else
				{
					console.printf("No such button, %s!", netcmds[1]);
				}
			}
			if(netcmds[0] == "mechsetgroup")
			{
				int amt = (netcmds[1].ByteAt(0))-48;
				plr.GiveInventory("IBTN_SETWEAPGRP",amt);
			}
			if(netcmds[0] == "giveweapon")
			{
				class<Mechbase_Weapon> mweap = netcmds[1];
				class<Mechbase_Utility> mutil = netcmds[1];
				if(mweap || mutil)
				{
					console.printf("Obtained: " .. netcmds[1]);
					plr.addWeaponToInv(netcmds[1]);
				}
				else
				{
					console.printf("Weapon not of type \"Mechbase_Weapon\" or \"Mechbase_Utility\"");
				}
			}
		}
	}	
}

// Real-Time/Shader EventHandler (By Cherno)
class ColorTintShaderManager : StaticEventHandler
{
	//map running time. 
	//We use a custom variable instead of relying on level.time
	//because we only want the timer to increasewhen the game is not paused
	int timer;
	
	//keeps track to the time that has passed since starting a transition,
	//either from 0 to transTimerMax when activing Image Enhancement,
	//or from transTimerMax to 0 when deactivating.
	int transTimer;
	
	//the speed of the transition in tics. may never be 0 or we get a divide by zero error!
	const transTimerMax = 20;
	
	//is image enhancement activated (on)? when sweitched from on to off, or vice versa, the transitioning will start
	int imageEnhancementOn;
	bool resetInfrared;
	
	//the transitioning progress, normalized between 0.0 and 1.0
	double transFrac;
	
	//since we can't have Vector3 constants, these are the red, green and blue color values for the image enhancement effect.
	const imageEnhancementColorR = 10.0;
	const imageEnhancementColorG = 3.0;
	const imageEnhancementColorB = 0.0;
	
	override void WorldTick()
	{
		//Update the ColorTint shader so it gets the current map time
		Shader.SetUniform1f(players[consoleplayer], "ColorTint", "timer", timer);
		transFrac = double(transTimer) / transTimerMax;
		if(imageEnhancementOn == true && transTimer <= transTimerMax)
		{
			Vector3 tintColor2 = (imageEnhancementColorR,imageEnhancementColorG,imageEnhancementColorB) * transFrac;
			Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", tintColor2 );
			transTimer++;	
		}
		else if(imageEnhancementOn == false && transTimer >= 0)
		{
			Vector3 tintColor2 = (imageEnhancementColorR,imageEnhancementColorG,imageEnhancementColorB) * transFrac;
			Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", tintColor2 );
			transTimer--;
		}	
		timer++;
	}

	//reset the image enhancement effect when existing or starting a map
	override void WorldLoaded(WorldEvent e)
	{
		timer = 0;
		if(!e.IsSaveGame) 
			resetInfrared = true;
		else
			transTimer = 0;
		Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", (0.0,0.0,0.0) );
	}
	
	override void WorldUnloaded(WorldEvent e)
	{
		timer = 0;
		if(!e.IsSaveGame) 
			resetInfrared = true;
		else
			transTimer = 0;
		Shader.SetUniform3f( players[consoleplayer], "ColorTint", "tintColor2", (0.0,0.0,0.0) );
	}
}

