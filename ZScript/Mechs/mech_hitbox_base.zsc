class MechHitbox : Actor
{
	MechHardpoint mounted_hp;
	Mechwarrior mech;
	double xoffs, yoffs, forward;
	double curangle, curpitch;
	
	Default
	{
		Health int.max;
		+SHOOTABLE;
		+NOGRAVITY;
		+NOBLOOD;
		+NORADIUSDMG;
		Radius 5;
		Height 5;
	}
		
	static MechHitBox SetupHitbox(Mechwarrior basemech, MechHardpoint mountpoint)
	{
		let box = MechHitBox(Actor.Spawn("MechHitbox", basemech.pos));
		if(box)
		{
			box.A_SetSize(mountpoint.hitbox_info.radius, mountpoint.hitbox_info.height);
			box.xoffs = mountpoint.hitbox_info.xoffs;
			box.yoffs = mountpoint.hitbox_info.yoffs;
			box.forward = mountpoint.hitbox_info.forward;
			box.mech = basemech;
			box.mounted_hp = mountpoint;
			mountpoint.hitbox = box;
		}
		return box;
	}
	 
	override int DamageMobJ(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if( (source is "Mechbase_Weapon") || (inflictor is "Mechbase_Weapon") ) return 0;
		DamageMech(inflictor, source, damage, angle);
		return 0;
	}
	
	// Custom damage routine which will handle non-int damage.
	virtual void DamageMech(Actor inflictor, Actor source, double damage, double angle)
	{
		// Damage fail conditions.
		if(!mech || mech.checkVoodoo() || !mounted_hp || Mechwarrior(inflictor) == mech || Mechwarrior(source) == mech || damage == 0) 
			return;
		
		// Take no damage directly, instead redirect to hardpoint.
		Actor damager = inflictor;
		let mechweap = Mechbase_Actor(inflictor);
		double realdamage = mechweap ? mechweap.truedamage : damage;
		bool mechdmg = (inflictor is "Mechwarrior") || (source is "Mechwarrior");
		double newdmg = mechdmg ? (realdamage*0.5) : (realdamage*MWGAMEPLAY_DAMAGESCALE);
		
		// Take a bit less damage from AI
		if(mechdmg && Mechwarrior(source).checkAI()) newdmg = realdamage*0.5;
		
		// Take more damage if we are AI
		if(mech.checkAI()) newdmg = realdamage;
		
		mech.DamageHardpoint(mounted_hp, newdmg, false, damager);
		return;
	}
	
	bool CheckTorsoMount()
	{
		return (mounted_hp != mech.hardpoints.ll) && (mounted_hp != mech.hardpoints.rl);
	}
	
	override void Tick()
	{
		super.Tick();
		if(!mech || !mech.models_reference) 
		{
			Destroy();
			return;
		}
		double truecockpit = mech.angle;
		if(mech.models_reference.cockpit && mech.player) 
			truecockpit = mech.models_reference.cockpit.angle;

		if(!mounted_hp) return;
		double offsangle = CheckTorsoMount() ? truecockpit : mech.LegAng;
		double offspitch = CheckTorsoMount() ? mech.models_reference.roll*-MDMath.Sign(xoffs) : 0;
		vector3 offs = MDMath.VOffsetPitch(offsangle,offspitch, forward, xoffs, 1);	
		Vector3 finalpos = mech.Vec3Offset(offs.x,offs.y,yoffs+(offs.z*18));
		curangle = offsangle;
		curpitch = offspitch;
		SetOrigin(finalpos, false);
	}
	
	States
	{
		Spawn:
			TNT1 A 1;
		loop;
	}
}
