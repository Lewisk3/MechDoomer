	/*************************\
	|	  Hardpoint System    |
	\*************************/
extend class MechWarriorBase;
	
// Initialize
void setupHardpoints(Vector2 hd, Vector2 ct, Vector2 rt, Vector2 lt, Vector2 la, Vector2 ra, Vector2 ll, Vector2 rl)
{
	// Setup weapon location hardpoints and hardpoint slots.
	inv_context.hardpoints.hd.pos = hd;
	inv_context.hardpoints.ct.pos = ct;
	inv_context.hardpoints.lt.pos = lt;
	inv_context.hardpoints.rt.pos = rt;
	inv_context.hardpoints.la.pos = la;
	inv_context.hardpoints.ra.pos = ra;
	inv_context.hardpoints.ll.pos = ll;
	inv_context.hardpoints.rl.pos = rl;
}
void setupHardpointVitals(int hda,int cta,int lta,int rta,int laa,int raa,int lla,int rla,int hdi,int cti,int lti,int rti,int lai,int rai,int lli,int rli)
{
	// This looks really messy but idk what else i can do.
	inv_context.hardpoints.hd.max_armor = hda;
	inv_context.hardpoints.ct.max_armor = cta;
	inv_context.hardpoints.lt.max_armor = lta;
	inv_context.hardpoints.rt.max_armor = rta;
	inv_context.hardpoints.la.max_armor = laa;
	inv_context.hardpoints.ra.max_armor = raa;
	inv_context.hardpoints.ll.max_armor = lla;
	inv_context.hardpoints.rl.max_armor = rla;
	inv_context.hardpoints.hd.armor = hda;
	inv_context.hardpoints.ct.armor = cta;
	inv_context.hardpoints.lt.armor = lta;
	inv_context.hardpoints.rt.armor = rta;
	inv_context.hardpoints.la.armor = laa;
	inv_context.hardpoints.ra.armor = raa;
	inv_context.hardpoints.ll.armor = lla;
	inv_context.hardpoints.rl.armor = rla;
	inv_context.hardpoints.hd.max_internal = hdi;
	inv_context.hardpoints.ct.max_internal = cti;
	inv_context.hardpoints.lt.max_internal = lti;
	inv_context.hardpoints.rt.max_internal = rti;
	inv_context.hardpoints.la.max_internal = lai;
	inv_context.hardpoints.ra.max_internal = rai;
	inv_context.hardpoints.ll.max_internal = lli;
	inv_context.hardpoints.rl.max_internal = rli;
	inv_context.hardpoints.hd.internalhp = hdi;
	inv_context.hardpoints.ct.internalhp = cti;
	inv_context.hardpoints.lt.internalhp = lti;
	inv_context.hardpoints.rt.internalhp = rti;
	inv_context.hardpoints.la.internalhp = lai;
	inv_context.hardpoints.ra.internalhp = rai;
	inv_context.hardpoints.ll.internalhp = lli;
	inv_context.hardpoints.rl.internalhp = rli;
}
void setupHardpointSlots(int hds=10,int cts=12,int rts=12, int lts=12, int las=12,int ras=12, int lls=2,int rls=2)
{
	inv_context.hardpoints.hd.maxslots = hds;
	inv_context.hardpoints.hd.slots = getWeaponSlotsUsed(inv_context.hardpoints.hd.pos);
	inv_context.hardpoints.ct.maxslots = cts;
	inv_context.hardpoints.ct.slots = getWeaponSlotsUsed(inv_context.hardpoints.ct.pos);
	inv_context.hardpoints.rt.maxslots = rts;
	inv_context.hardpoints.rt.slots = getWeaponSlotsUsed(inv_context.hardpoints.rt.pos);
	inv_context.hardpoints.lt.maxslots = lts;
	inv_context.hardpoints.lt.slots = getWeaponSlotsUsed(inv_context.hardpoints.lt.pos);
	inv_context.hardpoints.la.maxslots= las;
	inv_context.hardpoints.la.slots = getWeaponSlotsUsed(inv_context.hardpoints.la.pos);
	inv_context.hardpoints.ra.maxslots = ras;
	inv_context.hardpoints.ra.slots = getWeaponSlotsUsed(inv_context.hardpoints.ra.pos);
	inv_context.hardpoints.ll.maxslots = lls;
	inv_context.hardpoints.ll.slots = getWeaponSlotsUsed(inv_context.hardpoints.ll.pos);
	inv_context.hardpoints.rl.maxslots = rls;
	inv_context.hardpoints.rl.slots = getWeaponSlotsUsed(inv_context.hardpoints.rl.pos);
	// Setup criticals
	if(MoveSpeedKPH > 64)
	{
		equipStruct("StructEngine",inv_context.hardpoints.lt.pos);
		equipStruct("StructEngine",inv_context.hardpoints.rt.pos);	
	}
	if(MoveSpeedKPH > 81) equipStruct("StructEngine",inv_context.hardpoints.ct.pos);	
	equipStruct("StructGyro",inv_context.hardpoints.hd.pos);
	equipStruct("StructLifesupport",inv_context.hardpoints.hd.pos);
	equipStruct("StructSensors",inv_context.hardpoints.hd.pos);
	equipStruct("StructCockpit",inv_context.hardpoints.hd.pos);
	equipStruct("StructHip",inv_context.hardpoints.lt.pos);
	equipStruct("StructHip",inv_context.hardpoints.rt.pos);
	equipStruct("StructActuator",inv_context.hardpoints.la.pos);
	equipStruct("StructActuator",inv_context.hardpoints.ra.pos);
	equipStruct("StructEngine",inv_context.hardpoints.ct.pos);
	equipStruct("StructEngine",inv_context.hardpoints.ct.pos);
	equipStruct("StructGyro",inv_context.hardpoints.ct.pos);
	equipStruct("StructGyro",inv_context.hardpoints.ct.pos);
}

// Get
clearscope int getFreeSlots()
{
	int slots = 0;
	slots += (inv_context.hardpoints.hd.maxslots-inv_context.hardpoints.hd.slots);
	slots += (inv_context.hardpoints.ct.maxslots-inv_context.hardpoints.ct.slots);
	slots += (inv_context.hardpoints.lt.maxslots-inv_context.hardpoints.lt.slots);
	slots += (inv_context.hardpoints.rt.maxslots-inv_context.hardpoints.rt.slots);
	slots += (inv_context.hardpoints.la.maxslots-inv_context.hardpoints.la.slots);
	slots += (inv_context.hardpoints.ra.maxslots-inv_context.hardpoints.ra.slots);
	slots += (inv_context.hardpoints.ll.maxslots-inv_context.hardpoints.ll.slots);
	slots += (inv_context.hardpoints.rl.maxslots-inv_context.hardpoints.rl.slots);
	
	return slots;
}
int checkHardslots(Vector2 pos)
{
	int slots = 0;
	if(pos == inv_context.hardpoints.hd.pos) slots = (inv_context.hardpoints.hd.maxslots-inv_context.hardpoints.hd.slots);
	if(pos == inv_context.hardpoints.ct.pos) slots = (inv_context.hardpoints.ct.maxslots-inv_context.hardpoints.ct.slots);
	if(pos == inv_context.hardpoints.lt.pos) slots = (inv_context.hardpoints.lt.maxslots-inv_context.hardpoints.lt.slots);
	if(pos == inv_context.hardpoints.rt.pos) slots = (inv_context.hardpoints.rt.maxslots-inv_context.hardpoints.rt.slots);
	if(pos == inv_context.hardpoints.la.pos) slots = (inv_context.hardpoints.la.maxslots-inv_context.hardpoints.la.slots);
	if(pos == inv_context.hardpoints.ra.pos) slots = (inv_context.hardpoints.ra.maxslots-inv_context.hardpoints.ra.slots);
	if(pos == inv_context.hardpoints.ll.pos) slots = (inv_context.hardpoints.ll.maxslots-inv_context.hardpoints.ll.slots);
	if(pos == inv_context.hardpoints.rl.pos) slots = (inv_context.hardpoints.rl.maxslots-inv_context.hardpoints.rl.slots);
	return slots;
}
clearscope vector2 getHardpointSlots(int ind)
{
	// I have to use internal structures here such as vector2 instead of my own struct
	// due to pointer issues.
	vector2 hslots = ( 0, 0 );
	if(ind == 0) hslots = (inv_context.hardpoints.hd.maxslots, inv_context.hardpoints.hd.slots);
	if(ind == 1) hslots = (inv_context.hardpoints.ct.maxslots, inv_context.hardpoints.ct.slots);
	if(ind == 2) hslots = (inv_context.hardpoints.lt.maxslots, inv_context.hardpoints.lt.slots);
	if(ind == 3) hslots = (inv_context.hardpoints.rt.maxslots, inv_context.hardpoints.rt.slots);
	if(ind == 4) hslots = (inv_context.hardpoints.la.maxslots, inv_context.hardpoints.la.slots);
	if(ind == 5) hslots = (inv_context.hardpoints.ra.maxslots, inv_context.hardpoints.ra.slots);
	if(ind == 6) hslots = (inv_context.hardpoints.ll.maxslots, inv_context.hardpoints.ll.slots);
	if(ind == 7) hslots = (inv_context.hardpoints.rl.maxslots, inv_context.hardpoints.rl.slots);
	return hslots;
}
clearscope vector2 getHardpointPos(int ind)
{
	vector2 hpos = ( 0, 0 );
	if(ind == 0) hpos = inv_context.hardpoints.hd.pos;
	if(ind == 1) hpos = inv_context.hardpoints.ct.pos;
	if(ind == 2) hpos = inv_context.hardpoints.lt.pos;
	if(ind == 3) hpos = inv_context.hardpoints.rt.pos;
	if(ind == 4) hpos = inv_context.hardpoints.la.pos;
	if(ind == 5) hpos = inv_context.hardpoints.ra.pos;
	if(ind == 6) hpos = inv_context.hardpoints.ll.pos;
	if(ind == 7) hpos = inv_context.hardpoints.rl.pos;
	return hpos;
}
clearscope HardpointVitals getHardpointVitals(int ind)
{
	HardpointVitals hvital = new("HardpointVitals");
	switch(ind)
	{
		case 0:
			hvital.armor = inv_context.hardpoints.hd.armor;
			hvital.max_armor = inv_context.hardpoints.hd.max_armor;
			hvital.internalhp = inv_context.hardpoints.hd.internalhp;
			hvital.max_internal = inv_context.hardpoints.hd.max_internal;
		break;
		case 1:
			hvital.armor = inv_context.hardpoints.ct.armor;
			hvital.max_armor = inv_context.hardpoints.ct.max_armor;
			hvital.internalhp = inv_context.hardpoints.ct.internalhp;
			hvital.max_internal = inv_context.hardpoints.ct.max_internal;
		break;
		case 2:
			hvital.armor = inv_context.hardpoints.lt.armor;
			hvital.max_armor = inv_context.hardpoints.lt.max_armor;
			hvital.internalhp = inv_context.hardpoints.lt.internalhp;
			hvital.max_internal = inv_context.hardpoints.lt.max_internal;
		break;
		case 3:
			hvital.armor = inv_context.hardpoints.rt.armor;
			hvital.max_armor = inv_context.hardpoints.rt.max_armor;
			hvital.internalhp = inv_context.hardpoints.rt.internalhp;
			hvital.max_internal = inv_context.hardpoints.rt.max_internal;
		break;
		case 4:
			hvital.armor = inv_context.hardpoints.la.armor;
			hvital.max_armor = inv_context.hardpoints.la.max_armor;
			hvital.internalhp = inv_context.hardpoints.la.internalhp;
			hvital.max_internal = inv_context.hardpoints.la.max_internal;
		break;
		case 5:
			hvital.armor = inv_context.hardpoints.ra.armor;
			hvital.max_armor = inv_context.hardpoints.ra.max_armor;
			hvital.internalhp = inv_context.hardpoints.ra.internalhp;
			hvital.max_internal = inv_context.hardpoints.ra.max_internal;
		break;
		case 6:
			hvital.armor = inv_context.hardpoints.ll.armor;
			hvital.max_armor = inv_context.hardpoints.ll.max_armor;
			hvital.internalhp = inv_context.hardpoints.ll.internalhp;
			hvital.max_internal = inv_context.hardpoints.ll.max_internal;
		break;
		case 7:
			hvital.armor = inv_context.hardpoints.rl.armor;
			hvital.max_armor = inv_context.hardpoints.rl.max_armor;
			hvital.internalhp = inv_context.hardpoints.rl.internalhp;
			hvital.max_internal = inv_context.hardpoints.rl.max_internal;
		break;
	}
	return hvital;
}
clearscope vector2 FindHardpointVitals(vector2 pos)
{
	vector2 ffs = ( 0, 0 );
	if(pos == inv_context.hardpoints.hd.pos) ffs = (inv_context.hardpoints.hd.armor, inv_context.hardpoints.hd.internalhp);
	if(pos == inv_context.hardpoints.ct.pos) ffs = (inv_context.hardpoints.ct.armor, inv_context.hardpoints.ct.internalhp);
	if(pos == inv_context.hardpoints.lt.pos) ffs = (inv_context.hardpoints.lt.armor, inv_context.hardpoints.lt.internalhp);
	if(pos == inv_context.hardpoints.rt.pos) ffs = (inv_context.hardpoints.rt.armor, inv_context.hardpoints.rt.internalhp);
	if(pos == inv_context.hardpoints.la.pos) ffs = (inv_context.hardpoints.la.armor, inv_context.hardpoints.la.internalhp);
	if(pos == inv_context.hardpoints.ra.pos) ffs = (inv_context.hardpoints.ra.armor, inv_context.hardpoints.ra.internalhp);
	if(pos == inv_context.hardpoints.ll.pos) ffs = (inv_context.hardpoints.ll.armor, inv_context.hardpoints.ll.internalhp);
	if(pos == inv_context.hardpoints.rl.pos) ffs = (inv_context.hardpoints.rl.armor, inv_context.hardpoints.rl.internalhp);
	return ffs;
}

// Set
void adjustHardslots(Vector2 pos, int amt)
{
	if(pos == inv_context.hardpoints.hd.pos) inv_context.hardpoints.hd.slots += amt;
	if(pos == inv_context.hardpoints.ct.pos) inv_context.hardpoints.ct.slots += amt;
	if(pos == inv_context.hardpoints.lt.pos) inv_context.hardpoints.lt.slots += amt;
	if(pos == inv_context.hardpoints.rt.pos) inv_context.hardpoints.rt.slots += amt;
	if(pos == inv_context.hardpoints.la.pos) inv_context.hardpoints.la.slots += amt;
	if(pos == inv_context.hardpoints.ra.pos) inv_context.hardpoints.ra.slots += amt;
	if(pos == inv_context.hardpoints.ll.pos) inv_context.hardpoints.ll.slots += amt;
	if(pos == inv_context.hardpoints.rl.pos) inv_context.hardpoints.rl.slots += amt;
}


// Repair System
clearscope int CalculateHardpointRepairCost(HardpointVitals hv, int stat)
{
	int repair_cost = 0;
	float armor_ratio = 1.0 - (!hv.armor ? 1 : hv.armor)/hv.max_armor;
	float internalhp_ratio = 1.0 - (!hv.internalhp ? 1 : hv.internalhp)/hv.max_internal;
	if(stat == 0 && 	 armor_ratio > 0 ) repair_cost = (4750*armor_ratio)+(hv.max_armor*50);
	if(stat == 1 && internalhp_ratio > 0 ) repair_cost = (1250*internalhp_ratio)+(hv.max_internal*25);
	return repair_cost;
}
void RepairHardpointStat(int hindex, int stat)
{
	let hv = getHardpointVitals(hindex);
	int cost = CalculateHardpointRepairCost(hv,stat);
	if(inv_context.money_cbills < cost) 
	{
		sendHudAlert("Insufficient funds!",Font.CR_DARKRED);
	}
	else
	{
		inv_context.money_cbills -= cost;
		if(hindex == 0) _DoHardpointRepair(inv_context.hardpoints.hd, stat);
		if(hindex == 1) _DoHardpointRepair(inv_context.hardpoints.ct, stat);
		if(hindex == 2) _DoHardpointRepair(inv_context.hardpoints.lt, stat);
		if(hindex == 3) _DoHardpointRepair(inv_context.hardpoints.rt, stat);
		if(hindex == 4) _DoHardpointRepair(inv_context.hardpoints.la, stat);
		if(hindex == 5) _DoHardpointRepair(inv_context.hardpoints.ra, stat);
		if(hindex == 6) _DoHardpointRepair(inv_context.hardpoints.ll, stat);
		if(hindex == 7) _DoHardpointRepair(inv_context.hardpoints.rl, stat);
	}
}
void _DoHardpointRepair(MechHardpoint hp, int stats)
{
	if(stats == 0) hp.armor = hp.max_armor;
	if(stats == 1) hp.internalhp = hp.max_internal;	
	sendHudAlert("Hardpoint repaired!",Font.CR_GREEN);
}
void ActivateArmorUtility(class<ArmoryUtility> type, int hindex)
{	
	if(countinv(type) > 0)
	{
		let autil = ArmoryUtility(FindInventory(type));
		if(hindex == 0) autil.EquipUtil(self,inv_context.hardpoints.hd);
		if(hindex == 1) autil.EquipUtil(self,inv_context.hardpoints.ct);
		if(hindex == 2) autil.EquipUtil(self,inv_context.hardpoints.lt);
		if(hindex == 3) autil.EquipUtil(self,inv_context.hardpoints.rt);
		if(hindex == 4) autil.EquipUtil(self,inv_context.hardpoints.la);
		if(hindex == 5) autil.EquipUtil(self,inv_context.hardpoints.ra);
		if(hindex == 6) autil.EquipUtil(self,inv_context.hardpoints.ll);
		if(hindex == 7) autil.EquipUtil(self,inv_context.hardpoints.rl);
	}
}

// Damage System
void DamageHardpoint(MechHardpoint hp, float dmg, bool noarmor=false, bool crit=false)
{
	if(hp.armor > 0 && !noarmor) 
	{
		if(hp.armor-dmg <= 0) A_PlaySound("Mech/Damaged/NoArmor",1);
		// Random chance armor doesn't absorb the remaining damage.
		if(dmg > hp.armor && random(1,3)==3) 
		{
			hp.armor = 0;
			DamageHardpoint(hp,dmg-hp.armor,random(0,1));
		}
		else
		{
			hp.armor -= dmg;
			if(hp.armor < 0) hp.armor = 0;
		}
	}
	else if(hp.internalhp > 0)
	{
		if(random(0,20-dmg)==(20-dmg) || crit) 
		{
			A_PlaySound("Mech/Damaged/Critical",3);
			mechsounds.pushSound("Mech/Betty/CriticalHit");
			if(hp == inv_context.hardpoints.lt) mechsounds.pushSound("Mech/Betty/LeftTorso");
			if(hp == inv_context.hardpoints.rt) mechsounds.pushSound("Mech/Betty/RightTorso");
			if(hp == inv_context.hardpoints.la) mechsounds.pushSound("Mech/Betty/LeftArm");
			if(hp == inv_context.hardpoints.ra) mechsounds.pushSound("Mech/Betty/RightArm");
			if(hp == inv_context.hardpoints.ll) mechsounds.pushSound("Mech/Betty/LeftLeg");
			if(hp == inv_context.hardpoints.rl) mechsounds.pushSound("Mech/Betty/RightLeg");
			if(hp == inv_context.hardpoints.ct) mechsounds.pushSound("Mech/Betty/CenterTorso");
			if(random(0,1)==1)DestroyHardpointItems(hp,false);
		}
		hp.internalhp -= dmg;
		if(hp.internalhp <= 0) 
		{
			hp.internalhp = 0;
			if( random(1,3)==3 ) 
			{
				SpreadHardpointDamage(hp,dmg/2);
				A_PlaySound("Mech/Damaged/Explosion",3);
			}
		
			A_PlaySound("Mech/Damaged/HardpointDead",3);
			if(hp == inv_context.hardpoints.lt) mechsounds.pushSound("Mech/Betty/LeftTorso");
			if(hp == inv_context.hardpoints.rt) mechsounds.pushSound("Mech/Betty/RightTorso");
			if(hp == inv_context.hardpoints.la) mechsounds.pushSound("Mech/Betty/LeftArm");
			if(hp == inv_context.hardpoints.ra) mechsounds.pushSound("Mech/Betty/RightArm");
			if(hp == inv_context.hardpoints.ll) mechsounds.pushSound("Mech/Betty/LeftLeg");
			if(hp == inv_context.hardpoints.rl) mechsounds.pushSound("Mech/Betty/RightLeg");
			if(hp != inv_context.hardpoints.ct) mechsounds.pushSound("Mech/Betty/Destroyed");

			DestroyHardpointItems(hp);
		}
	}
	else
	{
		SpreadHardpointDamage(hp,dmg);
	}
}
void ProcessHardpointDamage(Name mod, float damage, Actor damager = NULL)
{	
	bool heatdmg = ( mod == "overheating" );
	//if(mod == "MechDamage_HD" || (heatdmg && random(1,12)==12) ) DamageHardpoint(inv_context.hardpoints.hd,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_CT" || (heatdmg && random(1,5)==5) ) DamageHardpoint(inv_context.hardpoints.ct,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_LT" || (heatdmg && random(1,3)==3) ) DamageHardpoint(inv_context.hardpoints.lt,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_RT" || (heatdmg && random(1,3)==3) ) DamageHardpoint(inv_context.hardpoints.rt,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_LA" || (heatdmg && random(1,4)==4) ) DamageHardpoint(inv_context.hardpoints.la,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_RA" || (heatdmg && random(1,4)==4) ) DamageHardpoint(inv_context.hardpoints.ra,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_LL" || (heatdmg && random(1,7)==7) ) DamageHardpoint(inv_context.hardpoints.ll,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_RL" || (heatdmg && random(1,7)==7) ) DamageHardpoint(inv_context.hardpoints.rl,damage,heatdmg&&random(0,1));
	
	if(  inv_context.hardpoints.hd.internalhp <= 0 || inv_context.hardpoints.ct.internalhp <= 0 ||
		(inv_context.hardpoints.ll.internalhp <= 0 && inv_context.hardpoints.rl.internalhp <= 0)   ) 
	{
		throttle = 0;
		if(modelcockpit)
		{
			mechsounds.Empty();
			for(int i = 0; i < 5; i++) mechsounds.PushSound("Mech/Damaged/CriticalExplosion");
			RandomExplosions.Trigger(pos,75,15,viewheight);
			if(!dronecam_active) ToggleDrone(200,0);
			AdjustDrone(200,1);
		}
		isdead = true;
		Die(NULL,damager);
		A_SetHealth(0);
	}
}
void SpreadHardpointDamage(MechHardpoint hp, float dmg)
{
	if(hp == inv_context.hardpoints.la) DamageHardpoint(inv_context.hardpoints.lt,dmg/2);
	if(hp == inv_context.hardpoints.ra) DamageHardpoint(inv_context.hardpoints.rt,dmg/2);
	if(hp == inv_context.hardpoints.lt) DamageHardpoint(inv_context.hardpoints.ct,dmg/4);
	if(hp == inv_context.hardpoints.rt) DamageHardpoint(inv_context.hardpoints.ct,dmg/4);
}
void DestroyHardpointItems(MechHardpoint hp, bool recurse=true)
{
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.mount == hp.pos) 
			{
				removeWeapon(ww);
				normalizeWeaponsID(1);
				mechsounds.pushSound("Mech/Betty/WeaponDestroyed");
				if(recurse) DestroyHardpointItems(hp,recurse);
			}
		}
	}
	DestroyHardpointStructs(hp,recurse);
}
void DestroyHardpointStructs(MechHardpoint hp, bool recurse=true)
{
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		Vector2 strucpos = inv_context.mechstructs[i].pos;
		let ut = GetDefaultByType(utilcast(inv_context.mechstructs[i].Tag));
		
		if(strucpos == hp.pos && ut.moveable)
		{
			class<Heatsink> hs = inv_context.mechstructs[i].Tag;
			if(hs) 
			{
				mechsounds.pushSound("Mech/Betty/Heatsink");
				mechsounds.pushSound("Mech/Betty/Destroyed");
			}
			adjustHardslots(strucpos,-ut.hardslots);
			inv_context.weapons_tonnage -= ut.weight;
			inv_context.mechstructs.delete(i);
			if(recurse) DestroyHardpointStructs(hp,recurse);
		}
	}
}
void HardpointDamageEffects()
{	
	// Process hardpoint damage effects
	if( inv_context.hardpoints.ll.internalhp <= 0 || 
		inv_context.hardpoints.rl.internalhp <= 0   )
	{
		throttle_max = 0.5;
		LegSpeed = 1;
	}
	else if( inv_context.hardpoints.lt.internalhp < inv_context.hardpoints.lt.max_internal || 
			 inv_context.hardpoints.rt.internalhp < inv_context.hardpoints.rt.max_internal    )
	{
		throttle_max = 0.8;
	}
	else
	{
		throttle_max = 1.0;
	}
}