// Camera Drone
class MechCamera : Actor
{
	MechWarriorBase mechowner;
	vector3 followpos;
	float followdist;
	float followdist_desired;
	float rotangle;
	float rotspd;
	bool frontcam;
	
	Property FollowDistance : followdist;
	
	Default
	{
		+NOGRAVITY;
		+SOLID;
		Radius 1;
		Height 1;
		MechCamera.FollowDistance 50;
	}
		
	static MechCamera Create(MechWarriorBase torso, float dist, float rotation, bool frontfacing=false)
	{
		let cam = MechCamera(Spawn("MechCamera"));
		if(cam) 
		{
			cam.mechowner = torso;
			cam.followdist_desired = dist;
			cam.rotspd = rotation;
			cam.frontcam = frontfacing;
		}
		return cam;
	}
	
	override void tick()
	{
		if(mechowner)
		{
			if(followdist < followdist_desired && mechowner.dronecam_active) 
				followdist = MDMath.Lerp(followdist,followdist_desired,0.05);
							
			float zoffs = (mechowner.viewheight);
			float lerpspd = 0.15;
			rotangle += rotspd;
			float trueangle = !rotangle ? mechowner.angle : rotangle;
			vector3 newfollowpos = (
				mechowner.pos.x - cos(trueangle)*followdist*(frontcam ? -1 : 1),
				mechowner.pos.y - sin(trueangle)*followdist*(frontcam ? -1 : 1),
				mechowner.pos.z + zoffs+(sin(mechowner.pitch)*followdist)
			);
			if(!followpos.length()) followpos = newfollowpos;
			
			if(!mechowner.dronecam_active)
			{
				if(Distance2D(mechowner) <= 24) Destroy();
				followdist = MDMath.Lerp(followdist,0,0.10);
				if(followdist <= 10) lerpspd=1;
			}
			followpos = MDMath.Lerp3D(followpos, newfollowpos, lerpspd);
			angle = AngleTo(mechowner);
			pitch = MDMath.getPitchBetween(pos,(mechowner.pos.x,mechowner.pos.y,mechowner.pos.z+zoffs));
			SetOrigin(followpos,true);
		}
	}	
	
	States
	{
		Spawn:
			MCAM A 1;
		loop;
	}
}


// Legs
class MechLegsBase : Actor
{
	MechwarriorBase mechowner;
	
	Default
	{
		+NOGRAVITY;
	}
	
	override void tick()
	{
		if(mechowner)
		{
			angle = mechowner.LegAng;
			SetOrigin(mechowner.pos,true);
		}
		super.tick();
	}
	
	bool isMoving()
	{
		return ( 
			 mechowner && !mechowner.checkVoodoo() && !mechowner.mech_shutdown && 
		    (mechowner.player && mechowner.player.onground) && 
			(mechowner.vel.xy.length() >= 0.08 || mechowner.LegVel) && 
			!mechowner.isdead
		);
	}
	bool checkStepping(bool idle=false)
	{
		if(!mechowner) return false;
		mechowner.stepping = idle ? false : (frame == 3 || frame == 8);
		return true;
	}
	
	static MechLegsBase Create(class<MechLegsBase> legs, MechWarriorBase torso)
	{
		let mwlegs = MechLegsBase(Spawn(legs));
		if(mwlegs)
		{
			mwlegs.mechowner = torso;
			mwlegs.frame = 0;
		}
		return mwlegs;
	}
	
	States
	{
		Spawn:
			TLEG "#" 1 A_JumpIf(checkStepping(true) && isMoving(), "WalkCycle");
		loop;
		WalkCycle:
			TLEG BCDEFGHIJ 4 
			{	
				float spdrating = (mechowner.throttle * mechowner.MoveSpeedKPH)/140.;
				float wrating = float(mechowner.inv_context.weapons_tonnage)/100.;
				float stompfriction = clamp((0.77) + (wrating*(spdrating)), 0.87, 1.32);
				if(checkStepping() && mechowner.stepping) mechowner.vel.xy *= stompfriction;
				if( (frame == 2 || frame == 7) ) SoundEmitter.SE_Trigger("Mech/Footstep",mechowner.pos);
				if(spdrating > 0) tics = clamp(10-(abs(spdrating)*10.), 3, 10);
				// console.printf("--------\nSR: %f\nWR: %f\nFR: %f", spdrating, wrating, stompfriction);
				
				return !isMoving() ? ResolveState("Spawn") : ResolveState(Null); 
			}
		loop;
	}
}


class Legs_Timberwolf : MechLegsBase {}
class Legs_Stormcrow : MechLegsBase {}
class Legs_Atlas : MechLegsBase {}
class Legs_Commando : MechLegsBase {}
class Legs_Urbanmech : MechLegsBase {}
class Legs_Jenner : MechLegsBase {}
class Legs_Invisible : MechLegsBase {}
