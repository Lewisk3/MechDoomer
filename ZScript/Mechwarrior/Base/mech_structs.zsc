	/*************************\
	|	 Structure Systems    |
	\*************************/
class FoundStruct
{
	mw_InvStruct obj;
	int realindex;
}
	
extend class MechwarriorBase;

// Engines
bool EquipEngine(class<Mechbase_Engine> engine)
{
	inv_context.engine = MechBase_Engine.Create(engine);
	MechBase_EngineOBJ engobj = inv_context.engine;
	
	// Check if enough slots/tons to equip.
	int slots_ct = hardpoints.ct.getFreeSlots();
	int slots_lt = hardpoints.lt.getFreeSlots();
	int slots_rt = hardpoints.rt.getFreeSlots();
	int ctslots = engobj.ctslots;
	int ltslots = engobj.ltslots;
	int rtslots = engobj.rtslots;
	int gyroslots = engobj.gyroslots;
	int weight = engobj.weight;
	
	if( 
		 (gyroslots+ctslots > slots_ct || ltslots > slots_lt || rtslots > slots_rt) || 
		 ((inv_context.weapons_tonnage+weight > mech_tonnage) && !overtonnage)
	  )
	{
		console.printf("Why?");
		inv_context.engine.Destroy();
		inv_context.engine = NULL;
		return false;
	}
	
	equipStruct("StructEngine",hardpoints.lt,ltslots);
	equipStruct("StructEngine",hardpoints.rt,rtslots);
	equipStruct("StructEngine",hardpoints.ct,ctslots);	
	equipStruct("StructGyro",hardpoints.ct,gyroslots);
	setupSpeedKPH(EngineGetKPH());
	inv_context.weapons_tonnage += weight;
	baseHeatEfficiency += GetDefaultByType("Heatsink").cooling*engobj.intrinsic_heatsinks;
	baseHeatEfficiency += GetDefaultByType("DoubleHeatsink").cooling*engobj.intrinsic_doubleheatsinks;
	return true;
}
	
clearscope float EngineGetKPH()
{
	if(!inv_context.engine) return 0;
	return (32.4*(100./mech_tonnage)) / (200./inv_context.engine.enginetype);
}
	
void DequipEngine()
{
	if(!inv_context.engine) return;
	MechBase_EngineOBJ engobj = inv_context.engine;
	bool engstruct = true;
	// Handle engine structures
	while(engstruct)
	{
		class<StructEngine> eng;
		class<StructGyro> gyro;
		for(int i = 0; i < inv_context.mechstructs.Size(); i++)
		{
			MechHardpoint hpos = inv_context.mechstructs[i].hardpoint;
			if(hpos == hardpoints.ct || hpos == hardpoints.lt || hpos == hardpoints.rt)
			{
				string type = inv_context.mechstructs[i].Tag;
				eng = type;
				gyro = type;
				if(eng || gyro) 
				{
					removeStruct(i);
					// If i don't break here, it'll fail to process all structs, probably
					// because the current context of the mechstructs array becomes invalid.
					break; 
				}
			}
		}
		if(!eng && !gyro) engstruct = false;
	}
	
	baseHeatEfficiency -= GetDefaultByType("Heatsink").cooling*engobj.intrinsic_heatsinks;
	baseHeatEfficiency -= GetDefaultByType("DoubleHeatsink").cooling*engobj.intrinsic_doubleheatsinks;
	inv_context.weapons_tonnage -= engobj.weight;
	addStructToInv(engobj.ClassType);
	
	// RIP
	engobj.Destroy();
	inv_context.engine = NULL;
}


// Find
mw_InvStruct FindHealthyStruct(String type, MechHardpoint pos)
{
	type.ToLower();
	if(!inv_context.mechstructs.Size()) inv_context.mechstructs.Clear();
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		if(inv_context.mechstructs[i].hardpoint != pos) continue;
		if(inv_context.mechstructs[i].broken) continue;
		String cname = inv_context.mechstructs[i].Tag;
		cname.ToLower();
		
		if(cname == type) return inv_context.mechstructs[i];
	}
	return NULL;
}
bool FindStructs(String type, MechHardpoint pos, bool healthy, in out Array<FoundStruct> objs)
{
	objs.Clear();
	type.ToLower();
	if(!inv_context.mechstructs.Size()) inv_context.mechstructs.Clear();
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		if(inv_context.mechstructs[i].hardpoint != pos) continue;
		if(healthy && inv_context.mechstructs[i].broken) continue;
		String cname = inv_context.mechstructs[i].Tag;
		cname.ToLower();
		
		if(cname == type) 
		{
			FoundStruct fstr = new("FoundStruct");
			fstr.obj = inv_context.mechstructs[i];
			fstr.realindex = i;
			objs.push(fstr);
		}
	}
	return (objs.Size() > 0);
}

// Get
bool getStructsIn(MechHardpoint pos, in out Array<FoundStruct> objs)
{
	objs.Clear();
	if(!inv_context.mechstructs.Size()) inv_context.mechstructs.Clear();
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		if(inv_context.mechstructs[i].hardpoint != pos) continue;
		String cname = inv_context.mechstructs[i].Tag;
		cname.ToLower();
		
		FoundStruct fstr = new("FoundStruct");
		fstr.obj = inv_context.mechstructs[i];
		fstr.realindex = i;
		objs.push(fstr);
	}
	return (objs.Size() > 0);
}
int countStruct(String type)
{
	int count = 0;
	type.ToLower();
	if(!inv_context.mechstructs.Size()) inv_context.mechstructs.Clear();
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		String cname = inv_context.mechstructs[i].Tag;
		cname.ToLower();
		type.ToLower();
		if(cname == type) count++;
	}
	return count;
}
int countStructDamaged(String type, bool destroyed=false)
{
	int dmgcount = 0;
	type.ToLower();
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		String cname = inv_context.mechstructs[i].Tag;
		cname.ToLower();
		
		if(cname == type) 
		{
			if(destroyed && inv_context.mechstructs[i].broken) 
				dmgcount++;
			else if(inv_context.mechstructs[i].dmg_taken > 0)
				dmgcount++;
		}
	}
	return dmgcount;
}

// Equip or Add
bool equipStructInv(int ind, MechHardpoint hp, bool move=true)
{
	// Equip struct from items
	class<Mechbase_Utility> util = inv_context.weapon_items[ind-1];
	class<Mechbase_Engine> eng = inv_context.weapon_items[ind-1];
	if(eng)
	{
		if(inv_context.engine) 
		{
			sendHudAlert("Engine already equipped!", Font.CR_DARKRED);
			return false;
		}
		if(!EquipEngine(eng))
		{
			sendHudAlert("Failed to equip engine, overtonnage or too big!", Font.CR_DARKRED);
			return false;
		}
		else
		{
			inv_context.weapon_items.delete(ind-1);
			return true;
		}
	}
	if(!util) return false;
	
	if( inv_context.weapons_tonnage+GetDefaultByType(util).weight > mech_tonnage && !overtonnage)
	{
		sendHudAlert("Cannot equip item, over tonnage!", Font.CR_DARKRED);
		return false;
	}
	if( hp.getFreeSlots() < GetDefaultByType(util).hardslots )
	{
		sendHudAlert("Cannot equip item, no freeslots!", Font.CR_DARKRED);
		return false;	
	}
	 
	 // Equip without giving starting ammunition
	if(!equipStruct(inv_context.weapon_items[ind-1],hp,1,false)) return false;
	if(move)inv_context.weapon_items.delete(ind-1);
	return true;
}
bool equipStruct(class<Mechbase_Utility> type, MechHardpoint hp, int amt = 1,bool giveammo=true)
{
	if( (hp.getFreeSlots()-(GetDefaultByType(type).hardslots*amt)) < 0)
	{
		if(!GetDefaultByType(type).moveable) console.printf("WARNING: Failed to equip critical item: %s",type.getClassName());
		return false;
	}
	let str_def = GetDefaultByType(type);
	if(str_def.ammogive > 0 && str_def.ammotype != "" && giveammo) 
	{
		A_GiveInventory(str_def.ammotype,str_def.ammogive);
	}
	for(int i = 0; i < amt; i++)
	{
		let st = new("mw_InvStruct");
		st.Tag = type.getClassName();
		st.hardpoint = hp;
		inv_context.mechstructs.push(st);
		inv_context.weapons_tonnage += GetDefaultByType(type).weight;
		hp.adjustHardslots(GetDefaultByType(type).hardslots);
	}
	return true;
}
void addStructToInv(String mstruc)
{
	class<Mechbase_Utility> util = mstruc;
	if(!util) return;
	inv_context.weapon_items.push(mstruc);
}

// Move
bool moveStructToInv(int struc_ind, bool move=true)
{
	
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		if(i == struc_ind)
		{
			let ut = GetDefaultByType(utilcast(inv_context.mechstructs[i].Tag));
			class<StructEngine> eng = inv_context.mechstructs[i].Tag;
			if(eng) 
			{
				DequipEngine();
				return true;
			}
			if(!ut.moveable) return false;
			addStructToInv(inv_context.mechstructs[i].Tag);
			removeStruct(i, move);
			return true;
		}
	}
	return false;
}

void removeStruct(int ind, bool delete=true)
{
	let mstruct = inv_context.mechstructs[ind];
	let ut = GetDefaultByType(utilcast(mstruct.Tag));
	MechHardpoint hp = mstruct.hardpoint;
	hp.adjustHardslots(-ut.hardslots);
	inv_context.weapons_tonnage -= ut.weight;
	if(delete) inv_context.mechstructs.delete(ind);
}
