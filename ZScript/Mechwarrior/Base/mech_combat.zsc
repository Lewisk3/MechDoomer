	/*************************\
	|	   Combat System      |
	\*************************/
extend class MechWarriorBase;

enum MechTypes
{
	MechType_Clan,
	MechType_Innersphere,
	MechType_BattleArmor
}

// Properties
double baseHeatEfficiency;
uint mechtype;

// Vars
Array<mw_CombatObjective> objectives;
bool display_objectives;
MechCamera dronecam;
RandomExplosions deathexplosions;
bool dronecam_active;
bool heatwarn;
bool supersink;
bool InfraredActive;
bool ams_passive;
double HeatEfficiency;
double HeatLevel;
double prevheat;
double deltaHeat;
int radar_range; // Rader range mode; 0-3
int radar_scale; // Radar scales; 0-2
String crosshair_sprite;

// Crosshair(s)
void SetCrosshair(int ind)
{
	string cx = "";
	if(ind) cx = "XHAIRB"..ind;
	crosshair_sprite = cx;
}

// Drone
void ToggleDrone(double cdist, double rotspd, double angdist, bool front, bool alwayson=false)
{
	if(!dronecam)
	{
		dronecam = MechCamera.Create(self, cdist, angdist, rotspd, front);
		dronecam_active = true;
		if(!isdead)
		{
			mechSounds.PushSound("Mech/Blip");
			mechSounds.PushSound("Mech/Betty/ExternalCamera");
		}
	}
	else if(!alwayson)
	{
		dronecam_active = false;
	}
}
void AdjustDrone(double cdist, double rotspd, double angdist, bool front)
{
	if(dronecam && dronecam_active)
	{
		dronecam.followdist_desired = cdist;
		dronecam.rotspd = rotspd;
		dronecam.followtilt = angdist;
		dronecam.frontcam = front;
	}
}

// Death
void ProcessDeath(Actor killer)
{
	throttle = 0;
	if(isdead) return; 
	
	if(modelcockpit)
	{
		mechsounds.Empty();
		for(int i = 0; i < 5; i++) mechsounds.PushSound("Mech/Damaged/CriticalExplosion");
		deathexplosions = RandomExplosions.TriggerOnActor(self, 75,15,viewheight);
		AdjustDrone(350, 1, 0, true);
		player.cheats |= CF_TOTALLYFROZEN;
	}
	
	isdead = true;
	mech_shutdown = true; 
	manualshutdown = false;
	forceshutdown = true;
	A_SetHealth(0);
}

// Main
void mech_weapons()
{
	if((ticks - prevticks ) > 5)
	{
		buttonTick = true;
		prevticks = ticks;
	}
	
	bool firing = (GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK) || 
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER1 ) ||
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER2 ) ||
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER3 ) ||
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER4 );

	// Process Heat levels and struct functionality.
	deltaHeat = HeatLevel-prevheat;
	class<Heatsink> hs = "Heatsink";
	class<Heatsink> dhs = "DoubleHeatsink";
	process_antimissilesystem();
	
	// Process hot/damaging floors. (Increase HeatLevel every 2 ticks)
	if( player && player.onground && CurSector.damageamount != 0 && !(level.maptime%2) )
	{
		HeatLevel += CurSector.damageamount * 0.01;
	}
	
	double HSinkEff = (countStruct("Heatsink")*GetDefaultByType(hs).cooling/35)+(countStruct("DoubleHeatsink")*GetDefaultByType(dhs).cooling/35);
	HeatEfficiency = inv_context.heateff+baseHeatEfficiency+HSinkEff; 
	Mech_HasJets = (countStruct("JumpJet") > 0);
	Mech_JetCount = countStruct("JumpJet");
	if(supersink) HeatEfficiency *= 3;
	// Dissipate heat quicker when under water
	if(waterlevel > 0) HeatEfficiency *= 2;
	if(HeatLevel > 0) HeatLevel -= HeatEfficiency;
	if(HeatLevel < 0) HeatLevel = 0; 
	if(HeatLevel > MWHEAT_MAX*0.53) DamageMobj(self,null,frandom(24,36),"overheating",DMG_NO_ARMOR | DMG_NO_FACTOR);
	if(HeatLevel <= MWHEAT_MAX*0.15) heatwarn = false;
	if(HeatLevel > MWHEAT_MAX*0.275 && !heatwarn)
	{
		A_PlaySound("Mech/HeatWarn",1,1);
		mechsounds.pushSound("Mech/Betty/HeatCritical");
		heatwarn = true;
	}
	if(HeatLevel >= MWHEAT_MAX*0.42 && !doShutdown && canShutdown) 
	{
		Cockpit_Alert("\c[SAPPHIRE]Shutdown sequence initiated!");
		mechsounds.pushSound("Mech/Betty/ShutdownInit");
		doShutdown = true;
		canShutdown = false;
		shutdown_timer = ticks;
	}
	if(HeatLevel <= MWHEAT_MAX*0.32) canShutdown = true;
	if( ((ticks - shutdown_timer) > MWHEAT_MAX) && doShutdown )
	{
		A_StopSound(1);
		Cockpit_Alert("\c[SAPPHIRE]Shutting down...");
		A_PlaySound("Mech/Betty/ShuttingDown",1);
		doShutdown = true;
		lockangle = angle;
		lockpitch = pitch;
		mech_shutdown = true;
		shutdown_timer = ticks;
		hAlert.hud_powersequence = MechStatusBar.GetAnimFlags();
		A_PlaySound("Mech/Shutdown",2);
	}
	if(HeatLevel > MWHEAT_MAX) HeatLevel = MWHEAT_MAX;
	
	if(selectedWeapon > inv_context.weapons_count)selectedWeapon = 1;
	if(selectedGroup > 4)selectedGroup = 1;
	if( (GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK) && getSelectedWeapon() && !pilotlook )
	{
		FireWeapons(weapon_groupfire);
		weapons_fired = true;
		if(buttonTick)buttonTick = false;
	}
	if(!firing && weapons_fired && getSelectedWeapon() && !getSelectedWeapon().dofire) 
	{	
		nextWeapon(true);
		weapons_fired = false;
	}
	
	if(countinv("IBTN_SETWEAPGRP"))
	{	
		if(countinv("IBTN_SETWEAPGRP") > 4)
		{
			console.printf("ERROR: Invalid weapon group :> %d",countinv("IBTN_SETWEAPGRP"));
			TakeInventory("IBTN_SETWEAPGRP",999);
		}
		else
		{
			setWeaponGroupAt(selectedWeapon,countinv("IBTN_SETWEAPGRP"));
			inv_context.maxgroup = getMaxWeaponGrouping();
		}
		TakeInventory("IBTN_SETWEAPGRP",999);
	}
	
	if(countinv("IBTN_SHOOTALLWEAPONSLIKEAMADLAD") && !pilotlook)
	{
		FireGroup(0,true,true); // pew pew pew, whoosh, whoosh, whoosh, pow, pow, po.. *explodes*
		TakeInventory("IBTN_SHOOTALLWEAPONSLIKEAMADLAD",1);
	}
	
	if(countinv("IBTN_NXTGROUP"))
	{
		if(inv_context.weapons_count > 1)
		{
			int grp = getWeaponGroupAt(selectedWeapon)+1;
			if(grp > inv_context.maxgroup) grp = 1;
			selectedWeapon = getNearestWeaponAt(grp);
		}
		TakeInventory("IBTN_NXTGROUP",1);
	}
	
	if(countinv("IBTN_PRVGROUP"))
	{
		if(inv_context.weapons_count > 1)
		{
			int grp = getWeaponGroupAt(selectedWeapon)-1;
			if(grp < 1)grp = inv_context.weapons_count;
			selectedWeapon = getNearestWeaponAt(grp);
		}
		TakeInventory("IBTN_PRVGROUP",1);
	}
	
	if(countinv("IBTN_SHUTDOWN") || (!mech_shutdown && !inv_context.engine) )
	{
		Cockpit_Alert("\c[RED]Shutting down...");
		mechsounds.pushSound("Mech/Betty/ShuttingDown");
		A_PlaySound("Mech/Shutdown",1);
		mech_shutdown = true;
		manualshutdown = true;
		lockpitch = pitch;
		lockangle = angle;
		TakeInventory("IBTN_SHUTDOWN",1);
		hAlert.hud_powersequence = MechStatusBar.GetAnimFlags();
	}
		
	if(!targetenemy && targetreticle)
	{
		// Don't hold onto dead/invalid target.
		targetreticle.RDeconstruct();
		targetreticle = null;
	}
	
	if(countinv("IBTN_TARGET"))
	{
		TakeInventory("IBTN_TARGET",999);
		
		// Get reference to shootable actor under players aim.
		// AimLineAttack or AimTarget fail to respect viewheight, hence the LineTrace.
		FLineTraceData lt;
		LineTrace(angle, 9999, pitch, 0, viewheight, 0.0,0.0, lt);
		if(lt.HitActor)
		{
			SoundEmitter.SE_Trigger("Mech/Target/Get",pos);
			if(targetreticle)targetreticle.RDeconstruct();
			targetenemy = lt.HitActor;
			targetreticle = MechTargetReticle.InitCreate(self, targetenemy, 16);
		}
	}
	
	if(countinv("IBTN_bFIREMODE"))
	{
		weapon_groupfire = !weapon_groupfire;
		if(weapon_groupfire)
		{
			Cockpit_Alert("\c[GREEN]Group Fire: Engaged");
			mechsounds.pushSound("Mech/Betty/Groupfire");
			mechsounds.pushSound("Mech/Betty/Engaged");
			TakeInventory("IBTN_bFIREMODE",1);
		} 
		else 
		{
			Cockpit_Alert("\c[GREEN]Chain Fire: Engaged");
			mechsounds.pushSound("Mech/Betty/Chainfire");
			mechsounds.pushSound("Mech/Betty/Engaged");
			TakeInventory("IBTN_bFIREMODE",1);
		}
		TakeInventory("IBTN_bFIREMODE",1);
	}
	
	if(!pilotlook)
	{
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER1)
		{
			if(FireGroup(1)) weapons_fired = true;
		}
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER2)
		{
			if(FireGroup(2)) weapons_fired = true;
		}
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER3)
		{
			if(FireGroup(3)) weapons_fired = true;
		}
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER4)
		{
			if(FireGroup(4)) weapons_fired = true;	
		}
	}
	
	if(countinv("IBTN_NEXTWEAPON"))
	{	
		if(inv_context.weapons_count > 1)
		{
			A_PlaySound("Mech/NextWeapon",CHAN_WEAPON);
			selectedWeapon++;
		}
		if(selectedWeapon > inv_context.weapons_count) selectedWeapon = 1;
		TakeInventory("IBTN_NEXTWEAPON",1);
	}		
	if(countinv("IBTN_PREVWEAPON"))
	{
		if(inv_context.weapons_count > 1)
		{
			A_PlaySound("Mech/NextWeapon",CHAN_WEAPON);
			selectedWeapon--;
		}
		if(selectedWeapon < 1) selectedWeapon = inv_context.weapons_count;
		TakeInventory("IBTN_PREVWEAPON",1);
	}
	
	prevheat = HeatLevel;
	ticks++;
}

// AMS
bool CheckHasAMS()
{
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		String cname = inv_context.mechstructs[i].Tag;
		class<AntiMissileSystem> basecast = cname;
		if(basecast) return true;
	}
	return false;
}
void process_antimissilesystem()
{
	if(ams_passive) return;
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		mw_InvStruct item = inv_context.mechstructs[i];
		String cname = item.Tag;
		class<AntiMissileSystem> basecast = cname;
		if(basecast)
		{
			trigger_ams(item);
			item.active_cooldown--;
		}
	}
}
void trigger_ams(mw_InvStruct amsitem)
{
	String cname = amsitem.Tag;
	vector2 amshardpoint = amsitem.hardpoint.pos;
	class<Mechbase_Utility> amsut = cname;
	class<AntiMissileSystem> amsdef = cname;
	
	let def_utams = GetDefaultByType(amsut);
	let def_ams = GetDefaultByType(amsdef);
	
	// Check ammunition.
	if(def_ams.ammotype) 
	{
		if(countammo(def_ams.ammotype) < def_ams.ammouse) return;
	}
	// Check if a projectile is near us.
	ThinkerIterator ams_it = ThinkerIterator.Create("Actor");
	Actor obj;
	while(obj = Actor(ams_it.Next()))
	{
		if(obj is "AMS_Missile" || obj is "Mechbase_Actor") continue;
		if(obj && obj.Damage && amsitem.active_cooldown <= 0)
		{	
			if(CheckSight(obj) && (obj.bMISSILE) && Distance3D(obj) < def_ams.activerange )
			{
				//console.printf("Firing AMS at: " .. obj.getTag());
				SoundEmitter.SE_Trigger(def_ams.firesound);
				amshardpoint.x += random(-5,5);
				amshardpoint.y += random(-5,5);
				vector2 offs = MDMath.VOffset(angle, 25, amshardpoint.x, 1);	
				vector3 lpos = Vec3Offset(offs.x,offs.y,(viewheight*player.crouchFactor)+amshardpoint.y);
				obj.bSHOOTABLE = true;
				let ams = AMS_Missile(Spawn(def_ams.amstype,lpos));
				if(ams)
				{
					// AMS Sound FX
					ams.mechplayer = Mechwarrior(self);
					ams.tracer = obj;
					ams.master = self;
					amsitem.active_cooldown = def_ams.cooldown;
					ams.pitch = obj.pitch;
					ams.angle = ams.AngleTo(obj);
					// Will automatically set convengence factor in postplay.
					ams.vel = (
							cos(ams.AngleTo(obj))*cos(obj.pitch),
							sin(ams.AngleTo(obj))*cos(obj.pitch),
							-sin(obj.pitch)*5
							) * (obj.speed+def_ams.speed);
					if(def_ams.ammotype) TakeAmmo(def_ams.ammotype,def_ams.ammouse);
				}
			}
		}
	}
}