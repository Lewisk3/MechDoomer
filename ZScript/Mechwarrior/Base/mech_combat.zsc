	/*************************\
	|	   Combat System      |
	\*************************/
extend class MechWarriorBase;

enum MechTypes
{
	MechType_Clan,
	MechType_Innersphere
}

// Properties
float baseHeatEfficiency;
uint mechtype;

// Vars
Array<mw_CombatObjective> objectives;
bool display_objectives;
MechCamera dronecam;
RandomExplosions deathexplosions;
bool dronecam_active;
bool heatwarn;
bool supersink;
bool InfraredActive;
int ams_timer;
float HeatEfficiency;
float HeatLevel;
float prevheat;
float deltaHeat;
String crosshair_sprite;

// Crosshair(s)
void SetCrosshair(int ind)
{
	string cx = "";
	if(ind) cx = "XHAIRB"..ind;
	crosshair_sprite = cx;
}

// Drone
void ToggleDrone(float cdist, float rotspd, float angdist, bool front)
{
	if(!dronecam)
	{
		dronecam = MechCamera.Create(self, cdist, angdist, rotspd, front);
		dronecam_active = true;
	}
	else
	{
		dronecam_active = false;
	}
}
void AdjustDrone(float cdist, float rotspd, float angdist, bool front)
{
	if(dronecam && dronecam_active)
	{
		dronecam.followdist_desired = cdist;
		dronecam.rotspd = rotspd;
		dronecam.followtilt = angdist;
		dronecam.frontcam = front;
	}
}

// Death
void ProcessDeath(Actor killer)
{
	throttle = 0;
	if(isdead) return; 
	
	if(modelcockpit)
	{
		player.cheats |= CF_TOTALLYFROZEN;
		mechsounds.Empty();
		for(int i = 0; i < 5; i++) mechsounds.PushSound("Mech/Damaged/CriticalExplosion");
		deathexplosions = RandomExplosions.TriggerOnActor(self, 75,15,viewheight);
		if(!dronecam_active) 
			ToggleDrone(350,1,0,true);
		else
			AdjustDrone(350,1,0,true);
	}
	
	isdead = true;
	mech_shutdown = true; 
	manualshutdown = false;
	forceshutdown = true;
	A_SetHealth(0);
}

// Main
void mech_weapons()
{
	if((ticks - prevticks ) > 5)
	{
		buttonTick = true;
		prevticks = ticks;
	}
	
	bool firing = (GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK) || 
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER1 ) ||
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER2 ) ||
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER3 ) ||
				  (GetPlayerInput(INPUT_BUTTONS) & BT_USER4 );

	// Process Heat levels and struct functionality.
	deltaHeat = HeatLevel-prevheat;
	class<Heatsink> hs = "Heatsink";
	class<Heatsink> dhs = "DoubleHeatsink";
	process_antimissilesystem();
	
	float HSinkEff = (countStruct("Heatsink")*GetDefaultByType(hs).cooling/35)+(countStruct("DoubleHeatsink")*GetDefaultByType(dhs).cooling/35);
	HeatEfficiency = inv_context.heateff+baseHeatEfficiency+HSinkEff; 
	Mech_HasJets = (countStruct("JumpJet") > 0);
	Mech_JetCount = countStruct("JumpJet");
	if(supersink) HeatEfficiency *= 2;
	if(HeatLevel > 0) HeatLevel -= HeatEfficiency;
	if(HeatLevel < 0) HeatLevel = 0;
	if(HeatLevel > MWHEAT_MAX*0.6) DamageMobj(self,null,random(6,12),"overheating",DMG_NO_ARMOR | DMG_NO_FACTOR);
	if(HeatLevel <= MWHEAT_MAX*0.15) heatwarn = false;
	if(HeatLevel > MWHEAT_MAX*0.275 && !heatwarn)
	{
		A_PlaySound("Mech/HeatWarn",1,1);
		mechsounds.pushSound("Mech/Betty/HeatCritical");
		heatwarn = true;
	}
	if(HeatLevel >= MWHEAT_MAX*0.42 && !doShutdown && canShutdown) 
	{
		A_Print("Shutdown sequence initiated!");
		mechsounds.pushSound("Mech/Betty/ShutdownInit");
		doShutdown = true;
		canShutdown = false;
		shutdown_timer = ticks;
	}
	if(HeatLevel <= MWHEAT_MAX*0.32) canShutdown = true;
	if( ((ticks - shutdown_timer) > MWHEAT_MAX) && doShutdown )
	{
		A_StopSound(1);
		A_Print("Shutting down...");
		A_PlaySound("Mech/Betty/ShuttingDown",1);
		doShutdown = true;
		lockangle = angle;
		lockpitch = pitch;
		mech_shutdown = true;
		shutdown_timer = ticks;
		A_PlaySound("Mech/Shutdown",2);
	}
	if(HeatLevel > MWHEAT_MAX) HeatLevel = MWHEAT_MAX;
	
	if(selectedWeapon > inv_context.weapons_count)selectedWeapon = 1;
	if(selectedGroup > 4)selectedGroup = 1;
	if( (GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK) && getSelectedWeapon() && !pilotlook )
	{
		FireWeapons(weapon_groupfire);
		weapons_fired = true;
		if(buttonTick)buttonTick = false;
	}
	if(!firing && weapons_fired && getSelectedWeapon() && !getSelectedWeapon().dofire) 
	{	
		nextWeapon(true);
		weapons_fired = false;
	}
	
	if(countinv("IBTN_SETWEAPGRP"))
	{	
		if(countinv("IBTN_SETWEAPGRP") > 4)
		{
			console.printf("ERROR: Invalid weapon group :> %d",countinv("IBTN_SETWEAPGRP"));
			TakeInventory("IBTN_SETWEAPGRP",999);
		}
		else
		{
			setWeaponGroupAt(selectedWeapon,countinv("IBTN_SETWEAPGRP"));
			inv_context.maxgroup = getMaxWeaponGrouping();
		}
		TakeInventory("IBTN_SETWEAPGRP",999);
	}
	
	if(countinv("IBTN_SHOOTALLWEAPONSLIKEAMADLAD") && !pilotlook)
	{
		FireGroup(0,true,true); // pew pew pew, whoosh, whoosh, whoosh, pow, pow, po.. *explodes*
		TakeInventory("IBTN_SHOOTALLWEAPONSLIKEAMADLAD",1);
	}
	
	if(countinv("IBTN_NXTGROUP"))
	{
		if(inv_context.weapons_count > 1)
		{
			int grp = getWeaponGroupAt(selectedWeapon)+1;
			if(grp > inv_context.maxgroup) grp = 1;
			selectedWeapon = getNearestWeaponAt(grp);
		}
		TakeInventory("IBTN_NXTGROUP",1);
	}
	
	if(countinv("IBTN_PRVGROUP"))
	{
		if(inv_context.weapons_count > 1)
		{
			int grp = getWeaponGroupAt(selectedWeapon)-1;
			if(grp < 1)grp = inv_context.weapons_count;
			selectedWeapon = getNearestWeaponAt(grp);
		}
		TakeInventory("IBTN_PRVGROUP",1);
	}
	
	if(countinv("IBTN_SHUTDOWN") || (!mech_shutdown && !inv_context.engine) )
	{
		A_Print("Shutting down...");
		mechsounds.pushSound("Mech/Betty/ShuttingDown");
		A_PlaySound("Mech/Shutdown",1);
		mech_shutdown = true;
		manualshutdown = true;
		lockpitch = pitch;
		lockangle = angle;
		TakeInventory("IBTN_SHUTDOWN",1);
	}
		
	if(!targetenemy && targetreticle)
	{
		// Don't hold onto dead/invalid target.
		targetreticle.RDeconstruct();
		targetreticle = null;
	}
	
	if(countinv("IBTN_TARGET"))
	{
		TakeInventory("IBTN_TARGET",999);
		
		// Get reference to shootable actor under players aim.
		// AimLineAttack or AimTarget fail to respect viewheight, hence the LineTrace.
		FLineTraceData lt;
		LineTrace(angle, 9999, pitch, 0, viewheight, 0.0,0.0, lt);
		if(lt.HitActor)
		{
			SoundEmitter.SE_Trigger("Mech/Target/Get",pos);
			if(targetreticle)targetreticle.RDeconstruct();
			targetenemy = lt.HitActor;
			targetreticle = MechTargetReticle.InitCreate(self, targetenemy, 16);
		}
	}
	
	if(countinv("IBTN_bFIREMODE"))
	{
		weapon_groupfire = !weapon_groupfire;
		if(weapon_groupfire){
			mechsounds.pushSound("Mech/Betty/Groupfire");
			mechsounds.pushSound("Mech/Betty/Engaged");
			TakeInventory("IBTN_bFIREMODE",1);
		} else {
			mechsounds.pushSound("Mech/Betty/Chainfire");
			mechsounds.pushSound("Mech/Betty/Engaged");
			TakeInventory("IBTN_bFIREMODE",1);
		}
		TakeInventory("IBTN_bFIREMODE",1);
	}
	
	if(!pilotlook)
	{
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER1)
		{
			if(FireGroup(1)) weapons_fired = true;
		}
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER2)
		{
			if(FireGroup(2)) weapons_fired = true;
		}
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER3)
		{
			if(FireGroup(3)) weapons_fired = true;
		}
		if(GetPlayerInput(INPUT_BUTTONS) & BT_USER4)
		{
			if(FireGroup(4)) weapons_fired = true;	
		}
	}
	
	if(countinv("IBTN_NEXTWEAPON"))
	{	
		if(inv_context.weapons_count > 1)
		{
			A_PlaySound("Mech/NextWeapon",CHAN_WEAPON);
			selectedWeapon++;
		}
		if(selectedWeapon > inv_context.weapons_count) selectedWeapon = 1;
		TakeInventory("IBTN_NEXTWEAPON",1);
	}		
	if(countinv("IBTN_PREVWEAPON"))
	{
		if(inv_context.weapons_count > 1)
		{
			A_PlaySound("Mech/NextWeapon",CHAN_WEAPON);
			selectedWeapon--;
		}
		if(selectedWeapon < 1) selectedWeapon = inv_context.weapons_count;
		TakeInventory("IBTN_PREVWEAPON",1);
	}
	
	prevheat = HeatLevel;
	ticks++;
}

// AMS
void process_antimissilesystem()
{
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		String cname = inv_context.mechstructs[i].Tag;
		cname.ToLower();
		if(cname == "antimissilesystem")
		{
			trigger_ams( inv_context.mechstructs[i].hardpoint.pos );
		}
	}
	if(ams_timer > 0) ams_timer--;
}
void trigger_ams(vector2 amshardpoint)
{
	class<Mechbase_Utility> amsut = "AntiMissileSystem";
	class<AntiMissileSystem> amsdef = "AntiMissileSystem";
	let def_utams = GetDefaultByType(amsut);
	let def_ams = GetDefaultByType(amsdef);
	
	if(ams_timer <= 0)
	{	
		// Check ammunition.
		if(def_ams.ammotype) 
		{
			if(countammo(def_ams.ammotype) < def_ams.ammouse) return;
		}
		// Check if a projectile is near us.
		ThinkerIterator ams_it = ThinkerIterator.Create("Actor");
		Actor obj;
		while(obj = Actor(ams_it.Next()))
		{
			if(obj is "AMS_Missile" || obj is "Mechbase_Actor") continue;
			if(obj)
			{	
				if( CheckSight(obj) && (obj.bMISSILE) && Distance3D(obj) < def_ams.activerange )
				{
					//console.printf("Firing AMS at: " .. obj.getTag());
					SoundEmitter.SE_Trigger("Missiles/AMS");
					amshardpoint.x += random(-5,5);
					amshardpoint.y += random(-5,5);
					vector2 offs = MDMath.VOffset(angle, 25, amshardpoint.x, 1);	
					vector3 lpos = Vec3Offset(offs.x,offs.y,(viewheight*player.crouchFactor)+amshardpoint.y);
					obj.bSHOOTABLE = true;
					let ams = AMS_Missile(Spawn(def_ams.amstype,lpos));
					if(ams)
					{
						// AMS Sound FX
						ams.tracer = obj;
						ams.master = self;
						ams_timer = def_ams.cooldown;
						ams.pitch = obj.pitch;
						ams.angle = ams.AngleTo(obj);
						// Will automatically set convengence factor in postplay.
						ams.vel = (
								cos(ams.AngleTo(obj))*cos(obj.pitch),
								sin(ams.AngleTo(obj))*cos(obj.pitch),
								-sin(obj.pitch)*5
								) * obj.speed;
						if(def_ams.ammotype) TakeAmmo(def_ams.ammotype,def_ams.ammouse);
					}
				}
			}
		}
	}
}