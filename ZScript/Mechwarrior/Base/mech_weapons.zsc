	/*************************\
	|	  Weapons Systems     |
	\*************************/
extend class MechwarriorBase;

// Vars
Actor targetenemy;
Actor prevlock;
MechTargetReticle targetreticle;
bool weapon_groupfire;
bool targetlocked;
bool weapons_fired;
int selectedGroup;
int selectedWeapon;
double locktimer;

// Normalize
void normalizeWeaponsID(int offs)
{
	int weapsid = inv_context.weapons_count-offs;
	inv_context.weapons_count -= offs;
	for(let w = Inv; w; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			ww.WeaponID = weapsid;
			weapsid--;
		}
	}
}
clearscope String resolveWeaponName(Mechbase_Weapon ww)
{	
	Array<String> weaponslot;
	weaponslot.Clear();
	String weapcheck = ww.getClassName();
	String weaptype = weapcheck;
	weapcheck.Split(weaponslot,"_");
	if(ww is weaponslot[0]) weaptype = weaponslot[0];
	//console.printf("Weapon is: %s",weaptype);
	return weaptype;
}

// Get
int getWeaponSlotsUsed(Vector2 loc)
{
	int slots = 0;
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.hardpoint.pos == loc) slots += ww.hardslots;
		}
	}
	return slots;
}
int getMaxWeaponGrouping()
{
	int mxgrp = 1;
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.group > mxgrp)mxgrp = ww.group;
		}
	}
	return mxgrp;
}
Mechbase_Weapon getSelectedWeapon()
{	
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.WeaponID == selectedWeapon) return ww;
		}
	}
	return null;
}
int getWeaponGroupAt(int ind)
{
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.WeaponID == ind) return ww.group;
		}
	}
	return 1;
}
bool, int getNextWeaponIn(int ind, int grp)
{
	int mxgrp = 0;
	bool found = false;
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.WeaponID > ind && ww.group == grp)
			{
				// /console.printf("Found: I: %d, G: %d",ww.WeaponID,ww.group);
				mxgrp = ww.WeaponID;
				found = true;
			}
		}
	}
	return found, mxgrp;
}
int getNearestWeaponAt(int group)
{
	int prevind = inv_context.weapons_count;
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if( (ww.WeaponID < prevind) && ww.group == group )
			{
				prevind = ww.WeaponID;
			}
		}
	}
	return prevind;
}

// Set
bool setWeaponGroupAt(int ind, int group)
{
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.WeaponID == ind) 
			{
				ww.group = group;
				return true;
			}
		}
	}
	return false;
}
void clearWeapons()
{
	ClearInventory();
	hardpoints.hd.slots = 0;
	hardpoints.ct.slots = 0;
	hardpoints.lt.slots = 0;
	hardpoints.rt.slots = 0;
	hardpoints.la.slots = 0;
	hardpoints.ra.slots = 0;
	hardpoints.ll.slots = 0;
	hardpoints.rl.slots = 0;
	inv_context.weapons_tonnage = 0;
	GiveInventory("WeaponsHandler",1);
	inv_context.weapons_count = 0;	
}

// Remove
void removeWeapon(Mechbase_Weapon w)
{
	// This is need because hardpoints and stuff.
	adjustTonnage(-w.weight);
	w.hardpoint.adjustHardslots(-w.hardslots);
	RemoveInventory(w);
}
bool removeWeaponAt(int ind)
{
	for(let w = Inv; w; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.WeaponID == ind)
			{
				removeWeapon(ww);
				normalizeWeaponsID(1);
				return true;
			}
		}
	}
	return false;
}

// Swap or Move
bool moveWeaponToInv(int weap_ind)
{
	for(let w = Inv; w; w = w.Inv)
	{
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.WeaponID == weap_ind)
			{
				addWeaponToInv(resolveWeaponName(ww),1,false);
				removeWeapon(ww);
				normalizeWeaponsID(1);
				return true;
			}
		}
	}
	return false;
}

// Equip or Add
bool equipWeaponInv(int ind, MechHardpoint hp, int grp, bool move=true)
{
	// Equip weapon from items
	class<Mechbase_Weapon> weap = inv_context.weapon_items[ind-1].Tag;
	if(!weap) return false;
	
	if( MDMath.RoundFloat(inv_context.weapons_tonnage+GetDefaultByType(weap).weight) > mech_tonnage && !CheckCompensative())
	{
		A_PlaySound("UI/Error",CHAN_WEAPON);
		sendHudAlert("Cannot equip weapon, over tonnage!", Font.CR_DARKRED);
		return false;
	}
	if( hp.getFreeSlots() < GetDefaultByType(weap).hardslots )
	{
		A_PlaySound("UI/Error",CHAN_WEAPON);
		sendHudAlert("Cannot equip weapon, no freeslots!", Font.CR_DARKRED);
		return false;	
	}
	 
	 // Equip weapon in inventory, don't give ammo.
	if(!equipWeapon(weap,hp,grp,false)) return false;
	if(move)inv_context.RemoveItem(ind-1, 1);
	return true;
}
bool equipWeapon(class<Mechbase_Weapon> type, MechHardpoint hp, int group, bool giveammo = true)
{
	if(checkVoodoo()) return false;
	GiveInventory(type,1);
	if(countinv(type) > 1)
	{
		int slotcheck = 1;
		Name ntype;
		// You can only have 12 of each weapon, max.
		for(int i = 1; i < 12; i++)
		{
			if(countinv( Name(type) .. "_" .. i )) continue;
			ntype = Name(type) .. "_" .. i;
			slotcheck = i;
		}
		if(!ntype)
		{
			A_PlaySound("UI/Error",CHAN_WEAPON);
			sendHudAlert("Weapon Systems Error.\nBuffer overloaded!", Font.CR_DARKRED);
			//console.printf("No free slot found for: %s",(Name(type) .. ""));
			return false;
		}
		GiveInventory(ntype,1);
		//console.printf("Obtaining another %s; slot #%d",(Name(ntype) .. ""),slotcheck);
	}
	inv_context.weapons_count++;
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.WeaponID == 0)
			{
				//console.printf("Setting new ID: %d",inv_context.weapons_count); 
				ww.WeaponID = inv_context.weapons_count;
				ww.group = group;
				ww.hardpoint = hp;
				hp.adjustHardslots(ww.hardslots);
				adjustTonnage(ww.weight);
				//console.printf("Adding Weapon: %s at %d",ww.displayName,ww.WeaponID);
			}
		}
	}
	inv_context.maxgroup = getMaxWeaponGrouping();
	return true;
}
void addWeaponToInv(String weapon,int amt=1,bool giveammo = true)
{
	if(inv_context.weapon_items.Size() == 0) inv_context.weapon_items.Clear();
	class<Mechbase_Weapon> weap = weapon;
	class<Mechbase_Utility> util = weapon;	
	for(int i = 0; i < amt; i++)inv_context.GiveItem(weapon);
}

// Next
void nextWeapon(bool gcycle=false)
{
	//console.printf("[4] %d",getNearestWeaponAt(getWeaponGroupAt(selectedWeapon)));
	if(weapon_groupfire || gcycle)
	{
		bool valid;
		int ind;
		[valid, ind] = getNextWeaponIn(selectedWeapon, getWeaponGroupAt(selectedWeapon));
		if(!valid)
		{
			selectedWeapon = getNearestWeaponAt(getWeaponGroupAt(selectedWeapon));
		}
		else
		{
			selectedWeapon = ind;
		}
	}
	else
	{
		selectedWeapon++;
	}
}

// Sort
void sortWeaponInv()
{
	Array<mw_InvStruct> newinv;
	Array<String> sortedtypes;
	GetItemsList(sortedtypes);
	newinv.Clear();
	String type;
	
	// Sort all items of unique types.
	for(int i = 0; i < sortedtypes.Size(); i++)
	{
		type = sortedtypes[i];
		type.toLower();
		for(int x = 0; x < inv_context.weapon_items.Size(); x++)
		{
			String thing = inv_context.weapon_items[x].Tag;
			thing.ToLower();
			if(thing == type)
			{
				newinv.push(inv_context.weapon_items[x]);
			}
		}
	}
	// Re-allocate
	inv_context.weapon_items.Clear();
	inv_context.weapon_items.Copy(newinv);
}

// Fire
bool FireGroup(int group, bool alpha=false, bool forcegroup=false)
{
	if(checkVoodoo()) return false;
	if(group > getMaxWeaponGrouping()) return false;
	
	if(weapon_groupfire || forcegroup)
	{
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww)
			{	
				if( (ww.group == group) || alpha) ww.MWFire();
			}
		}
	}
	else
	{
		int curgrp = getWeaponGroupAt(selectedWeapon);
		if(curgrp != group) selectedWeapon = getNearestWeaponAt(group);
		let weap = getSelectedWeapon();
		if(weap) weap.MWFire();
	}
	return true;
}
void FireWeapons(bool groupfire=true)
{
	if(checkVoodoo()) return;
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{	if(groupfire)
			{
				//int bit = 2 ** (ww.group-1);
				if(ww.group == getWeaponGroupAt(selectedWeapon))
				{
					if(!ww.MWFire() && buttonTick && !weapon_groupfire) A_PlaySound("Mech/WeaponBusy",3);
				}
			}
			else if(ww.WeaponID == selectedWeapon)
			{
				if(!ww.MWFire() && buttonTick && !weapon_groupfire && weapons_fired == 0) A_PlaySound("Mech/WeaponBusy",3);
			}
		}
	}
}


/*
bool swapWeaponToInv(int weap_ind, int inv_ind)
{
	String weaptype;
	inv_ind --;
	
	// Make sure our inventory type is a weapon!
	class<Mechbase_Weapon> invweap = inv_context.weapon_items[inv_ind].Tag;
	if(!invweap) return false;
	
	for(let w = Inv; w; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(weap_ind == ww.WeaponID)
			{
				weaptype = resolveWeaponName(ww);
				int prevweaps = inv_context.weapons_count;
				inv_context.weapons_count = ww.WeaponID-1;
				equipWeapon(inv_context.weapon_items[inv_ind].Tag,ww.hardpoint,ww.group,false);
				inv_context.weapons_count = prevweaps;
				removeWeapon(ww);
				inv_context.weapon_items[inv_ind] = weaptype;
				return true;
			}
		}
	}
	return false;
}
*/