	/*************************\
	|	  Hardpoint System    |
	\*************************/
extend class MechWarriorBase;
	
// Armor Systems
float CalculateArmorWeight(bool update=true)
{
	float apweight = GetDefaultByType("EndosteelBonus").weight;
	float aw;
	aw += hardpoints.hd.max_armor*apweight;
	aw += hardpoints.ct.max_armor*apweight;
	aw += hardpoints.lt.max_armor*apweight;
	aw += hardpoints.rt.max_armor*apweight;
	aw += hardpoints.la.max_armor*apweight;
	aw += hardpoints.ra.max_armor*apweight;
	aw += hardpoints.ll.max_armor*apweight;
	aw += hardpoints.rl.max_armor*apweight;
	
	// Over-max armor weight.
	if(hardpoints.hd.armor > hardpoints.hd.max_armor) aw += int(hardpoints.hd.armor-hardpoints.hd.max_armor)*apweight;
	if(hardpoints.ct.armor > hardpoints.ct.max_armor) aw += int(hardpoints.ct.armor-hardpoints.ct.max_armor)*apweight;
	if(hardpoints.lt.armor > hardpoints.ct.max_armor) aw += int(hardpoints.lt.armor-hardpoints.lt.max_armor)*apweight;
	if(hardpoints.rt.armor > hardpoints.rt.max_armor) aw += int(hardpoints.rt.armor-hardpoints.rt.max_armor)*apweight;
	if(hardpoints.la.armor > hardpoints.la.max_armor) aw += int(hardpoints.la.armor-hardpoints.la.max_armor)*apweight;
	if(hardpoints.ra.armor > hardpoints.ra.max_armor) aw += int(hardpoints.ra.armor-hardpoints.ra.max_armor)*apweight;
	if(hardpoints.ll.armor > hardpoints.ll.max_armor) aw += int(hardpoints.ll.armor-hardpoints.ll.max_armor)*apweight;
	if(hardpoints.rl.armor > hardpoints.rl.max_armor) aw += int(hardpoints.rl.armor-hardpoints.rl.max_armor)*apweight;
	
	if(update) 
	{
		adjustTonnage(-inv_context.armor_tonnage);
		inv_context.armor_tonnage = aw;
		adjustTonnage(inv_context.armor_tonnage);
	}
	
	return aw;
}

bool AddArmorWeight(int amt)
{
	double addtons = GetDefaultByType("EndosteelBonus").weight*amt;
	float correctedtons = MDMath.RoundFloat(inv_context.weapons_tonnage+addtons);
	if(correctedtons > mech_tonnage && !CheckCompensative()) return false;
	adjustTonnage(-inv_context.armor_tonnage);
	inv_context.armor_tonnage += addtons;
	adjustTonnage(inv_context.armor_tonnage);
	return true;
}

bool AdjustMaxArmor(MechHardpoint hp, int amt, bool clampmaxarmor=false)
{
	if(hp.armor > hp.max_armor && amt < 0) 
	{
		hp.armor+=amt;
		A_GiveInventory("EndoSteelBonus", abs(amt));
		AddArmorWeight(amt);
		return true;
	}
	
	if(hp.max_armor+amt < 0) return false;
	if(hp.max_armor+amt > hp.defmax_armor && clampmaxarmor) return false;
	if(hp.max_armor+amt < hp.armor) 
	{
		int diff = hp.armor-hp.max_armor;
		A_GiveInventory("EndoSteelBonus",diff);
		hp.armor = hp.max_armor+amt;
	}
	
	double addtons = GetDefaultByType("EndosteelBonus").weight*amt;
	float correctedtons = MDMath.RoundFloat(inv_context.weapons_tonnage+addtons);
	if(correctedtons > mech_tonnage && !CheckCompensative()) return false;
	hp.max_armor += amt;
	adjustTonnage(-inv_context.armor_tonnage);
	inv_context.armor_tonnage += addtons;
	adjustTonnage(inv_context.armor_tonnage);
	return true;
}
	
// Repair System
clearscope int CalculateHardpointRepairCost(MechHardpoint hp, int stat)
{
	int repair_cost = 0;
	float armor_ratio = hp.defmax_armor <= 0 ? 0 : 1.0 - (!hp.armor ? 1 : hp.armor)/hp.defmax_armor;
	float internalhp_ratio = 1.0 - (!hp.internalhp ? 1 : hp.internalhp)/hp.max_internal;
	if(stat == 0 && 	 armor_ratio > 0 ) repair_cost = (4750*armor_ratio)+(hp.defmax_armor*50);
	if(stat == 1 && internalhp_ratio > 0 ) repair_cost = (1250*internalhp_ratio)+(hp.max_internal*25);
	return repair_cost;
}
void RepairHardpointStat(int hindex, int stat)
{
	MechHardpoint hp = hardpoints.FindByIndex(hindex);
	int cost = CalculateHardpointRepairCost(hp,stat);
	if(inv_context.money_cbills < cost) 
	{
		sendHudAlert("Insufficient funds!",Font.CR_DARKRED);
	}
	else
	{
		inv_context.money_cbills -= cost;
		_DoHardpointRepair(hp, stat);
	}
}
void _DoHardpointRepair(MechHardpoint hp, int stats)
{
	if(stats == 0) 
	{
		hp.armor = hp.defmax_armor;
		hp.max_armor = hp.defmax_armor;
	}
	if(stats == 1) 
	{
		// Repair structures and weapons.
		Array<FoundStruct> items;
		getStructsIn(hp,items);
		for(int i = 0; i < items.Size(); i++) 
		{
			items[i].obj.broken = false;
			items[i].obj.dmg_taken = 0;
		}
		for(let w = Inv; w != null; w = w.Inv)
		{	
			let ww = Mechbase_Weapon(w);
			if(ww && ww.hardpoint == hp) ww.dmg_taken = 0;
		}
		hp.internalhp = hp.max_internal;	
	}
	sendHudAlert("Hardpoint repaired!",Font.CR_GREEN);
}
void ActivateArmorUtility(class<ArmoryUtility> type, int hindex)
{	
	if(countinv(type) > 0)
	{
		let autil = ArmoryUtility(FindInventory(type));
		let hp = hardpoints.FindByIndex(hindex);
		if(hp) autil.EquipUtil(self,hp);
	}
}

// Damage System
void DamageCritSounds(MechHardpoint hp)
{
	A_PlaySound("Mech/Damaged/Critical",3);
	mechsounds.pushSound("Mech/Betty/CriticalHit");
	if(hp == hardpoints.lt) mechsounds.pushSound("Mech/Betty/LeftTorso");
	if(hp == hardpoints.rt) mechsounds.pushSound("Mech/Betty/RightTorso");
	if(hp == hardpoints.la) mechsounds.pushSound("Mech/Betty/LeftArm");
	if(hp == hardpoints.ra) mechsounds.pushSound("Mech/Betty/RightArm");
	if(hp == hardpoints.ll) mechsounds.pushSound("Mech/Betty/LeftLeg");
	if(hp == hardpoints.rl) mechsounds.pushSound("Mech/Betty/RightLeg");
	if(hp == hardpoints.ct) mechsounds.pushSound("Mech/Betty/CenterTorso");
}

void DamageHardpoint(MechHardpoint hp, float dmg, bool noarmor=false)
{
	// Update for over-max armor, via EndosteelBonuses.
	if(hp.armor > 0 && !noarmor) 
	{
		bool overarmor = (hp.armor > hp.max_armor);
		if(hp.armor-dmg <= 0) A_PlaySound("Mech/Damaged/NoArmor",1);
		// Random chance armor doesn't absorb the remaining damage.
		if(dmg > hp.armor && random(1,3)==3) 
		{
			hp.armor = 0;
			DamageHardpoint(hp,dmg-hp.armor,random(0,1));
		}
		else
		{
			hp.armor -= dmg;
			if(hp.armor < 0) 
			{
				hp.armor = 0;
			}
		}
		
		// Change armor weight if we're using an armor powerup and it's receiving damage.
		if(overarmor) CalculateArmorWeight();
	}
	else if(hp.internalhp > 0)
	{
		if(random(0,5)==5)
		{
			if(random(0,1)==1)
				DamageHardpointWeapons(hp,50*random(1,2));
			else
				DamageHardpointStruct(hp,50*random(1,2));
		}
	
		hp.internalhp -= dmg/2;
		if(hp.internalhp <= 0) 
		{
			hp.internalhp = 0;
			if( random(1,3)==3 ) 
			{
				SpreadHardpointDamage(hp,dmg/2);
				A_PlaySound("Mech/Damaged/Explosion",3);
			}
		
			A_PlaySound("Mech/Damaged/HardpointDead",3);
			if(hp == hardpoints.lt) mechsounds.pushSound("Mech/Betty/LeftTorso");
			if(hp == hardpoints.rt) mechsounds.pushSound("Mech/Betty/RightTorso");
			if(hp == hardpoints.la) mechsounds.pushSound("Mech/Betty/LeftArm");
			if(hp == hardpoints.ra) mechsounds.pushSound("Mech/Betty/RightArm");
			if(hp == hardpoints.ll) mechsounds.pushSound("Mech/Betty/LeftLeg");
			if(hp == hardpoints.rl) mechsounds.pushSound("Mech/Betty/RightLeg");
			if(hp != hardpoints.ct) mechsounds.pushSound("Mech/Betty/Destroyed");

			DestroyHardpointItems(hp);
		}
	}
	else
	{
		SpreadHardpointDamage(hp,dmg);
	}
}
void ProcessHardpointDamage(Name mod, float damage, Actor damager = NULL)
{	
	bool heatdmg = ( mod == "overheating" );
	if(mod == "MechDamage_CT" || (heatdmg && random(1,5)==5) ) DamageHardpoint(hardpoints.ct,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_LT" || (heatdmg && random(1,3)==3) ) DamageHardpoint(hardpoints.lt,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_RT" || (heatdmg && random(1,3)==3) ) DamageHardpoint(hardpoints.rt,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_LA" || (heatdmg && random(1,4)==4) ) DamageHardpoint(hardpoints.la,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_RA" || (heatdmg && random(1,4)==4) ) DamageHardpoint(hardpoints.ra,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_LL" || (heatdmg && random(1,7)==7) ) DamageHardpoint(hardpoints.ll,damage,heatdmg&&random(0,1));
	if(mod == "MechDamage_RL" || (heatdmg && random(1,7)==7) ) DamageHardpoint(hardpoints.rl,damage,heatdmg&&random(0,1));
	
	if( inv_context.engine && (inv_context.engine.ltslots+inv_context.engine.rtslots) > 2 )
	{
		if((hardpoints.lt.internalhp <= 0 || hardpoints.rt.internalhp <= 0) && (mechtype != MechType_Clan)) ProcessDeath(damager);
		if((hardpoints.lt.internalhp <= 0 && hardpoints.rt.internalhp <= 0) && (mechtype == MechType_Clan)) ProcessDeath(damager);
	}
	if(  hardpoints.hd.internalhp <= 0 || hardpoints.ct.internalhp <= 0 ||
		(hardpoints.ll.internalhp <= 0 && hardpoints.rl.internalhp <= 0)   ) 
	{
		ProcessDeath(damager);
	}
}
void SpreadHardpointDamage(MechHardpoint hp, float dmg)
{
	if(hp == hardpoints.la) DamageHardpoint(hardpoints.lt,dmg/2);
	if(hp == hardpoints.ra) DamageHardpoint(hardpoints.rt,dmg/2);
	if(hp == hardpoints.lt) DamageHardpoint(hardpoints.ct,dmg/4);
	if(hp == hardpoints.rt) DamageHardpoint(hardpoints.ct,dmg/4);
}
void DamageHardpointStruct(MechHardpoint hp, int amt=50)
{
	Array<FoundStruct> items;
	getStructsIn(hp,items);
	if(!items.Size()) return;
	let item = items[random(0,items.Size()-1)];
	let ut = GetDefaultByType(utilcast(item.obj.Tag));
	if(ut.takesnodamage) return;
	
	//console.printf("Struct damage :> %s :: %d",item.obj.Tag,item.obj.dmg_taken);
	if(!item.obj.broken) item.obj.dmg_taken+=amt;
	if(item.obj.dmg_taken >= 100) 
	{
		class<Mechbase_Ammo> am = item.obj.Tag;
		item.obj.broken = true;
		if(ut.moveable)
		{
			DamageCritSounds(hp);
			class<Heatsink> hs = item.obj.Tag;
			if(hs) 
			{
				mechsounds.pushSound("Mech/Betty/Heatsink");
				mechsounds.pushSound("Mech/Betty/Destroyed");
			}
			if(am)
			{	
				// INTERNAL AMMO EXPLOSION DETECTED
				mechsounds.pushSound("Mech/Betty/AmmoExplosion");
				mw_InvStruct stcase;
				int stcaseind;
				[stcase, stcaseind] = FindHealthyStruct("C_A_S_E",hp);
				if(!stcase)
				{
					DamageHardpoint(hp,30,true);
					if( mechtype != MechType_Clan ) SpreadHardpointDamage(hp,20);
				}
				else
					inv_context.mechstructs.delete(stcaseind);
			}
			hp.adjustHardslots(-ut.hardslots);
			adjustTonnage(-ut.weight);
			inv_context.mechstructs.delete(item.realindex);
		}
		else 
		{
			A_PlaySound("Mech/Damaged/Critical",3);
			mechsounds.pushSound("Mech/Betty/CriticalHit");
			
			class<StructGyro> gyro = item.obj.Tag;
			class<StructEngine> engine = item.obj.Tag;
			class<StructHip> hip = item.obj.Tag;
			if(gyro) mechsounds.pushSound("Mech/Betty/Gyro");
			if(engine) mechsounds.pushSound("Mech/Betty/Engine");
			if(hip) mechsounds.pushSound("Mech/Betty/Hip");
		}
	}
	for(int i = 0; i < items.Size(); i++)
	{
		if(items[i].obj.broken) items.delete(i);
	}
}
void DamageHardpointWeapons(MechHardpoint hp, int amt=50)
{
	int index = 0;
	if(inv_context.weapons_count < 1) return;
	int weapind = random(0,inv_context.weapons_count-1);
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww && ww.hardpoint == hp)
		{
			if(index == weapind) 
			{	
				//console.printf("Weapon damage :> %s ",ww.getClassName());
				ww.dmg_taken += amt;
				if(ww.dmg_taken >= 100)
				{
					DamageCritSounds(hp);
					removeWeapon(ww);
					normalizeWeaponsID(1);
					mechsounds.pushSound("Mech/Betty/WeaponDestroyed");
				}
			}
			index++;
		}
	}
}
void DestroyHardpointItems(MechHardpoint hp, bool recurse=true)
{
	for(let w = Inv; w != null; w = w.Inv)
	{	
		let ww = Mechbase_Weapon(w);
		if(ww)
		{
			if(ww.hardpoint == hp) 
			{
				removeWeapon(ww);
				normalizeWeaponsID(1);
				mechsounds.pushSound("Mech/Betty/WeaponDestroyed");
				if(recurse) DestroyHardpointItems(hp,recurse);
			}
		}
	}
	DestroyHardpointStructs(hp,recurse);
}
void DestroyHardpointStructs(MechHardpoint hp, bool recurse=true)
{
	for(int i = 0; i < inv_context.mechstructs.Size(); i++)
	{
		MechHardpoint sthardpoint = inv_context.mechstructs[i].hardpoint;
		let ut = GetDefaultByType(utilcast(inv_context.mechstructs[i].Tag));
		
		if(sthardpoint == hp && ut.moveable)
		{
			class<Heatsink> hs = inv_context.mechstructs[i].Tag;
			if(hs) 
			{
				mechsounds.pushSound("Mech/Betty/Heatsink");
				mechsounds.pushSound("Mech/Betty/Destroyed");
			}
			hp.adjustHardslots(-ut.hardslots);
			adjustTonnage(-ut.weight);
			inv_context.mechstructs.delete(i);
			if(recurse) DestroyHardpointStructs(hp,recurse);
		}
	}
}
void HardpointDamageEffects()
{	
	// Process hardpoint damage effects
	if( hardpoints.ll.internalhp <= 0 || 
		hardpoints.rl.internalhp <= 0   )
	{
		throttle_max = 0.5;
		LegSpeed = 1;
	}
	else if(countStructDamaged("StructEngine",true))
	{
		throttle_max = 0.8;
		LegSpeed = default.LegSpeed;
	}
	else
	{
		throttle_max = 1.0;
		LegSpeed = default.LegSpeed;
	}
}