	/*************************\
	|	  Movement System     |
	\*************************/
extend class MechWarriorBase;

// Properties
bool defaultmovement;
bool uncappedtorso;
bool autopilot;
bool autopilot_finish;

double minPitch, maxPitch;
double LegSpeed;
double MoveSpeedKPH;
double MaxYaw;

// Vars
bool snd_reactor;
bool snd_accelerate;
bool Mech_HasJets;
bool doShutdown;
bool mech_shutdown;
bool zoomed_in;
bool canShutdown;
bool manualshutdown;
bool stepping;
bool nofirstpersonlegs;
bool reversing;

int Mech_JetCount;
int bobdir;
int shutdown_timer;

double LegAng;
double LegDelta;
double lockpitch;
double lockangle;
double MoveSpeed;
double MoveSpeed_Max;
double throttle;
double throttle_max;
double move_throttle;
double move_accel;
double mech_jetsfuel;
double LookVel;
double LegVel;
double overfactor;
double rolloffs;

// Bobbing
double boboffs;
double desiredbob;
double TiltOsc;
double StepOsc;
double TiltOffset;
double StepOffset;
double CrouchMulti;
double rolldistort;
double defviewz;
double viewzoffs;  // Bob modifier for actual viewz.


// Autopilot
void ToggleAutopilot(bool forceoff = false)
{
	// Only autopilot to target
	if(!targetenemy) return;
	
	autopilot = forceoff ? false : !autopilot;
	autopilot_finish = false;
	
	mechSounds.PushSound("Mech/Betty/Autopilot");
	if(autopilot) 
	{
		Cockpit_Alert("\c[GREEN]Autopilot: Engaged");
		mechSounds.PushSound("Mech/Betty/Engaged");
	}
	else
	{
		Cockpit_Alert("\c[GREEN]Autopilot: Disabled");
		mechSounds.PushSound("Mech/Betty/Disabled");
	}
}
void DoAutopilot()
{
	if(!targetenemy) 
	{
		ToggleAutopilot(true);
		return;
	}
	
	bool reached = Distance3D(targetenemy) <= 128;
	double adiff = MDMath.NormalizeAngle( LegAng - AngleTo(targetenemy) );
	
	FLineTraceData lt;
	LookExParams lookp;
	lookp.FOV = 180;
	lookp.maxDist = double.infinity;
	bool cansee = IsVisible(targetenemy,true,lookp);
	
	// Find colliding wall, slide against normal.
	LineTrace(LegAng,64,0,TRF_THRUACTORS|TRF_THRUBLOCK|TRF_ABSOFFSET,20,0,0,lt);
	if(lt.HitLine)
	{
		double wnormal = VectorAngle(lt.HitLine.delta.x, lt.HitLine.delta.y);
		int sign = wnormal > 0 ? 1 : -1;
		if( abs(wnormal) == 180 ) wnormal = 160 * sign;
		double walloffs = 180;
		adiff = MDMath.NormalizeAngle(LegAng - wnormal+walloffs);
	}
	
	if(adiff > 0) LegAng -=  LegSpeed;
	if(adiff < 0) LegAng +=  LegSpeed;
	double yaw = MDMath.NormalizeAngle(angle-LegAng);
	if(abs(yaw) >= 2)
	{
		if(!pilotlook)
		{
			if(yaw > 0)angle-=2;
			if(yaw < 0)angle+=2;
			if(pitch > 0)pitch-=2;
			if(pitch < 0)pitch+=2;
		}
		if(abs(yaw) < 2) angle = LegAng;
		// Make sure we actually slide if a wall is in our way.
		if(throttle > 0 && !lt.HitLine) throttle -= 0.02;
	}
	if( ((!reached && abs(adiff) <= LegSpeed) || lt.HitLine) && !autopilot_finish )
	{
		throttle += 0.02;
		if(snd_accelerate){ A_PlaySound("Mech/AccelFromStop",1); snd_accelerate = false; }
	}
	
	if(reached && !autopilot_finish)
	{
		autopilot_finish = true;
	}
	if(autopilot_finish)
	{
		if(throttle > 0)
		{
			throttle -= 0.02;
			if(!snd_accelerate){ A_PlaySound("Mech/DeccelToStop",1); snd_accelerate = true; }
		}
		if(throttle < 0 && NAVPoint(targetenemy))
		{
			let newNAV = NAVPoint.NextNAV( NAVPoint(targetenemy).SEQ );
			
			if(newNAV == targetenemy || !newNAV)
				ToggleAutopilot(true);
			else
			{
				mechsounds.PushSound("Mech/NavBlip");
				targetenemy = newNAV;
				autopilot_finish = false;
			}
		}
		else if(!NAVPoint(targetenemy))
		{
			ToggleAutopilot(true);	
		}
	}
	
	// Disable autopilot if player is trying to move.
	if( countinv("IBTN_STOP")   ||
		countinv("IBTN_CENTER") ||
		countinv("IBTN_CENTERTORSO") ) ToggleAutopilot(true);

	if(GetPlayerInput(INPUT_FORWARDMOVE) > 0) ToggleAutopilot(true);
	if(GetPlayerInput(INPUT_FORWARDMOVE) < 0) ToggleAutopilot(true);
	if(GetPlayerInput(INPUT_SIDEMOVE)    > 0) ToggleAutopilot(true);	
	if(GetPlayerInput(INPUT_SIDEMOVE)    < 0) ToggleAutopilot(true);	
}

// Main
void setupSpeedKPH(double kph)
{
	MoveSpeedKPH = kph;
	MoveSpeed = ((kph*(10.0/36.0))/35.0) * (34*MWGAMEPLAY_MECHSPEEDSCALE);
	MoveSpeed_Max = MoveSpeed;
	
	//kph_default = 25000; //75000
	//kph_real = 25000/MWGAMEPLAY_MECHSPEEDSCALE;
	//MoveSpeed = ceil((MoveSpeedKPH*15000)/kph_real);
}

void mech_cockpitbob()
{
	// Calculate Bob
	double movebobpart = MW_VELBOBFRAC;
	double bobthrust = 0;
	double tonmod = defaultmovement ? mech_tonnage/100.0 : clamp(mech_tonnage,50,100)/100.0;
	double bobmax = MW_BOBRANGE*tonmod;
	if(defaultmovement) bobmax *= 10;
	if(!bobdir) bobdir = 1;
	if(vel.z >  0.5) bobdir = 1;
	if(vel.z < -0.5) bobdir = -1;
	if(vel.length() > 0.08 || LegVel)
	{
		// 0.12
		double realvel = vel.length()+(LegVel**2);
		bobthrust = clamp(realvel*(movebobpart*MoveSpeed), -(bobmax/3), (bobmax/3));
		if(stepping) 
		{ 
			bobthrust = abs(bobthrust)*4;
			bobdir = 1;
		}
		boboffs += bobthrust * bobdir;
	}
	if(mech_shutdown)
	{
		bobdir = 1;
		bobthrust = bobmax;
	}
	if(abs(boboffs) > bobmax) 
	{
		bobdir *= -1;	
		boboffs = clamp(boboffs,-bobmax,bobmax);
	}
	if(mech_models)
	{
		// Calculate gyroscopics
		double gfactor = GetDefaultByType("StructGyro").power;
		double gyros = countStruct("StructGyro") - countStructDamaged("StructGyro",true);
		double bfactor = 2.76-(gyros*gfactor);
		double bobmod = boboffs*clamp( (bfactor*(mech_tonnage/100.0)), 1.2, 3.15);
		if(defaultmovement) bobmod *= 0.55;
		Player.ViewZ -= bobmod;
		viewzoffs = (Player.ViewZ-pos.z)-defviewz;
	}
}

void mech_movement()
{
	if(!player || isdead) return;
	if(!CheckCompensative() && mech_shutdown) return;
	if(autopilot) DoAutopilot();
	
	// Movement Quirks
	if(defaultmovement && inv_context)
	{			
		if(!inv_context.engine && !CheckCompensative()) return;
		// Roll/Sway system
		uint btns = player.cmd.buttons;
		bool strafing = (btns & BT_MOVELEFT) | (btns & BT_MOVERIGHT);
		if(btns & BT_MOVELEFT) rolloffs -= 1;
		if(btns & BT_MOVERIGHT) rolloffs += 1;
		if(!strafing) rolloffs *= 0.90;
		if(abs(rolloffs) < 0.2) rolloffs = 0;
		rolloffs = clamp(rolloffs,-2.25,2.25);
		
		if( rolloffs != 0 ) A_SetRoll(rolloffs);
	}
	// Overtonnage logic
	if(CheckCompensative())
	{
		if(!inv_context.engine) 
		{
			MoveSpeedKPH = 10;
			setupSpeedKPH(10);
		}
		else
		{
			setupSpeedKPH(clamp(EngineGetKPH(),0,200));
		}
		double truetonnage = mech_shutdown ? mech_tonnage*0.25 : mech_tonnage;
		overfactor = clamp( (truetonnage/(inv_context.weapons_tonnage))*1.4, 0.1, 1.0);
		setupSpeedKPH(EngineGetKPH()*overfactor);
		double finalspd = clamp(MoveSpeed*0.3*overfactor*throttle_max, 0.1, 1.45);
		A_SetSpeed(finalspd);
	}
	
	// Leg Movement
	if(!defaultmovement)
	{
		// Move mech by a percentage of throttle.
		if(!stepping) 
		{
			double accel = ((1000/mech_tonnage)/100) * (0.12*move_accel);
			move_throttle = MDMath.Lerp( move_throttle, throttle, clamp(accel,0.008,0.4) );
			vel = (cos(LegAng)*(move_throttle*MoveSpeed),sin(LegAng)*(move_throttle*MoveSpeed),vel.z);
		}
		
		// Speed decay when engine removed.
		if(!inv_context || !inv_context.engine)
		{
			if(abs(throttle) > 0.05)
			{
				throttle *= 0.97;
			}
			else if(MoveSpeedKPH > 0)
			{
				throttle = 0;
				setupSpeedKPH(0);
			}
			return;
		}
			
		if(throttle == 0) snd_accelerate = true;
		if(GetPlayerInput(INPUT_FORWARDMOVE) > 0)
		{
			bool prevaccel = GetPlayerInput(INPUT_OLDBUTTONS) & BT_FORWARD;
			throttle += 0.02;	
			if(throttle > 0 && reversing) 
			{
				if(prevaccel) 
					throttle = 0;
				else
					reversing = false;
			}
			
			// If stop is pressed and we continue moving, we don't want the two "forces" to fight.
			TakeInventory("IBTN_STOP",1);
			if(snd_accelerate){ A_PlaySound("Mech/AccelFromStop",1); snd_accelerate = false; }
		}
		else if(CVar.FindCVar("mwd_throttledecay").getInt() == 1 && throttle > 0.02)
		{
			throttle -= 0.02;
			if(!snd_accelerate){ A_PlaySound("Mech/DeccelToStop",1); snd_accelerate = true; }
		}
		
		if(GetPlayerInput(INPUT_FORWARDMOVE) < 0) 
		{
			bool prevdecel = GetPlayerInput(INPUT_OLDBUTTONS) & BT_BACK;
			throttle -= 0.02;
			if(throttle < 0 && !reversing) 
			{
				if(prevdecel) 
					throttle = 0;
				else
					reversing = true;
			}	
				
			TakeInventory("IBTN_STOP",1);
			if(!snd_accelerate){ A_PlaySound("Mech/DeccelToStop",1); snd_accelerate = true; }
		}
		else if(CVar.FindCVar("mwd_throttledecay").getInt() == 1 && throttle < 0)
		{
			throttle += 0.02;
			if(snd_accelerate){ A_PlaySound("Mech/AccelFromStop",1); snd_accelerate = false; }
		}
		
		throttle = clamp(throttle,-(throttle_max/2),throttle_max);
		
		if(throttle > 0.5 && !snd_reactor)
		{
			A_PlaySound("Mech/ReactorHum",CHAN_ITEM,0.3,1);
			snd_reactor = true;
		}
		else if(throttle < 0.5 && snd_reactor)
		{
			A_StopSound(CHAN_ITEM);
			snd_reactor = false;
		}
		
		if(!pilotlook)
		{
			if(GetPlayerInput(INPUT_SIDEMOVE) > 0)
			{
				TakeInventory("IBTN_CENTER",1);
				LegVel = -LegSpeed;
				LookVel = -LegSpeed;
			}
			if(GetPlayerInput(INPUT_SIDEMOVE) < 0 )
			{
				TakeInventory("IBTN_CENTER",1);
				LegVel = LegSpeed;
				LookVel = LegSpeed;
			}		
		}
		if( !floor(GetPlayerInput(INPUT_SIDEMOVE)*10) )
		{
			LookVel = 0;
			LegVel = 0;
		}
		   
		if(countinv("IBTN_STOP"))
		{
			if(abs(throttle) <= 0.1)TakeInventory("IBTN_STOP",1);
			if(throttle < 0)throttle += 0.02;
			if(throttle > 0)throttle -= 0.02;
			if(!snd_accelerate){A_PlaySound("Mech/DeccelToStop",1); snd_accelerate = true;}
			if(abs(throttle) <= 0.1)throttle = 0;
		}
		if(countinv("IBTN_CENTER"))
		{
			double yaw = MDMath.NormalizeAngle(angle-LegAng);
			if(yaw > 0) LegVel =  LegSpeed;
			if(yaw < 0) LegVel = -LegSpeed;
			if(abs(yaw) < LegSpeed*2) 
			{	
				LegAng = angle;
				LegVel = 0;
				TakeInventory("IBTN_CENTER",1);
			}
			if(abs(yaw) <= 0.1)TakeInventory("IBTN_CENTER",1);
		}
		if(countinv("IBTN_CENTERTORSO"))
		{
			double yaw = MDMath.NormalizeAngle(angle-LegAng);
			if(yaw > 0)angle-=2;
			if(yaw < 0)angle+=2;
			if(pitch > 0)pitch-=2;
			if(pitch < 0)pitch+=2;
			if(abs(yaw) < 2)
			{
				angle = LegAng;
				TakeInventory("IBTN_CENTERTORSO",1);
			}
			if(abs(yaw) <= 0.1)TakeInventory("IBTN_CENTERTORSO",1);
		}
		
		// Roll distortion when looking far up/down at odd leg angle.
		rolldistort = ( (cos((angle-LegAng)-90) * pitch) - (cos(angle) * (sin(pitch)*5)) )*0.5;
		if( !pilotlook && !mech_shutdown && (!models_reference || !models_reference.noroll) ) 
			A_SetRoll( roll + rolldistort );
	
		double curspd = MoveSpeedKPH*move_throttle;
		double turnmod = clamp(1.0/(mech_tonnage/100), 0.5, 2);
		double spdmod = 1.0 - (abs(curspd)/2)*0.007;	
		
		// If we're in the air we can move our legs freely of friction.
		double finalmod = (player.onground ? turnmod*spdmod : 2);
		finalmod = clamp(finalmod, 0.15, 2);
		if(!CVar.GetCVar("mwd_relativelegspeed",player).getBool()) finalmod = clamp(finalmod, turnmod*LegSpeed, 2);
		
		// Leg Delta gets how much the leg angle changed between movement.
		// This conditionally does not track when center button is active.
		LegDelta = !countinv("IBTN_CENTER") ? (LegVel*finalmod)*2 : 0;
		
		LegAng += LegVel*finalmod;
		angle  += LookVel*finalmod;
	
		if( !mech_shutdown )
		{
			if(!pilotlook) Pitch = clamp(Pitch, -minPitch, maxPitch);
			if(MaxYaw < 360 && !uncappedtorso && !pilotlook)
			{
				if(angle - LegAng > MaxYaw)  angle = LegAng + MaxYaw;
				if(angle - LegAng < -MaxYaw) angle = LegAng - MaxYaw;
			}
		}
	}
	else
	{
		// Set leg angle to looking angle.
		LegAng = angle;
	}
	
	if( (GetPlayerInput(INPUT_BUTTONS) & BT_JUMP) && Mech_HasJets && mech_jetsfuel > 0)
	{
		class<JumpJet> jj = "JumpJet";
		double truetonnage = CheckCompensative() ? inv_context.weapons_tonnage : mech_tonnage;
		double tonmod = 100-( truetonnage-(5*Mech_JetCount) );
		double zthrust = ( Mech_JetCount * GetDefaultByType(jj).thrust_power ) * ( tonmod/100 ) + ((mech_jetsfuel/100)*2);
		vel.z = zthrust * (defaultmovement ? 2 : 1);
		mech_jetsfuel -= 1;
		A_PlaySound("Mech/JetLoop",5,1,1);
	} 
	else if(!btn_jumpjets && mech_jetsfuel > 0)
	{
		A_StopSound(5);
	}
	
	if(btn_jumpjets && Mech_HasJets && mech_jetsfuel > 0)
	{
		class<JumpJet> jj = "JumpJet";
		double tonmod = 100-( mech_tonnage-(5*Mech_JetCount) );
		vel.z = ( Mech_JetCount * GetDefaultByType(jj).thrust_power ) * ( tonmod/100 ) + ((mech_jetsfuel/100)*2);
		mech_jetsfuel -= 1;
		A_PlaySound("Mech/JetLoop",5,1,1);
	} 
	else if ( !((GetPlayerInput(INPUT_BUTTONS) & BT_JUMP) && mech_jetsfuel > 0))
	{
		A_StopSound(5);
	}
	
	if( (GetPlayerInput(0) & BT_ZOOM) )
	{
		if(player.DesiredFOV > 30)
		{
			player.DesiredFOV -= 3;
			A_PlaySound("Mech/Zoom",7,1,1);
		}
		else
		{
			A_StopSound(7);
		}
	}
	else
	{
		double trueFOV = CVar.GetCVar("mwd_CockpitFOV", player).getFloat();
		if(player.DesiredFOV < trueFOV)
		{
			player.DesiredFOV += 3;
			A_PlaySound("Mech/Zoom",7,1,1);
		}
		else
		{
			player.DesiredFOV = trueFOV;
			A_StopSound(7);
		}
	}

	// Cool utilities for easier pilotability!
	if(countinv("IBTN_OVERRIDE"))
	{
		if(!doShutdown)
		{
			TakeInventory("IBTN_OVERRIDE",1);
		}
		else
		{
			Cockpit_Alert("\c[SAPPHIRE]Shutdown overridden.");
			doShutdown = false;
			shutdown_timer = ticks;
			A_PlaySound("Mech/Override",1);
			mechsounds.pushSound("Mech/Betty/ShutdownOverride");
			TakeInventory("IBTN_OVERRIDE",1);
		}
	}
	
	if(countStruct("JumpJet") > 0 && mech_jetsfuel < 100 && 
	 !(GetPlayerInput(INPUT_BUTTONS) & BT_JUMP) &&
	 !btn_jumpjets && player.OnGround) mech_jetsfuel += 0.5;
}

void process_shutdown()
{
	if(!defaultmovement && !modelcockpit)
	{	
		angle = lockangle;
		pitch = lockpitch;
	}
	if(!manualshutdown)
	{	
		// Prevent powerup only to shutdown once again.
		if(countinv("IBTN_SHUTDOWN")) TakeInventory("IBTN_SHUTDOWN",1);
		
		if(throttle > 0)throttle -= 0.1;
		if(throttle < 0)throttle += 0.1;
		if( ((ticks - shutdown_timer) > 35) && HeatLevel <= (MWHEAT_MAX*0.2) && doShutdown)
		{
			// If we are very efficiently cooled, powerup early
			prevticks = ticks;
			mechsounds.pushSound("Mech/Betty/SystemsCheck");
			A_PlaySound("Mech/Power",2);
			mechsounds.pushSound("Mech/StartupDone");
			doShutdown = false;
			Cockpit_Alert("\c[GREEN]Reactor powering up...", 30);
		}
		if(!doShutdown && (ticks-prevticks) > 35*5)powerup();
		if(HeatLevel > 0)HeatLevel -= HeatEfficiency*3.0;
	}
	else
	{
		if(countinv("IBTN_SHUTDOWN") && !forceshutdown)
		{
			doShutdown = false;
			mechsounds.pushSound("Mech/Betty/SystemsCheck");
			A_PlaySound("Mech/Power",2);
			mechsounds.pushSound("Mech/StartupDone");
			manualshutdown = false;
			TakeInventory("IBTN_SHUTDOWN",1);
			prevticks = ticks;
			Cockpit_Alert("\c[GREEN]Reactor powering up...", 30);
		}
	}
	ticks++;
}
void powerup()
{
	mech_shutdown = false;
	doShutdown = false;
}

// Bobbing
void Bobbing() {
	// Don't bob on voodoos!
	if(!player || !player.mo || player.mo != self) return;
	
	double tiltosc_amp =  10 + (vel.Length()/4);
	double steposc_amp =  15 + (vel.Length()/2);
	tiltosc_amp = clamp(tiltosc_amp,0,18);
	steposc_amp = clamp(steposc_amp,0,24);
	TiltOsc += tiltosc_amp;
	StepOsc += steposc_amp;
	
	CrouchMulti = 2 - Player.CrouchFactor;

	if (TiltOsc >= 360.0 || TiltOsc < 0.0)    {
		TiltOsc = 0.0;
	}
	if (StepOsc >= 360.0 || StepOsc < 0.0)    {
		StepOsc = 0.0;
	}

	int vel = vel.length();
	if(vel != 0)
	{
		TiltOffset  = sin(TiltOsc);
		TiltOffset *= clamp((vel/2) - (LegVel*0.8), 0.05, 5.0);
		TiltOffset *= 0.21;
		if(defaultmovement) TiltOffset *= 0.6;
		TiltOffset *= rolldistort*0.21;

		StepOffset  = sin(StepOsc);
		StepOffset *= (vel/2) + (LegVel*2);
		StepOffset *= (1.78 + ((mech_tonnage)/100));
		StepOffset *= 0.54;
		if(defaultmovement) StepOffset *= 0.7;
		StepOffset *= CrouchMulti;
	}
	
	A_SetRoll(-TiltOffset);
	//SetOrigin(Vec3Angle(TiltOffset * 0.5, angle+90, 0, false), true);
	if(!mech_models) Player.ViewZ += StepOffset;
}