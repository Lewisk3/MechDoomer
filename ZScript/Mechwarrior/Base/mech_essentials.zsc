	/*****************************\
	|	  Essential Functions     |
	\*****************************/
extend class MechwarriorBase;

// Vars
class<MechwarriorBase> baseclass;
mw_InvInfo inv_context;
MechHardpoints hardpoints;
HudAlert hAlert;
SoundQueue mechsounds;
MechLegsBase legs_reference;
bool buttonTick;
bool btn_userfive;
bool pilotlook;
bool isdead;
bool docopy_novoodoo;
int ticks;
int prevticks;
float mech_tonnage;
float defaultfov;
float kph_default;
float kph_real;

// Properties
class<CockpitHandler> cphandler;
class<MechLegsBase> mech_legs;
class<Mechbase_Engine> base_engine;
bool modelcockpit;
String hud_cockpit;
String hud_mech;


void ChangeMech(int invmech)
{
	mw_StoredMech curmech = new("mw_StoredMech");
	mw_StoredMech source = inv_context.mechs[invmech];
	
	// New inventory instance.
	let act = Spawn("Actor"); // Spawn dummy to create inv on.
	if(!act || !curmech) return;
	act.GiveInventory("mw_InvInfo",1);
	let ainv = mw_InvInfo(act.FindInventory("mw_InvInfo"));
	if(!ainv) return;
	ainv.Init();
	// Inventory transfer
	curmech.baseclass = baseclass;
	curmech.inv_context = ainv;
	curmech.active_inventory = Inv;
	inv_context.Swap(curmech.inv_context,source.inv_context);
	hardpoints = inv_context.hardpoints;
	Inv = source.active_inventory;
	// Take ownership of new inventory.
	for (let item = Inv; item != null; item = item.Inv)
		item.Owner = self;
	act.Inv = NULL;
	act.Destroy();
	
	// Assign defaults...
	console.printf("Changing to: %s",source.baseclass.getClassName());
	let defs = MechWarriorBase(GetDefaultByType(source.baseclass));
	baseclass = source.baseclass;
	ViewHeight = defs.ViewHeight;
	baseHeatEfficiency = defs.baseHeatEfficiency;
	LegSpeed = defs.LegSpeed;
	MaxYaw = defs.MaxYaw;
	minPitch = defs.minPitch;
	maxPitch = defs.maxPitch;
	mech_tonnage = defs.mech_tonnage;
	hud_mech = defs.hud_mech;
	hud_cockpit = defs.hud_cockpit;
	base_engine = defs.base_engine;
	defaultmovement = defs.defaultmovement;
	uncappedtorso = defs.uncappedtorso;
	overtonnage = defs.overtonnage;
	modelcockpit = defs.modelcockpit;
	cphandler = defs.cphandler;
	mech_legs = defs.mech_legs;
	mechtype = defs.mechtype;
	nofirstpersonlegs = defs.nofirstpersonlegs;
	player.viewheight = defs.ViewHeight;
	
	inv_context.mechs.Delete(invmech);
	inv_context.mechs.Insert(invmech,curmech);
	
	// Update vars
	player.PendingWeapon = Weapon(FindInventory(cphandler));
	DropWeapon();
	BringUpWeapon();
	if(legs_reference) legs_reference.Destroy();
	legs_reference = NULL;
	setupSpeedKPH(EngineGetKPH());
}

mw_StoredMech CreateStoredMech(class<MechwarriorBase> type)
{
	let mechobj = new("mw_StoredMech");
	let mechact = MechwarriorBase(Spawn(type));
	if(mechobj && mechact)
	{
		mechact.GiveInventory(mechact.cphandler,1);
		mechact.docopy_novoodoo = true;
		mechact.setupInventory();
		mechobj.baseclass = type;
		mechobj.inv_context = mechact.inv_context;
		mechobj.active_inventory = mechact.Inv;
		
		// Prevent deletion of critical data structures.
		mechact.inv_context = NULL;
		mechact.Inv = NULL;
		mechact.Destroy();
	}
	return mechobj;
}

// Inventory
bool setupInventory()
{
	if(!FindInventory(cphandler)) GiveInventory(cphandler,1);
	if(!inv_context)
	{
		GiveInventory("mw_InvInfo",1);
		inv_context = mw_InvInfo(FindInventory("mw_InvInfo"));
		inv_context.Init();
		hardpoints = inv_context.hardpoints;
		setupWeapons();
		if(!EquipEngine(base_engine))
		{
			console.printf("Pilot Error -> Failed to equip mech's engine, too heavy or not enough free slots!");
		}
		setupCriticals();		
	}
	return inv_context==NULL;
}

void setupCriticals()
{
	// Setup criticals
	equipStruct("StructLifesupport",hardpoints.hd);
	equipStruct("StructSensors",hardpoints.hd);
	equipStruct("StructCockpit",hardpoints.hd);
	equipStruct("StructGyro",hardpoints.hd);
	equipStruct("StructHip",hardpoints.lt);
	equipStruct("StructHip",hardpoints.rt);
	equipStruct("StructActuator",hardpoints.la);
	equipStruct("StructActuator",hardpoints.ra);
}


// Virtual
virtual void SetupWeapons() 
{
	hardpoints.setupLocations( (0,20), (0,0), (-30,-15), (30,-15), (-120,0), (120,0), (-60,-30), (60,-30) );
	hardpoints.setupSlots();
}

// Override
override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
{	
	if(checkVoodoo()) return super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	
	float newdmg = float(damage)/10;
	if( !source ) 
	{
		ProcessHardpointDamage(mod,newdmg);
		return 0;
	}
	
	Actor damager = inflictor;
	if(mod == "hitscan") damager = source;
	double shootslope = (source.height); // * 0.5

	// Preform ray cast to determine where the shooter is aiming.
	FLineTraceData lt;
	damager.LineTrace(inflictor.angle+90,2048,source.pitch+random(-8,16),0,shootslope-random(0,source.height/4),0,0,lt);
	vector3 dmgpos = lt.HitLocation;
	double plrdmgz = (viewheight*Player.crouchfactor);

	vector2 mechangle = ( pos.x, pos.y );
	vector2 dmgpos2D  = ( dmgpos.x, dmgpos.y );
	mechangle = MDMath.VRotate(mechangle,angle+90);
	int lrpos = AngleTo(source);
	float hitangle = abs(atan2(mechangle.x - dmgpos.x , mechangle.y - dmgpos.y)) + frandom(-8,8);
	
	// Legs
	if( dmgpos.z < pos.z+(plrdmgz/4) ) 
	{ 
		if(lrpos > 0) ProcessHardpointDamage("MechDamage_LL",newdmg,damager);
		if(lrpos < 0) ProcessHardpointDamage("MechDamage_RL",newdmg,damager);
	}
	else // Torso
	{	
		// left/right torsos
		if( hitangle > 40 && hitangle < 100)
		{
			if(lrpos < 0) ProcessHardpointDamage("MechDamage_RT",newdmg,damager);
			if(lrpos > 0) ProcessHardpointDamage("MechDamage_LT",newdmg,damager);
		}
		// Left/right arm
		else if( hitangle >= 100 )
		{
			if(lrpos < 0) ProcessHardpointDamage("MechDamage_RA",newdmg,damager);
			if(lrpos > 0) ProcessHardpointDamage("MechDamage_LA",newdmg,damager);
		}
		// Center torso
		else
		{
			ProcessHardpointDamage("MechDamage_CT",newdmg,damager);
		}
	}
	
	return 0;
}

override void PostBeginPlay()
{
	// Spawn pieces (WIP)
	if(mech_legs) legs_reference = MechLegsBase.Create(mech_legs, self);
	
	// Setup mech support systems.
	if(checkVoodoo()) 
	{
		super.PostBeginPlay();
		return;
	}
	setupInventory();
	
	baseclass = GetClassName();
	weapons_fired = false;
	weapon_groupfire = false;
	selectedGroup = 1;
	selectedWeapon = 1;
	mech_jetsfuel = 100;
	inv_context.maxgroup = getMaxWeaponGrouping();
	defaultfov = player.desiredFOV;
			
	// SoundQueue 
	mechsounds = SoundQueue.SQ_Create(self, 32);
	
	speed = 0; // Stop normal movement;
	LegAng = angle;
	
	throttle_max = 1;
	if(defaultmovement) 
	{
		A_SetSpeed(MoveSpeed*0.08);
		level.aircontrol = 1;
		level.airfriction = 0.87;
	}	
	
	//inv_context.mechs.Push(CreateStoredMech("Atlas"));
	//startMechbay();
	super.PostBeginPlay();
}
	
override void tick()
{	
	if(checkVoodoo()) 
	{
		super.Tick();
		return;
	}
		
	// Clamp viewheight so we don't end up inside our hips when we fall.
	player.viewheight = clamp(player.viewheight, default.viewheight*0.8, default.viewheight*2.0);
	
	// Turns out, we lose our legs when moving to another map, LOL.
	if(!legs_reference && mech_legs) legs_reference = MechLegsBase.Create(mech_legs, self);
	if(!inv_context) setupInventory();	
	if(!dronecam) player.camera = self;
	
	// Make sure player doesn't have any actual weapons.
	for(let w = Inv; w != null; w = w.Inv)
	{
		let weap = Weapon(w);
		if(weap)
		{
			if(!(weap is "CockpitHandler")) weap.Destroy();
		}
	}
	
	if(!isdead) 
	{		
		// Don't hold onto dead target.
		if(targetenemy && targetenemy.health <= 0) targetenemy = null;
		
		mech_cockpitbob();
		mech_movement(); 
		if(!mech_shutdown)
		{
			if(vel.length() > 0) A_Explode(3+(vel.length()*1.5),30,!XF_HURTSOURCE);
			HardpointDamageEffects();
			mech_weapons();
		}
		if(mech_shutdown)process_shutdown();
	}
	mechsounds.Tick();
	
	super.tick();
}