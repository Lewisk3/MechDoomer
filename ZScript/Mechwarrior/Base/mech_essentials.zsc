	/*****************************\
	|	  Essential Functions     |
	\*****************************/
extend class MechwarriorBase;

// Vars
bool forceshutdown;
class<MechwarriorBase> baseclass;
mw_InvInfo inv_context;
MechHardpoints hardpoints;
HudAlert hAlert;
SoundQueue mechsounds;
MechTorsoBase models_reference;
bool buttonTick;
bool btn_userfive;
bool pilotlook;
bool isdead;
bool docopy_novoodoo;
int ticks;
int prevticks;
float mech_tonnage;
float defaultfov;
float kph_default;
float kph_real;
float worth;
Array<mw_InvStruct> shopitems;
Array<mw_StoredMech> shopmechs;

// Properties
class<MechTorsoBase> mech_models;
class<Mechbase_Engine> base_engine;
bool modelcockpit;
String hud_cockpit;
String hud_mech;


void StartMechChange(int invmech)
{
	if(!mech_shutdown)
	{
		mechsounds.pushSound("Mech/Betty/ShuttingDown");
		A_PlaySound("Mech/Shutdown",1);
	}
	mech_shutdown = true; 
	manualshutdown = true;
	forceshutdown = true;
    MechExchange_Animator.Setup(self, invmech);
}

void ChangeMech(int invmech)
{
	mw_StoredMech curmech = new("mw_StoredMech");
	mw_StoredMech source = inv_context.mechs[invmech];
	
	if(!source) 
	{	
		curmech.Destroy();
		console.printf("[Failed to deploy mech] -> Source mech doesn't exist!");
		return;
	}
	
	curmech.baseclass = baseclass;
	curmech.inv_context = inv_context;
	curmech.inv_defs = new("mw_MechInvDefaults");
	curmech.inv_defs.weapons_tonnage = inv_context.weapons_tonnage;
	curmech.inv_defs.heateff = HeatEfficiency;
	curmech.inv_defs.weapons_count = inv_context.weapons_count;
	curmech.inv_defs.armor_tonnage = inv_context.armor_tonnage;
	curmech.inv_defs.engine = inv_context.engine;
	curmech.inv_defs.MoveSpeedKPH = MoveSpeedKPH;
	
	inv_context.Swap(source.inv_context);
	inv_context = source.inv_context;
	hardpoints = inv_context.hardpoints;
	GetStoredWeapons(curmech.active_weapons);
	
	// Destroy current weapons.
	for(let w = Inv; w != null; w = w.Inv)
	{
		let weap = Weapon(w);
		if(weap)
		{
			if(weap is "Mechbase_Weapon") RemoveInventory(weap);
		}
	}
	
	// Load new weapons
	for(int i = source.active_weapons.Size()-1; i >= 0; i--)
	{
		let ww = source.active_weapons[i];
		if(ww) 
		{	
			let weap = Mechbase_Weapon(Spawn(ww.baseclass));
			if(weap)
			{
				weap.group = ww.group;
				weap.WeaponID = ww.WeaponID;
				weap.hardpoint = ww.hardpoint;
				AddInventory(weap);
			}
		}
	}
	normalizeWeaponsID(0);
	
	// Setup Class Defaults
	//console.printf("Changing to: %s",source.baseclass.getClassName());
	let defs = MechWarriorBase(GetDefaultByType(source.baseclass));
	baseclass = source.baseclass;
	baseHeatEfficiency = defs.baseHeatEfficiency;
	LegSpeed = defs.LegSpeed;
	MaxYaw = defs.MaxYaw;
	minPitch = defs.minPitch;
	maxPitch = defs.maxPitch;
	mech_tonnage = defs.mech_tonnage;
	hud_mech = defs.hud_mech;
	hud_cockpit = defs.hud_cockpit;
	base_engine = defs.base_engine;
	defaultmovement = defs.defaultmovement;
	uncappedtorso = defs.uncappedtorso;
	overtonnage = defs.overtonnage;
	modelcockpit = defs.modelcockpit;
	mech_models = defs.mech_models;
	mechtype = defs.mechtype;
	nofirstpersonlegs = defs.nofirstpersonlegs;
	ViewHeight = defs.ViewHeight;
	defviewz = defs.ViewHeight;
	player.ViewHeight = defs.ViewHeight;
	viewzoffs = 0;
	
	// Update vars
	A_SetSpeed(0);
	if(models_reference) models_reference.Destroy();
	setupSpeedKPH(EngineGetKPH());
	
	inv_context.mechs.Delete(invmech);
	inv_context.mechs.Insert(invmech, curmech);
	return;
	
}

mw_StoredMech CreateStoredMech(class<MechwarriorBase> type, bool attachtomech=true)
{
	let mechobj = new("mw_StoredMech");
	let mechact = MechwarriorBase(Spawn(type));
	if(mechobj && mechact)
	{
		mechact.docopy_novoodoo = true;
		mechact.setupInventory();
		mechact.mech_weapons();
			
		mechobj.baseclass = type;
		mechobj.inv_context = mechact.inv_context;
		mechobj.inv_defs = new("mw_MechInvDefaults");
		mechobj.inv_defs.weapons_tonnage = mechact.inv_context.weapons_tonnage;
		mechobj.inv_defs.heateff = mechact.HeatEfficiency;
		mechobj.inv_defs.weapons_count = mechact.inv_context.weapons_count;
		mechobj.inv_defs.armor_tonnage = mechact.inv_context.armor_tonnage;
		mechobj.inv_defs.engine = mechact.inv_context.engine;
		mechobj.inv_defs.MoveSpeedKPH = mechact.MoveSpeedKPH;
		mechact.inv_context.active = false;
		if(attachtomech) AddInventory(mechobj.inv_context);
		mechact.GetStoredWeapons(mechobj.active_weapons);
		
		// Prevent deletion of critical data structures.
		mechact.inv_context = NULL;
		mechact.Destroy();
	}
	return mechobj;
}
void GetStoredWeapons(in out Array<mw_StoredWeapon> weaps)
{
	while(true)
	{
		let ww = Mechbase_Weapon(FindInventory("Mechbase_Weapon",true));
		if(!ww) break;
		let sweap = new("mw_StoredWeapon");
		sweap.Tag = resolveWeaponName(ww);
		sweap.baseclass = ww.GetClassName();
		sweap.group = ww.group;
		sweap.WeaponID = ww.WeaponID;
		sweap.hardpoint = ww.hardpoint;
		weaps.Push(sweap);
		RemoveInventory(ww);
	}
}


// Inventory
bool setupInventory()
{
	if(!FindInventory("WeaponsHandler")) GiveInventory("WeaponsHandler",1);
	if(!inv_context)
	{
		GiveInventory("mw_InvInfo",1);
		inv_context = mw_InvInfo(FindInventory("mw_InvInfo"));
		inv_context.Init();
		hardpoints = inv_context.hardpoints;
		setupWeapons();
		CalculateArmorWeight();
		if(!EquipEngine(base_engine))
		{
			console.printf("Pilot Error -> Failed to equip mech's engine, too heavy or not enough free slots!");
		}
		setupCriticals();		
	}
	return inv_context==NULL;
}

void setupCriticals()
{
	// Setup criticals
	equipStruct("StructLifesupport",hardpoints.hd);
	equipStruct("StructSensors",hardpoints.hd);
	equipStruct("StructCockpit",hardpoints.hd);
	equipStruct("StructGyro",hardpoints.hd);
	equipStruct("StructHip",hardpoints.lt);
	equipStruct("StructHip",hardpoints.rt);
	equipStruct("StructActuator",hardpoints.la);
	equipStruct("StructActuator",hardpoints.ra);
}


// Setup models
void TrySetupModels()
{
	if(mech_models && !models_reference) models_reference = MechTorsoBase(MechPartsBase.Create(mech_models, self));
}

// Virtual
virtual void SetupWeapons() 
{
	hardpoints.setupLocations( (0,20), (0,0), (-30,-15), (30,-15), (-120,0), (120,0), (-60,-30), (60,-30) );
	hardpoints.setupSlots();
}

// Override
override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
{	
	if(checkVoodoo()) return super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	
	float newdmg = float(damage)*MWGAMEPLAY_DAMAGESCALE;
	if( !source ) 
	{
		ProcessHardpointDamage(mod,newdmg);
		return 0;
	}
	
	Actor damager = inflictor;
	if(mod == "hitscan") damager = source;
	double shootslope = (source.height); // * 0.5

	// Preform ray cast to determine where the shooter is aiming.
	FLineTraceData lt;
	damager.LineTrace(inflictor.angle,2048,source.pitch+random(-8,16),TRF_ABSOFFSET,shootslope-random(0,source.height/4),0,0,lt);
	vector3 dmgpos = lt.HitLocation;
	double plrdmgz = (viewheight*Player.crouchfactor);

	vector2 mechangle = ( pos.x, pos.y );
	vector2 dmgpos2D  = ( dmgpos.x, dmgpos.y );
	mechangle = MDMath.VRotate(mechangle,self.angle);
	float lrpos = atan2(source.pos.y - mechangle.y , source.pos.x - mechangle.x);
	float hitangle = abs((atan2(pos.x - dmgpos.x , pos.y - dmgpos.y))) + frandom(-8,8);
	hitangle = abs(hitangle-((self.angle-90)%180));
	// Legs
	if( dmgpos.z < pos.z+(plrdmgz/4) ) 
	{ 
		if(lrpos > 0) ProcessHardpointDamage("MechDamage_LL",newdmg,damager);
		if(lrpos < 0) ProcessHardpointDamage("MechDamage_RL",newdmg,damager);
	}
	else // Torso
	{	
		// left/right torsos
		if( hitangle > 40 && hitangle < 100)
		{
			if(lrpos < 0) ProcessHardpointDamage("MechDamage_RT",newdmg,damager);
			if(lrpos > 0) ProcessHardpointDamage("MechDamage_LT",newdmg,damager);
		}
		// Left/right arm
		else if( hitangle >= 100 )
		{
			if(lrpos < 0) ProcessHardpointDamage("MechDamage_RA",newdmg,damager);
			if(lrpos > 0) ProcessHardpointDamage("MechDamage_LA",newdmg,damager);
		}
		// Center torso
		else
		{
			ProcessHardpointDamage("MechDamage_CT",newdmg,damager);
		}
	}
	
	return 0;
}

override void PostBeginPlay()
{
	// Spawn pieces (WIP)
	TrySetupModels();
	
	// Setup mech support systems.
	if(checkVoodoo()) 
	{
		super.PostBeginPlay();
		return;
	}
	setupInventory();
	
	baseclass = GetClassName();
	weapons_fired = false;
	weapon_groupfire = false;
	selectedGroup = 1;
	selectedWeapon = 1;
	mech_jetsfuel = 100;
	defviewz = Player.ViewHeight;
	inv_context.maxgroup = getMaxWeaponGrouping();
	defaultfov = player.desiredFOV;
			
	// SoundQueue 
	mechsounds = SoundQueue.SQ_Create(self, 32);
	
	speed = 0; // Stop normal movement;
	LegAng = angle;
	
	throttle_max = 1;
	if(defaultmovement) 
	{
		A_SetSpeed(MoveSpeed*0.08);
		level.aircontrol = 1;
		level.airfriction = 0.87;
	}	
	
	//inv_context.mechs.Push(CreateStoredMech("Atlas"));
	//startMechbay();
	super.PostBeginPlay();
}
	
override void tick()
{
	// Hold onto reference of all mechs for shop
	if(!shopmechs.Size()) GetAllMechs(shopmechs);
	
	if(checkVoodoo()) 
	{
		super.Tick();
		return;
	}
	
	// Clamp viewheight so we don't end up inside our hips when we fall.
	player.viewheight = clamp(player.viewheight, defviewz*0.8, defviewz*2.0);
	
	// Turns out, we lose our models when moving to another map.
	TrySetupModels();
	
	if(!inv_context) setupInventory();	
	if(!dronecam) player.camera = self;
	
	// Make sure player doesn't have any actual weapons.
	for(let w = Inv; w != null; w = w.Inv)
	{
		let weap = Weapon(w);
		if(weap)
		{
			if(!(weap is "WeaponsHandler")) weap.Destroy();
		}
	}
	
	if(!isdead) 
	{		
		// Don't hold onto dead target.
		if(targetenemy && targetenemy.health <= 0) targetenemy = null;
		
		mech_cockpitbob();
		mech_movement(); 
		if(!mech_shutdown)
		{
			if(vel.length() > 0) A_Explode(3+(vel.length()*1.5),30,!XF_HURTSOURCE);
			HardpointDamageEffects();
			mech_weapons();
		}
		if(mech_shutdown)
		{
			dronecam_active = false;
			process_shutdown();
		}
	}
	mechsounds.Tick();
	
	super.tick();
}