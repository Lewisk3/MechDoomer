struct HudAlert 
{	
	String text;
	int col;
}
class mw_InvStruct
{
	string Tag;
	Array<String> description;
	class<Mechbase_Utility> utiltype;
	MechutilDefs utildefs;
	MechHardpoint hardpoint;
	bool broken;
	int dmg_taken;
	int ammunition; // Contains ammo left in structure.
	int hardslots;
	String displayName;
	float weight;
	bool moveable;
	bool takesnodamage;
	int worth;
}

// Create Stored weapon, Array<Mechbase_Weapon> does NOT persist!
class mw_StoredWeapon : Object
{
	class<Mechbase_Weapon> baseclass;
	int group;
	int WeaponID;
	MechHardpoint hardpoint;
}
class mw_StoredMech : Object
{
	mw_InvInfo inv_context;
	Array<mw_StoredWeapon> active_weapons;
	class<MechWarriorBase> baseclass;
}
class mw_InvInfo : Inventory
{
	MechHardpoints hardpoints;
	Array<mw_InvStruct> weapon_items; // Stores all mech items before they go into the inventory.
	Array<mw_InvStruct> mechstructs;  // These are equipped structs.
	Array<mw_StoredMech> mechs;
	Mechbase_EngineOBJ engine;
	int weapons_count;
	int maxgroup;
	float heateff;
	bool active;
	
	int money_cbills;			// moneys
	float weapons_tonnage;		// How much weapons weigh.
	
	void Init()
	{
		hardpoints = MechHardpoints.Create();
	}	

	// Moves source to local mw_InvInfo, moves old info to dest.
	void Swap(mw_InvInfo source)
	{	
		// All new lists are added to the inventory, 
		// they're just toggled in how active they are.
		source.mechs.Clear();
		source.mechs.Copy(mechs);
		source.money_cbills = money_cbills;
		source.weapon_items.Clear();
		source.weapon_items.Copy(weapon_items);
		
		source.active = true;
		active = false;
	}
	
	mw_InvStruct GiveItem(String type)
	{
		let item = NewItem(type);
		if(item) weapon_items.push(item);
		return item;
	}
	mw_InvStruct NewItem(String type)
	{
		class<Mechbase_Utility> util = type;
		let typeobj = util==NULL ? NULL : Mechbase_Utility.CreateTemp(util);
		let item = new("mw_InvStruct");
		if(item)
		{
			item.Tag = type;
			if(typeobj) 
			{
				item.utiltype = type;
				typeobj.SetupItem(item);
			}
		}
		if(typeobj) typeobj.Destroy();
		return item;
	}
	void GiveItems(String type, int amt)
	{
		for(int i = 0; i < amt; i++) GiveItem(type);
	}
	void MoveToItems(int ind)
	{
		mechstructs[ind].hardpoint = NULL;
		weapon_items.push(mechstructs[ind]);
		mechstructs.delete(ind);
	}
	
	Default
	{
		inventory.maxamount 1;
	}
}
class MechWarriorBase : DoomPlayer
{
	// Chassis properties
	Property heatEff  : baseHeatEfficiency;
	Property LegSpeed : LegSpeed;
	Property TwistRange : MaxYaw;
	Property PitchRange : minPitch, maxPitch;
	Property Weight : mech_tonnage;
	Property HudMech : hud_mech;
	Property HudCockpit : hud_cockpit;
	Property Engine : base_engine;
	Property DefaultMovement: defaultmovement;
	Property InfiniteTorsoTwist: uncappedtorso;
	Property OverTonnage: overtonnage;
	Property CockpitIsModel: modelcockpit;
	Property SetCockpitHandler: cphandler;
	Property MechPieces : mech_torso, mech_legs;
	Property Manufacturer : mechtype;
	Property HideLegsPerspective : nofirstpersonlegs;
	
	// Clearscope
	clearscope void sendHudAlert(String str, int c)
	{
		hAlert.text = str;
		hAlert.col = c;
	}
	clearscope class<Mechbase_Utility> utilcast(String type)
	{
		class<Mechbase_Utility> mechutil = type;
		return mechutil;
	}
	clearscope int checkItemWorth(String item)
	{
		class<Mechbase_Utility> item_ut = item;
		class<Mechbase_Weapon> item_weap = item;
		if(item_ut)return GetDefaultByType(item_ut).worth;
		if(item_weap)return GetDefaultByType(item_weap).worth;
		
		return 0;
	}
	clearscope bool checkVoodoo() 
	{ 
		return docopy_novoodoo ? false : (!player || !player.mo || player.mo != self); 
	}
	clearscope String getChassisName()
	{
		if(!baseclass) return "???";
		return GetDefaultByType(baseclass).getClassName();
	}
}